
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_table>:
	return cb(str, strl, ctx);
}

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
   0:	80 14 00 20 59 17 00 00 2f 59 00 00 15 17 00 00     ... Y.../Y......
	...
	 * When buf0 is NULL we don't store anything.
	 * Instead we count the needed space to store the data.
	 * In this case, incoming len argument indicates the anticipated
	 * buffer "misalignment" offset.
	 */
	if (buf0 == NULL) {
  2c:	45 15 00 00 00 00 00 00 00 00 00 00 dd 14 00 00     E...............
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  3c:	00 00 00 00                                         ....

00000040 <_irq_vector_table>:
  40:	b9 15 00 00 b9 15 00 00 b9 15 00 00 b9 15 00 00     ................
	 * Here we branch directly into the code processing strings
	 * which is in the middle of the following while() loop. That's the
	 * reason for the post-decrement on fmt as it will be incremented
	 * prior to the next (actually first) round of that loop.
	 */
	s = fmt--;
  50:	b9 15 00 00 b9 15 00 00 b9 15 00 00 b9 15 00 00     ................

		/* copy va_list data over to our buffer */
		if (is_str_arg) {
			s = va_arg(ap, char *);
process_string:
			if (buf0 != NULL) {
  60:	b9 15 00 00 b9 15 00 00 b9 15 00 00 b9 15 00 00     ................
				*(const char **)buf = s;
			}

			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
  70:	b9 15 00 00 b9 15 00 00 b9 15 00 00 b9 15 00 00     ................
#else
	#define RO_START 0
	#define RO_END 0
#endif

	return (((const char *)addr >= (const char *)RO_START) &&
  80:	b9 15 00 00 b9 15 00 00 b9 15 00 00 b9 15 00 00     ................
  90:	b9 15 00 00 b9 15 00 00 b9 15 00 00 b9 15 00 00     ................
			switch (*fmt) {
  a0:	b9 15 00 00 b9 15 00 00                             ........

Disassembly of section text:

000000a8 <__gnu_thumb1_case_uqi>:
      a8:	b402      	push	{r1}
      aa:	4671      	mov	r1, lr
      ac:	0849      	lsrs	r1, r1, #1
      ae:	0049      	lsls	r1, r1, #1
      b0:	5c09      	ldrb	r1, [r1, r0]
      b2:	0049      	lsls	r1, r1, #1
      b4:	448e      	add	lr, r1
				parsing = false;
      b6:	bc02      	pop	{r1}
				continue;
      b8:	4770      	bx	lr
			switch (*fmt) {
      ba:	46c0      	nop			; (mov r8, r8)

000000bc <__gnu_thumb1_case_shi>:
      bc:	b403      	push	{r0, r1}
      be:	4671      	mov	r1, lr
      c0:	0849      	lsrs	r1, r1, #1
      c2:	0040      	lsls	r0, r0, #1
      c4:	0049      	lsls	r1, r1, #1
      c6:	5e09      	ldrsh	r1, [r1, r0]
      c8:	0049      	lsls	r1, r1, #1
      ca:	448e      	add	lr, r1
      cc:	bc03      	pop	{r0, r1}
      ce:	4770      	bx	lr

000000d0 <__udivsi3>:
      d0:	2900      	cmp	r1, #0
      d2:	d034      	beq.n	13e <CONFIG_FLASH_SIZE+0x3e>

000000d4 <.udivsi3_skip_div0_test>:
      d4:	2301      	movs	r3, #1
      d6:	2200      	movs	r2, #0
      d8:	b410      	push	{r4}
      da:	4288      	cmp	r0, r1
      dc:	d32c      	bcc.n	138 <CONFIG_FLASH_SIZE+0x38>
      de:	2401      	movs	r4, #1
      e0:	0724      	lsls	r4, r4, #28
      e2:	42a1      	cmp	r1, r4
      e4:	d204      	bcs.n	f0 <.udivsi3_skip_div0_test+0x1c>
      e6:	4281      	cmp	r1, r0
      e8:	d202      	bcs.n	f0 <.udivsi3_skip_div0_test+0x1c>
      ea:	0109      	lsls	r1, r1, #4
      ec:	011b      	lsls	r3, r3, #4
      ee:	e7f8      	b.n	e2 <.udivsi3_skip_div0_test+0xe>
      f0:	00e4      	lsls	r4, r4, #3
      f2:	42a1      	cmp	r1, r4
      f4:	d204      	bcs.n	100 <CONFIG_FLASH_SIZE>
				parsing = false;
      f6:	4281      	cmp	r1, r0
			switch (*fmt) {
      f8:	d202      	bcs.n	100 <CONFIG_FLASH_SIZE>
      fa:	0049      	lsls	r1, r1, #1
      fc:	005b      	lsls	r3, r3, #1
      fe:	e7f8      	b.n	f2 <.udivsi3_skip_div0_test+0x1e>
     100:	4288      	cmp	r0, r1
     102:	d301      	bcc.n	108 <CONFIG_FLASH_SIZE+0x8>
     104:	1a40      	subs	r0, r0, r1
     106:	431a      	orrs	r2, r3
     108:	084c      	lsrs	r4, r1, #1
     10a:	42a0      	cmp	r0, r4
     10c:	d302      	bcc.n	114 <CONFIG_FLASH_SIZE+0x14>
     10e:	1b00      	subs	r0, r0, r4
     110:	085c      	lsrs	r4, r3, #1
     112:	4322      	orrs	r2, r4
     114:	088c      	lsrs	r4, r1, #2
     116:	42a0      	cmp	r0, r4
     118:	d302      	bcc.n	120 <CONFIG_FLASH_SIZE+0x20>
     11a:	1b00      	subs	r0, r0, r4
     11c:	089c      	lsrs	r4, r3, #2
     11e:	4322      	orrs	r2, r4
     120:	08cc      	lsrs	r4, r1, #3
		buf = (void *) ROUND_UP(buf, align);
     122:	42a0      	cmp	r0, r4
     124:	d302      	bcc.n	12c <CONFIG_FLASH_SIZE+0x2c>
     126:	1b00      	subs	r0, r0, r4
     128:	08dc      	lsrs	r4, r3, #3
     12a:	4322      	orrs	r2, r4
     12c:	2800      	cmp	r0, #0
		if (buf0 != NULL && BUF_OFFSET + size > len) {
     12e:	d003      	beq.n	138 <CONFIG_FLASH_SIZE+0x38>
     130:	091b      	lsrs	r3, r3, #4
     132:	d001      	beq.n	138 <CONFIG_FLASH_SIZE+0x38>
     134:	0909      	lsrs	r1, r1, #4
     136:	e7e3      	b.n	100 <CONFIG_FLASH_SIZE>
     138:	0010      	movs	r0, r2
     13a:	bc10      	pop	{r4}
     13c:	4770      	bx	lr
		if (is_str_arg) {
     13e:	b501      	push	{r0, lr}
     140:	2000      	movs	r0, #0
				s_idx++;
			}
			buf += sizeof(char *);

			is_str_arg = false;
		} else if (size == sizeof(int)) {
     142:	f000 f85f 	bl	204 <__aeabi_idiv0>
			int v = va_arg(ap, int);
     146:	bd02      	pop	{r1, pc}

00000148 <__aeabi_uidivmod>:

			if (buf0 != NULL) {
				*(int *)buf = v;
     148:	2900      	cmp	r1, #0
     14a:	d0f8      	beq.n	13e <CONFIG_FLASH_SIZE+0x3e>
			}
			buf += sizeof(int);
     14c:	b503      	push	{r0, r1, lr}
     14e:	f7ff ffc1 	bl	d4 <.udivsi3_skip_div0_test>
     152:	bc0e      	pop	{r1, r2, r3}
     154:	4342      	muls	r2, r0
				arg_idx--;
     156:	1a89      	subs	r1, r1, r2
     158:	4718      	bx	r3
     15a:	46c0      	nop			; (mov r8, r8)

0000015c <__divsi3>:
				parsing = false;
     15c:	2900      	cmp	r1, #0
     15e:	d041      	beq.n	1e4 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x77>

00000160 <.divsi3_skip_div0_test>:
				if (fmt[-1] == 'l') {
     160:	b410      	push	{r4}
     162:	0004      	movs	r4, r0
     164:	404c      	eors	r4, r1
				parsing = false;
     166:	46a4      	mov	ip, r4
				if (fmt[-1] == 'l') {
     168:	2301      	movs	r3, #1
     16a:	2200      	movs	r2, #0
				align = VA_STACK_ALIGN(void *);
     16c:	2900      	cmp	r1, #0
					if (fmt[-2] == 'l') {
     16e:	d500      	bpl.n	172 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x5>
				size = sizeof(void *);
     170:	4249      	negs	r1, r1
					if (fmt[-2] == 'l') {
     172:	2800      	cmp	r0, #0
     174:	d500      	bpl.n	178 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0xb>
     176:	4240      	negs	r0, r0
						align = VA_STACK_ALIGN(long long);
     178:	4288      	cmp	r0, r1
			switch (*fmt) {
     17a:	d32c      	bcc.n	1d6 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x69>
     17c:	2401      	movs	r4, #1
					v.ld = va_arg(ap, long double);
     17e:	0724      	lsls	r4, r4, #28
				buf = (void *) ROUND_UP(buf, align);
     180:	42a1      	cmp	r1, r4
					v.ld = va_arg(ap, long double);
     182:	d204      	bcs.n	18e <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x21>
     184:	4281      	cmp	r1, r0
				buf = (void *) ROUND_UP(buf, align);
     186:	d202      	bcs.n	18e <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x21>
     188:	0109      	lsls	r1, r1, #4
					v.ld = va_arg(ap, long double);
     18a:	011b      	lsls	r3, r3, #4
				if (buf0 != NULL) {
     18c:	e7f8      	b.n	180 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x13>
     18e:	00e4      	lsls	r4, r4, #3
					if (BUF_OFFSET + size > len) {
     190:	42a1      	cmp	r1, r4
     192:	d204      	bcs.n	19e <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x31>
     194:	4281      	cmp	r1, r0
     196:	d202      	bcs.n	19e <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x31>
     198:	0049      	lsls	r1, r1, #1
     19a:	005b      	lsls	r3, r3, #1
     19c:	e7f8      	b.n	190 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x23>
						*(long double *)buf = v.ld;
     19e:	4288      	cmp	r0, r1
     1a0:	d301      	bcc.n	1a6 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x39>
				parsing = false;
     1a2:	1a40      	subs	r0, r0, r1
				buf += size;
     1a4:	431a      	orrs	r2, r3
     1a6:	084c      	lsrs	r4, r1, #1
				parsing = false;
     1a8:	42a0      	cmp	r0, r4
			switch (*fmt) {
     1aa:	d302      	bcc.n	1b2 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x45>
     1ac:	1b00      	subs	r0, r0, r4
     1ae:	085c      	lsrs	r4, r3, #1
     1b0:	4322      	orrs	r2, r4
     1b2:	088c      	lsrs	r4, r1, #2
			if (*++fmt == '\0') {
     1b4:	42a0      	cmp	r0, r4
     1b6:	d302      	bcc.n	1be <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x51>
     1b8:	1b00      	subs	r0, r0, r4
     1ba:	089c      	lsrs	r4, r3, #2
     1bc:	4322      	orrs	r2, r4
			if (!parsing) {
     1be:	08cc      	lsrs	r4, r1, #3
     1c0:	42a0      	cmp	r0, r4
     1c2:	d302      	bcc.n	1ca <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x5d>
     1c4:	1b00      	subs	r0, r0, r4
				if (*fmt == '%') {
     1c6:	08dc      	lsrs	r4, r3, #3
     1c8:	4322      	orrs	r2, r4
					arg_idx++;
     1ca:	2800      	cmp	r0, #0
     1cc:	d003      	beq.n	1d6 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x69>
     1ce:	091b      	lsrs	r3, r3, #4
					parsing = true;
     1d0:	d001      	beq.n	1d6 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x69>
     1d2:	0909      	lsrs	r1, r1, #4
				align = VA_STACK_ALIGN(size_t);
     1d4:	e7e3      	b.n	19e <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x31>
     1d6:	0010      	movs	r0, r2
			switch (*fmt) {
     1d8:	4664      	mov	r4, ip
     1da:	2c00      	cmp	r4, #0
     1dc:	d500      	bpl.n	1e0 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x73>
     1de:	4240      	negs	r0, r0

			if (buf0 != NULL) {
				*(long *)buf = v;
			}
			buf += sizeof(long);
		} else if (size == sizeof(long long)) {
     1e0:	bc10      	pop	{r4}
     1e2:	4770      	bx	lr
     1e4:	b501      	push	{r0, lr}
			long long v = va_arg(ap, long long);
     1e6:	2000      	movs	r0, #0

			if (buf0 != NULL) {
				if (Z_CBPRINTF_VA_STACK_LL_DBL_MEMCPY) {
					memcpy(buf, &v, sizeof(long long));
				} else {
					*(long long *)buf = v;
     1e8:	f000 f80c 	bl	204 <__aeabi_idiv0>
			long long v = va_arg(ap, long long);
     1ec:	bd02      	pop	{r1, pc}
     1ee:	46c0      	nop			; (mov r8, r8)

000001f0 <__aeabi_idivmod>:
					*(long long *)buf = v;
     1f0:	2900      	cmp	r1, #0
     1f2:	d0f7      	beq.n	1e4 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x77>
				}
			}
			buf += sizeof(long long);
     1f4:	b503      	push	{r0, r1, lr}
     1f6:	f7ff ffb3 	bl	160 <.divsi3_skip_div0_test>
     1fa:	bc0e      	pop	{r1, r2, r3}
     1fc:	4342      	muls	r2, r0
		if (is_str_arg) {
     1fe:	1a89      	subs	r1, r1, r2
     200:	4718      	bx	r3
		} else if (size == sizeof(int)) {
     202:	46c0      	nop			; (mov r8, r8)

00000204 <__aeabi_idiv0>:
     204:	4770      	bx	lr
			int v = va_arg(ap, int);
     206:	46c0      	nop			; (mov r8, r8)

00000208 <__clzsi2>:
			if (buf0 != NULL) {
     208:	211c      	movs	r1, #28
		} else if (size == sizeof(long long)) {
     20a:	2301      	movs	r3, #1
     20c:	041b      	lsls	r3, r3, #16
			long long v = va_arg(ap, long long);
     20e:	4298      	cmp	r0, r3
     210:	d301      	bcc.n	216 <__clzsi2+0xe>
     212:	0c00      	lsrs	r0, r0, #16
     214:	3910      	subs	r1, #16
			if (buf0 != NULL) {
     216:	0a1b      	lsrs	r3, r3, #8
			if (*++fmt == '\0') {
     218:	4298      	cmp	r0, r3
     21a:	d301      	bcc.n	220 <__clzsi2+0x18>
     21c:	0a00      	lsrs	r0, r0, #8
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
     21e:	3908      	subs	r1, #8
     220:	091b      	lsrs	r3, r3, #4
     222:	4298      	cmp	r0, r3
			s = va_arg(ap, char *);
     224:	d301      	bcc.n	22a <__clzsi2+0x22>
     226:	0900      	lsrs	r0, r0, #4
     228:	3904      	subs	r1, #4
			if (is_ro && !do_ro) {
     22a:	a202      	add	r2, pc, #8	; (adr r2, 234 <__clzsi2+0x2c>)
     22c:	5c10      	ldrb	r0, [r2, r0]
     22e:	1840      	adds	r0, r0, r1
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
     230:	4770      	bx	lr
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
     232:	46c0      	nop			; (mov r8, r8)
     234:	02020304 	.word	0x02020304
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
     238:	01010101 	.word	0x01010101
	...

00000244 <__ctzsi2>:
					__ASSERT(false, "String with too many arguments");
     244:	4241      	negs	r1, r0
     246:	4008      	ands	r0, r1
     248:	211c      	movs	r1, #28
     24a:	2301      	movs	r3, #1
     24c:	041b      	lsls	r3, r3, #16
     24e:	4298      	cmp	r0, r3
     250:	d301      	bcc.n	256 <__ctzsi2+0x12>
     252:	0c00      	lsrs	r0, r0, #16
     254:	3910      	subs	r1, #16
					__ASSERT(false, "str_ptr_pos[] too small");
     256:	0a1b      	lsrs	r3, r3, #8
     258:	4298      	cmp	r0, r3
     25a:	d301      	bcc.n	260 <__ctzsi2+0x1c>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
     25c:	0a00      	lsrs	r0, r0, #8
     25e:	3908      	subs	r1, #8
     260:	091b      	lsrs	r3, r3, #4
				if (buf0 != NULL) {
     262:	4298      	cmp	r0, r3
     264:	d301      	bcc.n	26a <__ctzsi2+0x26>
					str_ptr_pos[s_idx] = s_ptr_idx;
     266:	0900      	lsrs	r0, r0, #4
     268:	3904      	subs	r1, #4
     26a:	a202      	add	r2, pc, #8	; (adr r2, 274 <__ctzsi2+0x30>)
					str_ptr_arg[s_idx] = arg_idx;
     26c:	5c10      	ldrb	r0, [r2, r0]
     26e:	1a40      	subs	r0, r0, r1
     270:	4770      	bx	lr
     272:	46c0      	nop			; (mov r8, r8)
						s_rw_cnt++;
     274:	1d1d1c1b 	.word	0x1d1d1c1b
     278:	1e1e1e1e 	.word	0x1e1e1e1e
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
     27c:	1f1f1f1f 	.word	0x1f1f1f1f
     280:	1f1f1f1f 	.word	0x1f1f1f1f

00000284 <__aeabi_uldivmod>:
					__ASSERT(false, "str_ptr_pos[] too small");
     284:	2b00      	cmp	r3, #0
     286:	d111      	bne.n	2ac <__aeabi_uldivmod+0x28>
     288:	2a00      	cmp	r2, #0
     28a:	d10f      	bne.n	2ac <__aeabi_uldivmod+0x28>
     28c:	2900      	cmp	r1, #0
     28e:	d100      	bne.n	292 <__aeabi_uldivmod+0xe>
     290:	2800      	cmp	r0, #0
     292:	d002      	beq.n	29a <__aeabi_uldivmod+0x16>
     294:	2100      	movs	r1, #0
     296:	43c9      	mvns	r1, r1
     298:	0008      	movs	r0, r1
     29a:	b407      	push	{r0, r1, r2}
     29c:	4802      	ldr	r0, [pc, #8]	; (2a8 <__aeabi_uldivmod+0x24>)
				if (buf0 != NULL) {
     29e:	a102      	add	r1, pc, #8	; (adr r1, 2a8 <__aeabi_uldivmod+0x24>)
     2a0:	1840      	adds	r0, r0, r1
					str_ptr_pos[s_idx] = s_ptr_idx;
     2a2:	9002      	str	r0, [sp, #8]
     2a4:	bd03      	pop	{r0, r1, pc}
     2a6:	46c0      	nop			; (mov r8, r8)
     2a8:	ffffff5d 	.word	0xffffff5d
					str_ptr_arg[s_idx] = arg_idx;
     2ac:	b403      	push	{r0, r1}
     2ae:	4668      	mov	r0, sp
     2b0:	b501      	push	{r0, lr}
					if (is_ro) {
     2b2:	9802      	ldr	r0, [sp, #8]
     2b4:	f000 f84c 	bl	350 <__udivmoddi4>
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
     2b8:	9b01      	ldr	r3, [sp, #4]
     2ba:	469e      	mov	lr, r3
     2bc:	b002      	add	sp, #8
     2be:	bc0c      	pop	{r2, r3}
     2c0:	4770      	bx	lr
						s_ro_cnt++;
     2c2:	46c0      	nop			; (mov r8, r8)

000002c4 <__aeabi_llsr>:
     2c4:	40d0      	lsrs	r0, r2
     2c6:	000b      	movs	r3, r1
				s_idx++;
     2c8:	40d1      	lsrs	r1, r2
     2ca:	469c      	mov	ip, r3
     2cc:	3a20      	subs	r2, #32
			buf += sizeof(char *);
     2ce:	40d3      	lsrs	r3, r2
     2d0:	4318      	orrs	r0, r3
     2d2:	4252      	negs	r2, r2
			is_str_arg = false;
     2d4:	4663      	mov	r3, ip
     2d6:	4093      	lsls	r3, r2
     2d8:	4318      	orrs	r0, r3
				} else if (is_ro) {
     2da:	4770      	bx	lr

000002dc <__aeabi_llsl>:
     2dc:	4091      	lsls	r1, r2
					len += 1;
     2de:	0003      	movs	r3, r0
     2e0:	4090      	lsls	r0, r2
					len += strlen(s) + 1 + 1;
     2e2:	469c      	mov	ip, r3
     2e4:	3a20      	subs	r2, #32
					len += 2;
     2e6:	4093      	lsls	r3, r2
     2e8:	4319      	orrs	r1, r3
     2ea:	4252      	negs	r2, r2
				} else if (rws_pos_en) {
     2ec:	4663      	mov	r3, ip
     2ee:	40d3      	lsrs	r3, r2
     2f0:	4319      	orrs	r1, r3
					len += strlen(s) + 1 + 1;
     2f2:	4770      	bx	lr

000002f4 <__clzdi2>:
     2f4:	b510      	push	{r4, lr}
     2f6:	2900      	cmp	r1, #0
     2f8:	d103      	bne.n	302 <__clzdi2+0xe>
     2fa:	f7ff ff85 	bl	208 <__clzsi2>
		} else {
			__ASSERT(false, "unexpected size %u", size);
     2fe:	3020      	adds	r0, #32
     300:	e002      	b.n	308 <__clzdi2+0x14>
     302:	0008      	movs	r0, r1
     304:	f7ff ff80 	bl	208 <__clzsi2>
     308:	bd10      	pop	{r4, pc}
     30a:	46c0      	nop			; (mov r8, r8)

0000030c <__aeabi_lmul>:
     30c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
     30e:	0c04      	lsrs	r4, r0, #16
     310:	000d      	movs	r5, r1
     312:	b291      	uxth	r1, r2
     314:	000f      	movs	r7, r1
     316:	4361      	muls	r1, r4
     318:	468c      	mov	ip, r1
     31a:	0006      	movs	r6, r0
     31c:	9301      	str	r3, [sp, #4]
     31e:	b283      	uxth	r3, r0
     320:	0c10      	lsrs	r0, r2, #16
     322:	435f      	muls	r7, r3
     324:	4344      	muls	r4, r0
     326:	4358      	muls	r0, r3
     328:	0c3b      	lsrs	r3, r7, #16
     32a:	4460      	add	r0, ip
     32c:	181b      	adds	r3, r3, r0
     32e:	4299      	cmp	r1, r3
     330:	d902      	bls.n	338 <__aeabi_lmul+0x2c>
     332:	2180      	movs	r1, #128	; 0x80
     334:	0249      	lsls	r1, r1, #9
     336:	1864      	adds	r4, r4, r1
     338:	9901      	ldr	r1, [sp, #4]
     33a:	4355      	muls	r5, r2
     33c:	4371      	muls	r1, r6
     33e:	0c18      	lsrs	r0, r3, #16
     340:	1904      	adds	r4, r0, r4
     342:	041b      	lsls	r3, r3, #16
	 * We remember the size of the argument list as a multiple of
	 * sizeof(int) and limit it to a 8-bit field. That means 1020 bytes
	 * worth of va_list, or about 127 arguments on a 64-bit system
	 * (twice that on 32-bit systems). That ought to be good enough.
	 */
	if (BUF_OFFSET / sizeof(int) > 255) {
     344:	b2bf      	uxth	r7, r7
     346:	1949      	adds	r1, r1, r5
     348:	19d8      	adds	r0, r3, r7
     34a:	1909      	adds	r1, r1, r4
     34c:	b003      	add	sp, #12
     34e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00000350 <__udivmoddi4>:
		__ASSERT(false, "too many format args");
     350:	b5f0      	push	{r4, r5, r6, r7, lr}
     352:	0006      	movs	r6, r0
     354:	000f      	movs	r7, r1
     356:	0015      	movs	r5, r2
     358:	001c      	movs	r4, r3
     35a:	b085      	sub	sp, #20
     35c:	428b      	cmp	r3, r1
     35e:	d863      	bhi.n	428 <CONFIG_MAIN_STACK_SIZE+0x28>
     360:	d101      	bne.n	366 <__udivmoddi4+0x16>
     362:	4282      	cmp	r2, r0
     364:	d860      	bhi.n	428 <CONFIG_MAIN_STACK_SIZE+0x28>
     366:	0021      	movs	r1, r4

	/*
	 * If all we wanted was to count required buffer size
	 * then we have it now.
	 */
	if (buf0 == NULL) {
     368:	0028      	movs	r0, r5
     36a:	f7ff ffc3 	bl	2f4 <__clzdi2>
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
     36e:	0039      	movs	r1, r7
     370:	9000      	str	r0, [sp, #0]
	return BUF_OFFSET;

#undef BUF_OFFSET
#undef STR_POS_RO_FLAG
#undef STR_POS_MASK
}
     372:	0030      	movs	r0, r6
     374:	f7ff ffbe 	bl	2f4 <__clzdi2>
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
     378:	9b00      	ldr	r3, [sp, #0]
	*(char **)buf0 = NULL;
     37a:	0021      	movs	r1, r4
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
     37c:	1a1b      	subs	r3, r3, r0
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
     37e:	001a      	movs	r2, r3
     380:	0028      	movs	r0, r5
	if (rws_pos_en) {
     382:	9303      	str	r3, [sp, #12]
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
     384:	f7ff ffaa 	bl	2dc <__aeabi_llsl>
	if (rws_pos_en) {
     388:	9000      	str	r0, [sp, #0]
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
     38a:	9101      	str	r1, [sp, #4]
	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
     38c:	42b9      	cmp	r1, r7
     38e:	d845      	bhi.n	41c <CONFIG_MAIN_STACK_SIZE+0x1c>
	if (s_ro_cnt) {
     390:	d101      	bne.n	396 <__udivmoddi4+0x46>
     392:	42b0      	cmp	r0, r6
			*buf++ = str_ptr_arg[i];
     394:	d842      	bhi.n	41c <CONFIG_MAIN_STACK_SIZE+0x1c>
     396:	9b00      	ldr	r3, [sp, #0]
	for (i = 0; i < s_idx; i++) {
     398:	9c01      	ldr	r4, [sp, #4]
     39a:	2001      	movs	r0, #1
     39c:	2100      	movs	r1, #0
	return BUF_OFFSET;
     39e:	9a03      	ldr	r2, [sp, #12]
     3a0:	1af6      	subs	r6, r6, r3
     3a2:	41a7      	sbcs	r7, r4
		pkg_hdr->desc.str_cnt = s_rw_cnt;
     3a4:	f7ff ff9a 	bl	2dc <__aeabi_llsl>
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
     3a8:	0004      	movs	r4, r0
     3aa:	000d      	movs	r5, r1
     3ac:	9b03      	ldr	r3, [sp, #12]
     3ae:	2b00      	cmp	r3, #0
     3b0:	d02b      	beq.n	40a <CONFIG_MAIN_STACK_SIZE+0xa>
     3b2:	9b01      	ldr	r3, [sp, #4]
			if (BUF_OFFSET + 1 > len) {
     3b4:	9a00      	ldr	r2, [sp, #0]
     3b6:	07db      	lsls	r3, r3, #31
     3b8:	0850      	lsrs	r0, r2, #1
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
     3ba:	4318      	orrs	r0, r3
			if (BUF_OFFSET + 1 > len) {
     3bc:	9b01      	ldr	r3, [sp, #4]
     3be:	0859      	lsrs	r1, r3, #1
     3c0:	9b03      	ldr	r3, [sp, #12]
			*buf++ = pos;
     3c2:	469c      	mov	ip, r3
     3c4:	42b9      	cmp	r1, r7
     3c6:	d82c      	bhi.n	422 <CONFIG_MAIN_STACK_SIZE+0x22>
     3c8:	d101      	bne.n	3ce <__udivmoddi4+0x7e>
     3ca:	42b0      	cmp	r0, r6
		for (i = 0; i < s_idx; i++) {
     3cc:	d829      	bhi.n	422 <CONFIG_MAIN_STACK_SIZE+0x22>
     3ce:	0032      	movs	r2, r6
     3d0:	003b      	movs	r3, r7
     3d2:	1a12      	subs	r2, r2, r0
     3d4:	418b      	sbcs	r3, r1
			if (BUF_OFFSET + 1 > len) {
     3d6:	2601      	movs	r6, #1
		for (i = 0; i < s_idx; i++) {
     3d8:	1892      	adds	r2, r2, r2
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
     3da:	415b      	adcs	r3, r3
			if (BUF_OFFSET + 1 > len) {
     3dc:	2700      	movs	r7, #0
     3de:	18b6      	adds	r6, r6, r2
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
     3e0:	415f      	adcs	r7, r3
     3e2:	2301      	movs	r3, #1
     3e4:	425b      	negs	r3, r3
     3e6:	449c      	add	ip, r3
     3e8:	4663      	mov	r3, ip
     3ea:	2b00      	cmp	r3, #0
		if (rws_pos_en) {
     3ec:	d1ea      	bne.n	3c4 <__udivmoddi4+0x74>
     3ee:	0030      	movs	r0, r6
     3f0:	0039      	movs	r1, r7
			*buf++ = str_ptr_arg[i];
     3f2:	9a03      	ldr	r2, [sp, #12]
     3f4:	f7ff ff66 	bl	2c4 <__aeabi_llsr>
			size = 0;
     3f8:	9a03      	ldr	r2, [sp, #12]
			*buf++ = str_ptr_arg[i];
     3fa:	19a4      	adds	r4, r4, r6
     3fc:	417d      	adcs	r5, r7
     3fe:	0006      	movs	r6, r0
     400:	000f      	movs	r7, r1
		if (BUF_OFFSET + 1 + size > len) {
     402:	f7ff ff6b 	bl	2dc <__aeabi_llsl>
     406:	1a24      	subs	r4, r4, r0
     408:	418d      	sbcs	r5, r1
     40a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
     40c:	2b00      	cmp	r3, #0
     40e:	d001      	beq.n	414 <CONFIG_MAIN_STACK_SIZE+0x14>
     410:	601e      	str	r6, [r3, #0]
     412:	605f      	str	r7, [r3, #4]
		*buf++ = str_ptr_pos[i];
     414:	0020      	movs	r0, r4
     416:	0029      	movs	r1, r5
     418:	b005      	add	sp, #20
     41a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     41c:	2400      	movs	r4, #0
		memcpy(buf, s, size);
     41e:	2500      	movs	r5, #0
		*buf++ = str_ptr_pos[i];
     420:	e7c4      	b.n	3ac <__udivmoddi4+0x5c>
		memcpy(buf, s, size);
     422:	19b6      	adds	r6, r6, r6
     424:	417f      	adcs	r7, r7
     426:	e7dc      	b.n	3e2 <__udivmoddi4+0x92>
     428:	2400      	movs	r4, #0
		buf += size;
     42a:	2500      	movs	r5, #0
     42c:	e7ed      	b.n	40a <CONFIG_MAIN_STACK_SIZE+0xa>
	...

00000430 <z_zassert.constprop.0>:

#define z_zexpect(cond, default_msg, file, line, func, msg, ...) z_zexpect_(cond, file, line)

#else /* CONFIG_ZTEST_ASSERT_VERBOSE != 0 */

static inline bool z_zassert(bool cond, const char *default_msg, const char *file, int line,
     430:	b5f0      	push	{r4, r5, r6, r7, lr}
     432:	0004      	movs	r4, r0
     434:	000f      	movs	r7, r1
     436:	001e      	movs	r6, r3
     438:	b085      	sub	sp, #20
			     const char *func, const char *msg, ...)
{
	if (cond == false) {
     43a:	2800      	cmp	r0, #0
     43c:	d115      	bne.n	46a <z_zassert.constprop.0+0x3a>
		va_list vargs;

		va_start(vargs, msg);
     43e:	ab0c      	add	r3, sp, #48	; 0x30
		PRINT("\n    Assertion failed at %s:%d: %s: %s\n", ztest_relative_filename(file),
     440:	480b      	ldr	r0, [pc, #44]	; (470 <z_zassert.constprop.0+0x40>)
		va_start(vargs, msg);
     442:	9303      	str	r3, [sp, #12]
		PRINT("\n    Assertion failed at %s:%d: %s: %s\n", ztest_relative_filename(file),
     444:	f005 faff 	bl	5a46 <ztest_relative_filename>
     448:	4d0a      	ldr	r5, [pc, #40]	; (474 <z_zassert.constprop.0+0x44>)
     44a:	0001      	movs	r1, r0
     44c:	0032      	movs	r2, r6
     44e:	4b0a      	ldr	r3, [pc, #40]	; (478 <z_zassert.constprop.0+0x48>)
     450:	0028      	movs	r0, r5
     452:	9700      	str	r7, [sp, #0]
     454:	f005 f9b5 	bl	57c2 <printk>
		      line, func, default_msg);
		vprintk(msg, vargs);
     458:	9903      	ldr	r1, [sp, #12]
     45a:	980b      	ldr	r0, [sp, #44]	; 0x2c
     45c:	f000 f8ba 	bl	5d4 <vprintk>
		printk("\n");
     460:	4806      	ldr	r0, [pc, #24]	; (47c <z_zassert.constprop.0+0x4c>)
     462:	f005 f9ae 	bl	57c2 <printk>
		va_end(vargs);
		ztest_test_fail();
     466:	f001 fa09 	bl	187c <ztest_test_fail>
		PRINT("\n   Assertion succeeded at %s:%d (%s)\n", ztest_relative_filename(file),
		      line, func);
	}
#endif
	return true;
}
     46a:	0020      	movs	r0, r4
     46c:	b005      	add	sp, #20
     46e:	bdf0      	pop	{r4, r5, r6, r7, pc}
     470:	00005ff0 	.word	0x00005ff0
     474:	0000602a 	.word	0x0000602a
     478:	000062ba 	.word	0x000062ba
     47c:	00006f87 	.word	0x00006f87

00000480 <_custom_lib_test_get_value_wrapper>:

#include <zephyr/ztest.h>

#include <custom_lib/custom_lib.h>

ZTEST(custom_lib, test_get_value)
     480:	b537      	push	{r0, r1, r2, r4, r5, lr}
{
	/* Verify standard behavior */
	zassert_equal(custom_lib_get_value(INT_MIN), INT_MIN,
     482:	2080      	movs	r0, #128	; 0x80
     484:	0600      	lsls	r0, r0, #24
     486:	f005 fb70 	bl	5b6a <custom_lib_get_value>
     48a:	2380      	movs	r3, #128	; 0x80
     48c:	061b      	lsls	r3, r3, #24
     48e:	18c0      	adds	r0, r0, r3
     490:	4243      	negs	r3, r0
     492:	4158      	adcs	r0, r3
     494:	4d34      	ldr	r5, [pc, #208]	; (568 <_custom_lib_test_get_value_wrapper+0xe8>)
     496:	4c35      	ldr	r4, [pc, #212]	; (56c <_custom_lib_test_get_value_wrapper+0xec>)
     498:	4b35      	ldr	r3, [pc, #212]	; (570 <_custom_lib_test_get_value_wrapper+0xf0>)
     49a:	0022      	movs	r2, r4
     49c:	4935      	ldr	r1, [pc, #212]	; (574 <_custom_lib_test_get_value_wrapper+0xf4>)
     49e:	9301      	str	r3, [sp, #4]
     4a0:	9500      	str	r5, [sp, #0]
     4a2:	2317      	movs	r3, #23
     4a4:	b2c0      	uxtb	r0, r0
     4a6:	f7ff ffc3 	bl	430 <z_zassert.constprop.0>
		"get_value failed input of INT_MIN");
	zassert_equal(custom_lib_get_value(INT_MIN + 1), INT_MIN + 1,
     4aa:	4833      	ldr	r0, [pc, #204]	; (578 <_custom_lib_test_get_value_wrapper+0xf8>)
     4ac:	f005 fb5d 	bl	5b6a <custom_lib_get_value>
     4b0:	4b32      	ldr	r3, [pc, #200]	; (57c <_custom_lib_test_get_value_wrapper+0xfc>)
     4b2:	0022      	movs	r2, r4
     4b4:	18c0      	adds	r0, r0, r3
     4b6:	4243      	negs	r3, r0
     4b8:	4158      	adcs	r0, r3
     4ba:	4b31      	ldr	r3, [pc, #196]	; (580 <_custom_lib_test_get_value_wrapper+0x100>)
     4bc:	4931      	ldr	r1, [pc, #196]	; (584 <_custom_lib_test_get_value_wrapper+0x104>)
     4be:	9301      	str	r3, [sp, #4]
     4c0:	9500      	str	r5, [sp, #0]
     4c2:	2319      	movs	r3, #25
     4c4:	b2c0      	uxtb	r0, r0
     4c6:	f7ff ffb3 	bl	430 <z_zassert.constprop.0>
		"get_value failed input of INT_MIN + 1");
	zassert_equal(custom_lib_get_value(-1), -1,
     4ca:	2001      	movs	r0, #1
     4cc:	4240      	negs	r0, r0
     4ce:	f005 fb4c 	bl	5b6a <custom_lib_get_value>
     4d2:	3001      	adds	r0, #1
     4d4:	4243      	negs	r3, r0
     4d6:	4158      	adcs	r0, r3
     4d8:	4b2b      	ldr	r3, [pc, #172]	; (588 <_custom_lib_test_get_value_wrapper+0x108>)
     4da:	0022      	movs	r2, r4
     4dc:	492b      	ldr	r1, [pc, #172]	; (58c <_custom_lib_test_get_value_wrapper+0x10c>)
     4de:	9301      	str	r3, [sp, #4]
     4e0:	9500      	str	r5, [sp, #0]
     4e2:	231b      	movs	r3, #27
     4e4:	b2c0      	uxtb	r0, r0
     4e6:	f7ff ffa3 	bl	430 <z_zassert.constprop.0>
		"get_value failed input of -1");
	zassert_equal(custom_lib_get_value(1), 1,
     4ea:	2001      	movs	r0, #1
     4ec:	f005 fb3d 	bl	5b6a <custom_lib_get_value>
     4f0:	3801      	subs	r0, #1
     4f2:	4243      	negs	r3, r0
     4f4:	4158      	adcs	r0, r3
     4f6:	4b26      	ldr	r3, [pc, #152]	; (590 <_custom_lib_test_get_value_wrapper+0x110>)
     4f8:	0022      	movs	r2, r4
     4fa:	4926      	ldr	r1, [pc, #152]	; (594 <_custom_lib_test_get_value_wrapper+0x114>)
     4fc:	9301      	str	r3, [sp, #4]
     4fe:	9500      	str	r5, [sp, #0]
     500:	231d      	movs	r3, #29
     502:	b2c0      	uxtb	r0, r0
     504:	f7ff ff94 	bl	430 <z_zassert.constprop.0>
		"get_value failed input of 1");
	zassert_equal(custom_lib_get_value(INT_MAX - 1), INT_MAX - 1,
     508:	4823      	ldr	r0, [pc, #140]	; (598 <_custom_lib_test_get_value_wrapper+0x118>)
     50a:	f005 fb2e 	bl	5b6a <custom_lib_get_value>
     50e:	4b23      	ldr	r3, [pc, #140]	; (59c <_custom_lib_test_get_value_wrapper+0x11c>)
     510:	0022      	movs	r2, r4
     512:	18c0      	adds	r0, r0, r3
     514:	4243      	negs	r3, r0
     516:	4158      	adcs	r0, r3
     518:	4b21      	ldr	r3, [pc, #132]	; (5a0 <_custom_lib_test_get_value_wrapper+0x120>)
     51a:	4922      	ldr	r1, [pc, #136]	; (5a4 <_custom_lib_test_get_value_wrapper+0x124>)
     51c:	9301      	str	r3, [sp, #4]
     51e:	9500      	str	r5, [sp, #0]
     520:	231f      	movs	r3, #31
     522:	b2c0      	uxtb	r0, r0
     524:	f7ff ff84 	bl	430 <z_zassert.constprop.0>
		"get_value failed input of INT_MAX - 1");
	zassert_equal(custom_lib_get_value(INT_MAX), INT_MAX,
     528:	4814      	ldr	r0, [pc, #80]	; (57c <_custom_lib_test_get_value_wrapper+0xfc>)
     52a:	f005 fb1e 	bl	5b6a <custom_lib_get_value>
     52e:	4b12      	ldr	r3, [pc, #72]	; (578 <_custom_lib_test_get_value_wrapper+0xf8>)
     530:	0022      	movs	r2, r4
     532:	18c0      	adds	r0, r0, r3
     534:	4243      	negs	r3, r0
     536:	4158      	adcs	r0, r3
     538:	4b1b      	ldr	r3, [pc, #108]	; (5a8 <_custom_lib_test_get_value_wrapper+0x128>)
     53a:	491c      	ldr	r1, [pc, #112]	; (5ac <_custom_lib_test_get_value_wrapper+0x12c>)
     53c:	9301      	str	r3, [sp, #4]
     53e:	9500      	str	r5, [sp, #0]
     540:	2321      	movs	r3, #33	; 0x21
     542:	b2c0      	uxtb	r0, r0
     544:	f7ff ff74 	bl	430 <z_zassert.constprop.0>
		"get_value failed input of INT_MAX");

	/* Verify override behavior */
	zassert_equal(custom_lib_get_value(0),
     548:	2000      	movs	r0, #0
     54a:	f005 fb0e 	bl	5b6a <custom_lib_get_value>
     54e:	4243      	negs	r3, r0
     550:	4158      	adcs	r0, r3
     552:	4b17      	ldr	r3, [pc, #92]	; (5b0 <_custom_lib_test_get_value_wrapper+0x130>)
     554:	9500      	str	r5, [sp, #0]
     556:	9301      	str	r3, [sp, #4]
     558:	0022      	movs	r2, r4
     55a:	2325      	movs	r3, #37	; 0x25
     55c:	4915      	ldr	r1, [pc, #84]	; (5b4 <_custom_lib_test_get_value_wrapper+0x134>)
     55e:	b2c0      	uxtb	r0, r0
     560:	f7ff ff66 	bl	430 <z_zassert.constprop.0>
ZTEST(custom_lib, test_get_value)
     564:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
     566:	46c0      	nop			; (mov r8, r8)
     568:	000062ba 	.word	0x000062ba
     56c:	00005ff0 	.word	0x00005ff0
     570:	00006087 	.word	0x00006087
     574:	00006052 	.word	0x00006052
     578:	80000001 	.word	0x80000001
     57c:	7fffffff 	.word	0x7fffffff
     580:	000060e6 	.word	0x000060e6
     584:	000060a9 	.word	0x000060a9
     588:	00006137 	.word	0x00006137
     58c:	0000610c 	.word	0x0000610c
     590:	0000617d 	.word	0x0000617d
     594:	00006154 	.word	0x00006154
     598:	7ffffffe 	.word	0x7ffffffe
     59c:	80000002 	.word	0x80000002
     5a0:	000061d6 	.word	0x000061d6
     5a4:	00006199 	.word	0x00006199
     5a8:	00006231 	.word	0x00006231
     5ac:	000061fc 	.word	0x000061fc
     5b0:	0000629e 	.word	0x0000629e
     5b4:	00006253 	.word	0x00006253

000005b8 <char_out>:

	return c;
}

static int char_out(int c, void *ctx_p)
{
     5b8:	b510      	push	{r4, lr}
	(void) ctx_p;
	return _char_out(c);
     5ba:	4b02      	ldr	r3, [pc, #8]	; (5c4 <char_out+0xc>)
     5bc:	681b      	ldr	r3, [r3, #0]
     5be:	4798      	blx	r3
}
     5c0:	bd10      	pop	{r4, pc}
     5c2:	46c0      	nop			; (mov r8, r8)
     5c4:	20000008 	.word	0x20000008

000005c8 <__printk_hook_install>:
	_char_out = fn;
     5c8:	4b01      	ldr	r3, [pc, #4]	; (5d0 <__printk_hook_install+0x8>)
     5ca:	6018      	str	r0, [r3, #0]
}
     5cc:	4770      	bx	lr
     5ce:	46c0      	nop			; (mov r8, r8)
     5d0:	20000008 	.word	0x20000008

000005d4 <vprintk>:

void vprintk(const char *fmt, va_list ap)
{
     5d4:	b513      	push	{r0, r1, r4, lr}
     5d6:	000b      	movs	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
     5d8:	2100      	movs	r1, #0
     5da:	4c03      	ldr	r4, [pc, #12]	; (5e8 <vprintk+0x14>)
     5dc:	0002      	movs	r2, r0
     5de:	9100      	str	r1, [sp, #0]
     5e0:	0020      	movs	r0, r4
     5e2:	f000 f803 	bl	5ec <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
     5e6:	bd13      	pop	{r0, r1, r4, pc}
     5e8:	000005b9 	.word	0x000005b9

000005ec <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
     5ec:	b5f0      	push	{r4, r5, r6, r7, lr}
     5ee:	001c      	movs	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
     5f0:	2700      	movs	r7, #0
{
     5f2:	b099      	sub	sp, #100	; 0x64
     5f4:	9004      	str	r0, [sp, #16]
     5f6:	9105      	str	r1, [sp, #20]
     5f8:	9208      	str	r2, [sp, #32]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
     5fa:	9b08      	ldr	r3, [sp, #32]
     5fc:	7818      	ldrb	r0, [r3, #0]
     5fe:	2800      	cmp	r0, #0
     600:	d101      	bne.n	606 <z_cbvprintf_impl+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
     602:	0038      	movs	r0, r7
     604:	e327      	b.n	c56 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x9e>
			OUTC(*fp++);
     606:	9b08      	ldr	r3, [sp, #32]
     608:	3301      	adds	r3, #1
     60a:	9307      	str	r3, [sp, #28]
		if (*fp != '%') {
     60c:	2825      	cmp	r0, #37	; 0x25
     60e:	d007      	beq.n	620 <z_cbvprintf_impl+0x34>
			OUTC('%');
     610:	9905      	ldr	r1, [sp, #20]
     612:	9b04      	ldr	r3, [sp, #16]
     614:	4798      	blx	r3
     616:	2800      	cmp	r0, #0
     618:	da00      	bge.n	61c <z_cbvprintf_impl+0x30>
     61a:	e31c      	b.n	c56 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x9e>
     61c:	3701      	adds	r7, #1
		if (bps == NULL) {
     61e:	e1e3      	b.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
		} state = {
     620:	ad12      	add	r5, sp, #72	; 0x48
     622:	2218      	movs	r2, #24
     624:	2100      	movs	r1, #0
     626:	0028      	movs	r0, r5
     628:	f005 f9c6 	bl	59b8 <memset>
	if (*sp == '%') {
     62c:	9b08      	ldr	r3, [sp, #32]
     62e:	785b      	ldrb	r3, [r3, #1]
     630:	2b25      	cmp	r3, #37	; 0x25
     632:	d114      	bne.n	65e <z_cbvprintf_impl+0x72>
		conv->specifier = *sp++;
     634:	9a08      	ldr	r2, [sp, #32]
     636:	72eb      	strb	r3, [r5, #11]
     638:	3202      	adds	r2, #2
     63a:	9207      	str	r2, [sp, #28]
		if (conv->width_star) {
     63c:	ab12      	add	r3, sp, #72	; 0x48
     63e:	7a5a      	ldrb	r2, [r3, #9]
     640:	07d1      	lsls	r1, r2, #31
     642:	d400      	bmi.n	646 <z_cbvprintf_impl+0x5a>
     644:	e17f      	b.n	946 <CONFIG_ISR_STACK_SIZE+0x146>
			width = va_arg(ap, int);
     646:	cc02      	ldmia	r4!, {r1}
     648:	9103      	str	r1, [sp, #12]
			if (width < 0) {
     64a:	2900      	cmp	r1, #0
     64c:	db00      	blt.n	650 <z_cbvprintf_impl+0x64>
     64e:	e17f      	b.n	950 <CONFIG_ISR_STACK_SIZE+0x150>
				conv->flag_dash = true;
     650:	2104      	movs	r1, #4
     652:	7a18      	ldrb	r0, [r3, #8]
     654:	4301      	orrs	r1, r0
     656:	7219      	strb	r1, [r3, #8]
				width = -width;
     658:	9b03      	ldr	r3, [sp, #12]
		int width = -1;
     65a:	425b      	negs	r3, r3
     65c:	e177      	b.n	94e <CONFIG_ISR_STACK_SIZE+0x14e>
     65e:	2200      	movs	r2, #0
		switch (*sp) {
     660:	2601      	movs	r6, #1
     662:	0015      	movs	r5, r2
     664:	0010      	movs	r0, r2
     666:	4694      	mov	ip, r2
     668:	9203      	str	r2, [sp, #12]
     66a:	9b07      	ldr	r3, [sp, #28]
     66c:	781b      	ldrb	r3, [r3, #0]
     66e:	2b2b      	cmp	r3, #43	; 0x2b
     670:	d06f      	beq.n	752 <z_cbvprintf_impl+0x166>
     672:	d868      	bhi.n	746 <z_cbvprintf_impl+0x15a>
     674:	2b20      	cmp	r3, #32
     676:	d071      	beq.n	75c <z_cbvprintf_impl+0x170>
     678:	2b23      	cmp	r3, #35	; 0x23
     67a:	d071      	beq.n	760 <z_cbvprintf_impl+0x174>
     67c:	2a00      	cmp	r2, #0
     67e:	d005      	beq.n	68c <z_cbvprintf_impl+0xa0>
     680:	ae12      	add	r6, sp, #72	; 0x48
     682:	7a32      	ldrb	r2, [r6, #8]
     684:	0011      	movs	r1, r2
     686:	2240      	movs	r2, #64	; 0x40
     688:	430a      	orrs	r2, r1
     68a:	7232      	strb	r2, [r6, #8]
     68c:	2d00      	cmp	r5, #0
     68e:	d004      	beq.n	69a <z_cbvprintf_impl+0xae>
     690:	2220      	movs	r2, #32
     692:	ad12      	add	r5, sp, #72	; 0x48
     694:	7a2e      	ldrb	r6, [r5, #8]
     696:	4332      	orrs	r2, r6
     698:	722a      	strb	r2, [r5, #8]
     69a:	2800      	cmp	r0, #0
     69c:	d004      	beq.n	6a8 <z_cbvprintf_impl+0xbc>
     69e:	2210      	movs	r2, #16
     6a0:	a812      	add	r0, sp, #72	; 0x48
     6a2:	7a05      	ldrb	r5, [r0, #8]
     6a4:	432a      	orrs	r2, r5
     6a6:	7202      	strb	r2, [r0, #8]
     6a8:	9a03      	ldr	r2, [sp, #12]
     6aa:	2a00      	cmp	r2, #0
     6ac:	d004      	beq.n	6b8 <z_cbvprintf_impl+0xcc>
     6ae:	2208      	movs	r2, #8
     6b0:	a912      	add	r1, sp, #72	; 0x48
     6b2:	7a08      	ldrb	r0, [r1, #8]
     6b4:	4302      	orrs	r2, r0
     6b6:	720a      	strb	r2, [r1, #8]
     6b8:	4662      	mov	r2, ip
     6ba:	2a00      	cmp	r2, #0
     6bc:	d004      	beq.n	6c8 <z_cbvprintf_impl+0xdc>
     6be:	2204      	movs	r2, #4
     6c0:	a912      	add	r1, sp, #72	; 0x48
     6c2:	7a08      	ldrb	r0, [r1, #8]
     6c4:	4302      	orrs	r2, r0
     6c6:	720a      	strb	r2, [r1, #8]
	if (conv->flag_zero && conv->flag_dash) {
     6c8:	2144      	movs	r1, #68	; 0x44
     6ca:	a812      	add	r0, sp, #72	; 0x48
     6cc:	7a02      	ldrb	r2, [r0, #8]
     6ce:	4011      	ands	r1, r2
     6d0:	2944      	cmp	r1, #68	; 0x44
     6d2:	d102      	bne.n	6da <z_cbvprintf_impl+0xee>
		conv->flag_zero = false;
     6d4:	2140      	movs	r1, #64	; 0x40
     6d6:	438a      	bics	r2, r1
     6d8:	7202      	strb	r2, [r0, #8]
	conv->width_present = true;
     6da:	2280      	movs	r2, #128	; 0x80
     6dc:	7a01      	ldrb	r1, [r0, #8]
     6de:	4252      	negs	r2, r2
     6e0:	430a      	orrs	r2, r1
     6e2:	7202      	strb	r2, [r0, #8]
	size_t val = 0;
     6e4:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
     6e6:	250a      	movs	r5, #10
     6e8:	9a07      	ldr	r2, [sp, #28]
	if (*sp == '*') {
     6ea:	2b2a      	cmp	r3, #42	; 0x2a
     6ec:	d140      	bne.n	770 <z_cbvprintf_impl+0x184>
		conv->width_star = true;
     6ee:	7a41      	ldrb	r1, [r0, #9]
     6f0:	3b29      	subs	r3, #41	; 0x29
     6f2:	430b      	orrs	r3, r1
		return ++sp;
     6f4:	3201      	adds	r2, #1
		conv->width_star = true;
     6f6:	7243      	strb	r3, [r0, #9]
	conv->prec_present = (*sp == '.');
     6f8:	7815      	ldrb	r5, [r2, #0]
     6fa:	2602      	movs	r6, #2
     6fc:	0029      	movs	r1, r5
     6fe:	392e      	subs	r1, #46	; 0x2e
     700:	424b      	negs	r3, r1
     702:	4159      	adcs	r1, r3
     704:	a812      	add	r0, sp, #72	; 0x48
     706:	7a43      	ldrb	r3, [r0, #9]
     708:	0049      	lsls	r1, r1, #1
     70a:	43b3      	bics	r3, r6
     70c:	430b      	orrs	r3, r1
     70e:	7243      	strb	r3, [r0, #9]
	if (!conv->prec_present) {
     710:	2d2e      	cmp	r5, #46	; 0x2e
     712:	d145      	bne.n	7a0 <z_cbvprintf_impl+0x1b4>
	if (*sp == '*') {
     714:	7853      	ldrb	r3, [r2, #1]
     716:	2b2a      	cmp	r3, #42	; 0x2a
     718:	d03d      	beq.n	796 <z_cbvprintf_impl+0x1aa>
	size_t val = 0;
     71a:	2300      	movs	r3, #0
	++sp;
     71c:	3201      	adds	r2, #1
		val = 10U * val + *sp++ - '0';
     71e:	3608      	adds	r6, #8
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
     720:	7811      	ldrb	r1, [r2, #0]
     722:	1c55      	adds	r5, r2, #1
     724:	0008      	movs	r0, r1
     726:	3830      	subs	r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
     728:	2809      	cmp	r0, #9
     72a:	d963      	bls.n	7f4 <z_cbvprintf_impl+0x208>
	conv->prec_value = prec;
     72c:	a912      	add	r1, sp, #72	; 0x48
     72e:	9316      	str	r3, [sp, #88]	; 0x58
	conv->unsupported |= ((conv->prec_value < 0)
     730:	7a0d      	ldrb	r5, [r1, #8]
     732:	07a8      	lsls	r0, r5, #30
     734:	4318      	orrs	r0, r3
     736:	2302      	movs	r3, #2
     738:	439d      	bics	r5, r3
     73a:	002b      	movs	r3, r5
     73c:	0fc0      	lsrs	r0, r0, #31
     73e:	0040      	lsls	r0, r0, #1
     740:	4303      	orrs	r3, r0
     742:	720b      	strb	r3, [r1, #8]
	return sp;
     744:	e02c      	b.n	7a0 <z_cbvprintf_impl+0x1b4>
		switch (*sp) {
     746:	2b2d      	cmp	r3, #45	; 0x2d
     748:	d00c      	beq.n	764 <z_cbvprintf_impl+0x178>
     74a:	2b30      	cmp	r3, #48	; 0x30
     74c:	d196      	bne.n	67c <z_cbvprintf_impl+0x90>
     74e:	0032      	movs	r2, r6
     750:	e000      	b.n	754 <z_cbvprintf_impl+0x168>
     752:	9603      	str	r6, [sp, #12]
			++sp;
     754:	9b07      	ldr	r3, [sp, #28]
     756:	3301      	adds	r3, #1
     758:	9307      	str	r3, [sp, #28]
	} while (loop);
     75a:	e786      	b.n	66a <z_cbvprintf_impl+0x7e>
		switch (*sp) {
     75c:	0030      	movs	r0, r6
     75e:	e7f9      	b.n	754 <z_cbvprintf_impl+0x168>
     760:	0035      	movs	r5, r6
     762:	e7f7      	b.n	754 <z_cbvprintf_impl+0x168>
     764:	46b4      	mov	ip, r6
     766:	e7f5      	b.n	754 <z_cbvprintf_impl+0x168>
		val = 10U * val + *sp++ - '0';
     768:	0032      	movs	r2, r6
     76a:	4369      	muls	r1, r5
     76c:	3930      	subs	r1, #48	; 0x30
     76e:	1859      	adds	r1, r3, r1
     770:	7813      	ldrb	r3, [r2, #0]
     772:	1c56      	adds	r6, r2, #1
     774:	0018      	movs	r0, r3
     776:	3830      	subs	r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
     778:	2809      	cmp	r0, #9
     77a:	d9f5      	bls.n	768 <z_cbvprintf_impl+0x17c>
	if (sp != wp) {
     77c:	9b07      	ldr	r3, [sp, #28]
     77e:	4293      	cmp	r3, r2
     780:	d0ba      	beq.n	6f8 <z_cbvprintf_impl+0x10c>
		conv->unsupported |= ((conv->width_value < 0)
     782:	2502      	movs	r5, #2
		conv->width_value = width;
     784:	ab12      	add	r3, sp, #72	; 0x48
		conv->unsupported |= ((conv->width_value < 0)
     786:	7a18      	ldrb	r0, [r3, #8]
		conv->width_value = width;
     788:	9115      	str	r1, [sp, #84]	; 0x54
		conv->unsupported |= ((conv->width_value < 0)
     78a:	0fc9      	lsrs	r1, r1, #31
     78c:	0049      	lsls	r1, r1, #1
     78e:	43a8      	bics	r0, r5
     790:	4301      	orrs	r1, r0
     792:	7219      	strb	r1, [r3, #8]
     794:	e7b0      	b.n	6f8 <z_cbvprintf_impl+0x10c>
		conv->prec_star = true;
     796:	2304      	movs	r3, #4
     798:	7a41      	ldrb	r1, [r0, #9]
		return ++sp;
     79a:	3202      	adds	r2, #2
		conv->prec_star = true;
     79c:	430b      	orrs	r3, r1
     79e:	7243      	strb	r3, [r0, #9]
	switch (*sp) {
     7a0:	7811      	ldrb	r1, [r2, #0]
     7a2:	ab12      	add	r3, sp, #72	; 0x48
     7a4:	296c      	cmp	r1, #108	; 0x6c
     7a6:	d045      	beq.n	834 <CONFIG_ISR_STACK_SIZE+0x34>
     7a8:	d829      	bhi.n	7fe <z_cbvprintf_impl+0x212>
     7aa:	2968      	cmp	r1, #104	; 0x68
     7ac:	d030      	beq.n	810 <CONFIG_ISR_STACK_SIZE+0x10>
     7ae:	296a      	cmp	r1, #106	; 0x6a
     7b0:	d04c      	beq.n	84c <CONFIG_ISR_STACK_SIZE+0x4c>
     7b2:	294c      	cmp	r1, #76	; 0x4c
     7b4:	d054      	beq.n	860 <CONFIG_ISR_STACK_SIZE+0x60>
	conv->specifier = *sp++;
     7b6:	7811      	ldrb	r1, [r2, #0]
     7b8:	1c53      	adds	r3, r2, #1
     7ba:	aa12      	add	r2, sp, #72	; 0x48
     7bc:	9307      	str	r3, [sp, #28]
     7be:	72d1      	strb	r1, [r2, #11]
		if (conv->length_mod == LENGTH_UPPER_L) {
     7c0:	7a53      	ldrb	r3, [r2, #9]
	switch (conv->specifier) {
     7c2:	2978      	cmp	r1, #120	; 0x78
     7c4:	d900      	bls.n	7c8 <z_cbvprintf_impl+0x1dc>
     7c6:	e0b9      	b.n	93c <CONFIG_ISR_STACK_SIZE+0x13c>
     7c8:	296d      	cmp	r1, #109	; 0x6d
     7ca:	d850      	bhi.n	86e <CONFIG_ISR_STACK_SIZE+0x6e>
     7cc:	2969      	cmp	r1, #105	; 0x69
     7ce:	d900      	bls.n	7d2 <z_cbvprintf_impl+0x1e6>
     7d0:	e0b4      	b.n	93c <CONFIG_ISR_STACK_SIZE+0x13c>
     7d2:	2957      	cmp	r1, #87	; 0x57
     7d4:	d866      	bhi.n	8a4 <CONFIG_ISR_STACK_SIZE+0xa4>
     7d6:	2941      	cmp	r1, #65	; 0x41
     7d8:	d003      	beq.n	7e2 <z_cbvprintf_impl+0x1f6>
     7da:	3945      	subs	r1, #69	; 0x45
     7dc:	2902      	cmp	r1, #2
     7de:	d900      	bls.n	7e2 <z_cbvprintf_impl+0x1f6>
     7e0:	e0ac      	b.n	93c <CONFIG_ISR_STACK_SIZE+0x13c>
		conv->specifier_cat = SPECIFIER_FP;
     7e2:	2307      	movs	r3, #7
     7e4:	a912      	add	r1, sp, #72	; 0x48
     7e6:	7a8a      	ldrb	r2, [r1, #10]
     7e8:	439a      	bics	r2, r3
     7ea:	3b03      	subs	r3, #3
     7ec:	4313      	orrs	r3, r2
     7ee:	728b      	strb	r3, [r1, #10]
			unsupported = true;
     7f0:	2301      	movs	r3, #1
			break;
     7f2:	e073      	b.n	8dc <CONFIG_ISR_STACK_SIZE+0xdc>
		val = 10U * val + *sp++ - '0';
     7f4:	4373      	muls	r3, r6
     7f6:	3b30      	subs	r3, #48	; 0x30
     7f8:	002a      	movs	r2, r5
     7fa:	185b      	adds	r3, r3, r1
     7fc:	e790      	b.n	720 <z_cbvprintf_impl+0x134>
	switch (*sp) {
     7fe:	2974      	cmp	r1, #116	; 0x74
     800:	d029      	beq.n	856 <CONFIG_ISR_STACK_SIZE+0x56>
     802:	297a      	cmp	r1, #122	; 0x7a
     804:	d1d7      	bne.n	7b6 <z_cbvprintf_impl+0x1ca>
		conv->length_mod = LENGTH_Z;
     806:	2178      	movs	r1, #120	; 0x78
     808:	7a58      	ldrb	r0, [r3, #9]
     80a:	4388      	bics	r0, r1
     80c:	3948      	subs	r1, #72	; 0x48
     80e:	e00d      	b.n	82c <CONFIG_ISR_STACK_SIZE+0x2c>
		if (*++sp == 'h') {
     810:	7850      	ldrb	r0, [r2, #1]
     812:	2178      	movs	r1, #120	; 0x78
     814:	2868      	cmp	r0, #104	; 0x68
     816:	d106      	bne.n	826 <CONFIG_ISR_STACK_SIZE+0x26>
			conv->length_mod = LENGTH_HH;
     818:	7a58      	ldrb	r0, [r3, #9]
     81a:	4388      	bics	r0, r1
     81c:	3970      	subs	r1, #112	; 0x70
			conv->length_mod = LENGTH_LL;
     81e:	4301      	orrs	r1, r0
     820:	7259      	strb	r1, [r3, #9]
			++sp;
     822:	3202      	adds	r2, #2
     824:	e7c7      	b.n	7b6 <z_cbvprintf_impl+0x1ca>
			conv->length_mod = LENGTH_H;
     826:	7a58      	ldrb	r0, [r3, #9]
     828:	4388      	bics	r0, r1
     82a:	2110      	movs	r1, #16
     82c:	4301      	orrs	r1, r0
     82e:	7259      	strb	r1, [r3, #9]
		if (*++sp == 'h') {
     830:	3201      	adds	r2, #1
     832:	e7c0      	b.n	7b6 <z_cbvprintf_impl+0x1ca>
		if (*++sp == 'l') {
     834:	7850      	ldrb	r0, [r2, #1]
     836:	2178      	movs	r1, #120	; 0x78
     838:	286c      	cmp	r0, #108	; 0x6c
     83a:	d103      	bne.n	844 <CONFIG_ISR_STACK_SIZE+0x44>
			conv->length_mod = LENGTH_LL;
     83c:	7a58      	ldrb	r0, [r3, #9]
     83e:	4388      	bics	r0, r1
     840:	3958      	subs	r1, #88	; 0x58
     842:	e7ec      	b.n	81e <CONFIG_ISR_STACK_SIZE+0x1e>
			conv->length_mod = LENGTH_L;
     844:	7a58      	ldrb	r0, [r3, #9]
     846:	4388      	bics	r0, r1
     848:	2118      	movs	r1, #24
     84a:	e7ef      	b.n	82c <CONFIG_ISR_STACK_SIZE+0x2c>
		conv->length_mod = LENGTH_J;
     84c:	2178      	movs	r1, #120	; 0x78
     84e:	7a58      	ldrb	r0, [r3, #9]
     850:	4388      	bics	r0, r1
     852:	3950      	subs	r1, #80	; 0x50
     854:	e7ea      	b.n	82c <CONFIG_ISR_STACK_SIZE+0x2c>
		conv->length_mod = LENGTH_T;
     856:	2178      	movs	r1, #120	; 0x78
     858:	7a58      	ldrb	r0, [r3, #9]
     85a:	4388      	bics	r0, r1
     85c:	3940      	subs	r1, #64	; 0x40
     85e:	e7e5      	b.n	82c <CONFIG_ISR_STACK_SIZE+0x2c>
		conv->unsupported = true;
     860:	8918      	ldrh	r0, [r3, #8]
     862:	49a5      	ldr	r1, [pc, #660]	; (af8 <CONFIG_ISR_STACK_SIZE+0x2f8>)
     864:	4008      	ands	r0, r1
     866:	49a5      	ldr	r1, [pc, #660]	; (afc <CONFIG_ISR_STACK_SIZE+0x2fc>)
     868:	4301      	orrs	r1, r0
     86a:	8119      	strh	r1, [r3, #8]
		break;
     86c:	e7e0      	b.n	830 <CONFIG_ISR_STACK_SIZE+0x30>
     86e:	2001      	movs	r0, #1
     870:	0005      	movs	r5, r0
	switch (conv->specifier) {
     872:	396e      	subs	r1, #110	; 0x6e
     874:	b2c9      	uxtb	r1, r1
     876:	408d      	lsls	r5, r1
     878:	0029      	movs	r1, r5
     87a:	4da1      	ldr	r5, [pc, #644]	; (b00 <CONFIG_ISR_STACK_SIZE+0x300>)
     87c:	4229      	tst	r1, r5
     87e:	d138      	bne.n	8f2 <CONFIG_ISR_STACK_SIZE+0xf2>
     880:	2524      	movs	r5, #36	; 0x24
     882:	4229      	tst	r1, r5
     884:	d151      	bne.n	92a <CONFIG_ISR_STACK_SIZE+0x12a>
     886:	4201      	tst	r1, r0
     888:	d058      	beq.n	93c <CONFIG_ISR_STACK_SIZE+0x13c>
		conv->specifier_cat = SPECIFIER_PTR;
     88a:	2107      	movs	r1, #7
     88c:	7a90      	ldrb	r0, [r2, #10]
     88e:	4388      	bics	r0, r1
     890:	3904      	subs	r1, #4
     892:	4301      	orrs	r1, r0
     894:	7291      	strb	r1, [r2, #10]
		if (conv->length_mod == LENGTH_UPPER_L) {
     896:	2278      	movs	r2, #120	; 0x78
     898:	4013      	ands	r3, r2
     89a:	3b40      	subs	r3, #64	; 0x40
     89c:	425a      	negs	r2, r3
     89e:	4153      	adcs	r3, r2
		if (conv->length_mod != LENGTH_NONE) {
     8a0:	b2db      	uxtb	r3, r3
     8a2:	e01b      	b.n	8dc <CONFIG_ISR_STACK_SIZE+0xdc>
     8a4:	2001      	movs	r0, #1
	switch (conv->specifier) {
     8a6:	000d      	movs	r5, r1
     8a8:	0006      	movs	r6, r0
     8aa:	3d58      	subs	r5, #88	; 0x58
     8ac:	b2ed      	uxtb	r5, r5
     8ae:	40ae      	lsls	r6, r5
     8b0:	0035      	movs	r5, r6
     8b2:	26e2      	movs	r6, #226	; 0xe2
     8b4:	0236      	lsls	r6, r6, #8
     8b6:	4235      	tst	r5, r6
     8b8:	d193      	bne.n	7e2 <z_cbvprintf_impl+0x1f6>
     8ba:	4e92      	ldr	r6, [pc, #584]	; (b04 <CONFIG_ISR_STACK_SIZE+0x304>)
     8bc:	4235      	tst	r5, r6
     8be:	d122      	bne.n	906 <CONFIG_ISR_STACK_SIZE+0x106>
     8c0:	2184      	movs	r1, #132	; 0x84
     8c2:	0289      	lsls	r1, r1, #10
     8c4:	420d      	tst	r5, r1
     8c6:	d039      	beq.n	93c <CONFIG_ISR_STACK_SIZE+0x13c>
		conv->specifier_cat = SPECIFIER_SINT;
     8c8:	2507      	movs	r5, #7
     8ca:	7a91      	ldrb	r1, [r2, #10]
     8cc:	43a9      	bics	r1, r5
     8ce:	4301      	orrs	r1, r0
     8d0:	7291      	strb	r1, [r2, #10]
		if (conv->length_mod == LENGTH_UPPER_L) {
     8d2:	2178      	movs	r1, #120	; 0x78
     8d4:	400b      	ands	r3, r1
     8d6:	2b40      	cmp	r3, #64	; 0x40
     8d8:	d011      	beq.n	8fe <CONFIG_ISR_STACK_SIZE+0xfe>
	bool unsupported = false;
     8da:	2300      	movs	r3, #0
	conv->unsupported |= unsupported;
     8dc:	aa12      	add	r2, sp, #72	; 0x48
     8de:	7a11      	ldrb	r1, [r2, #8]
     8e0:	0788      	lsls	r0, r1, #30
     8e2:	0fc0      	lsrs	r0, r0, #31
     8e4:	4303      	orrs	r3, r0
     8e6:	2002      	movs	r0, #2
     8e8:	005b      	lsls	r3, r3, #1
     8ea:	4381      	bics	r1, r0
     8ec:	4319      	orrs	r1, r3
     8ee:	7211      	strb	r1, [r2, #8]
	return sp;
     8f0:	e6a4      	b.n	63c <z_cbvprintf_impl+0x50>
		conv->specifier_cat = SPECIFIER_UINT;
     8f2:	2107      	movs	r1, #7
     8f4:	7a95      	ldrb	r5, [r2, #10]
     8f6:	438d      	bics	r5, r1
     8f8:	3905      	subs	r1, #5
     8fa:	4329      	orrs	r1, r5
     8fc:	e7e8      	b.n	8d0 <CONFIG_ISR_STACK_SIZE+0xd0>
			conv->invalid = true;
     8fe:	7a13      	ldrb	r3, [r2, #8]
     900:	4303      	orrs	r3, r0
		conv->invalid = true;
     902:	7213      	strb	r3, [r2, #8]
		break;
     904:	e7e9      	b.n	8da <CONFIG_ISR_STACK_SIZE+0xda>
		conv->specifier_cat = SPECIFIER_UINT;
     906:	2507      	movs	r5, #7
     908:	7a96      	ldrb	r6, [r2, #10]
     90a:	43ae      	bics	r6, r5
     90c:	3d05      	subs	r5, #5
     90e:	4335      	orrs	r5, r6
     910:	7295      	strb	r5, [r2, #10]
		if (conv->length_mod == LENGTH_UPPER_L) {
     912:	2578      	movs	r5, #120	; 0x78
     914:	402b      	ands	r3, r5
     916:	2b40      	cmp	r3, #64	; 0x40
     918:	d102      	bne.n	920 <CONFIG_ISR_STACK_SIZE+0x120>
			conv->invalid = true;
     91a:	7a15      	ldrb	r5, [r2, #8]
     91c:	4328      	orrs	r0, r5
     91e:	7210      	strb	r0, [r2, #8]
		if (conv->specifier == 'c') {
     920:	2963      	cmp	r1, #99	; 0x63
     922:	d1da      	bne.n	8da <CONFIG_ISR_STACK_SIZE+0xda>
		if (conv->length_mod != LENGTH_NONE) {
     924:	1e5a      	subs	r2, r3, #1
     926:	4193      	sbcs	r3, r2
     928:	e7ba      	b.n	8a0 <CONFIG_ISR_STACK_SIZE+0xa0>
		conv->specifier_cat = SPECIFIER_PTR;
     92a:	2107      	movs	r1, #7
     92c:	7a90      	ldrb	r0, [r2, #10]
     92e:	4388      	bics	r0, r1
     930:	3904      	subs	r1, #4
     932:	4301      	orrs	r1, r0
     934:	7291      	strb	r1, [r2, #10]
		if (conv->length_mod != LENGTH_NONE) {
     936:	2278      	movs	r2, #120	; 0x78
     938:	4013      	ands	r3, r2
     93a:	e7f3      	b.n	924 <CONFIG_ISR_STACK_SIZE+0x124>
		conv->invalid = true;
     93c:	2301      	movs	r3, #1
     93e:	aa12      	add	r2, sp, #72	; 0x48
     940:	7a11      	ldrb	r1, [r2, #8]
     942:	430b      	orrs	r3, r1
     944:	e7dd      	b.n	902 <CONFIG_ISR_STACK_SIZE+0x102>
		} else if (conv->width_present) {
     946:	7a19      	ldrb	r1, [r3, #8]
     948:	297f      	cmp	r1, #127	; 0x7f
     94a:	d90f      	bls.n	96c <CONFIG_ISR_STACK_SIZE+0x16c>
			width = conv->width_value;
     94c:	68db      	ldr	r3, [r3, #12]
		int width = -1;
     94e:	9303      	str	r3, [sp, #12]
		if (conv->prec_star) {
     950:	ab12      	add	r3, sp, #72	; 0x48
     952:	0751      	lsls	r1, r2, #29
     954:	d50c      	bpl.n	970 <CONFIG_ISR_STACK_SIZE+0x170>
			int arg = va_arg(ap, int);
     956:	cc04      	ldmia	r4!, {r2}
     958:	9206      	str	r2, [sp, #24]
			if (arg < 0) {
     95a:	2a00      	cmp	r2, #0
     95c:	da0c      	bge.n	978 <CONFIG_ISR_STACK_SIZE+0x178>
				conv->prec_present = false;
     95e:	2102      	movs	r1, #2
     960:	7a5a      	ldrb	r2, [r3, #9]
     962:	438a      	bics	r2, r1
     964:	725a      	strb	r2, [r3, #9]
		int precision = -1;
     966:	2301      	movs	r3, #1
     968:	425b      	negs	r3, r3
     96a:	e004      	b.n	976 <CONFIG_ISR_STACK_SIZE+0x176>
		int width = -1;
     96c:	2301      	movs	r3, #1
     96e:	e674      	b.n	65a <z_cbvprintf_impl+0x6e>
		} else if (conv->prec_present) {
     970:	0792      	lsls	r2, r2, #30
     972:	d5f8      	bpl.n	966 <CONFIG_ISR_STACK_SIZE+0x166>
			precision = conv->prec_value;
     974:	691b      	ldr	r3, [r3, #16]
		int precision = -1;
     976:	9306      	str	r3, [sp, #24]
		conv->pad0_value = 0;
     978:	2500      	movs	r5, #0
     97a:	a912      	add	r1, sp, #72	; 0x48
			= (enum specifier_cat_enum)conv->specifier_cat;
     97c:	7a8b      	ldrb	r3, [r1, #10]
			= (enum length_mod_enum)conv->length_mod;
     97e:	7a4a      	ldrb	r2, [r1, #9]
			= (enum specifier_cat_enum)conv->specifier_cat;
     980:	075b      	lsls	r3, r3, #29
			= (enum length_mod_enum)conv->length_mod;
     982:	0652      	lsls	r2, r2, #25
		enum specifier_cat_enum specifier_cat
     984:	0f5b      	lsrs	r3, r3, #29
			= (enum length_mod_enum)conv->length_mod;
     986:	0f12      	lsrs	r2, r2, #28
		conv->pad0_value = 0;
     988:	60cd      	str	r5, [r1, #12]
		conv->pad0_pre_exp = 0;
     98a:	610d      	str	r5, [r1, #16]
		if (specifier_cat == SPECIFIER_SINT) {
     98c:	2b01      	cmp	r3, #1
     98e:	d130      	bne.n	9f2 <CONFIG_ISR_STACK_SIZE+0x1f2>
			switch (length_mod) {
     990:	1ed0      	subs	r0, r2, #3
     992:	2804      	cmp	r0, #4
     994:	d804      	bhi.n	9a0 <CONFIG_ISR_STACK_SIZE+0x1a0>
     996:	f7ff fb87 	bl	a8 <__gnu_thumb1_case_uqi>
     99a:	450e      	.short	0x450e
     99c:	0e45      	.short	0x0e45
     99e:	0e          	.byte	0x0e
     99f:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
     9a0:	6823      	ldr	r3, [r4, #0]
     9a2:	17d8      	asrs	r0, r3, #31
     9a4:	9312      	str	r3, [sp, #72]	; 0x48
     9a6:	6048      	str	r0, [r1, #4]
			if (length_mod == LENGTH_HH) {
     9a8:	2a01      	cmp	r2, #1
     9aa:	d109      	bne.n	9c0 <CONFIG_ISR_STACK_SIZE+0x1c0>
				value->sint = (signed char)value->sint;
     9ac:	b25b      	sxtb	r3, r3
				value->sint = (short)value->sint;
     9ae:	9312      	str	r3, [sp, #72]	; 0x48
     9b0:	17db      	asrs	r3, r3, #31
     9b2:	604b      	str	r3, [r1, #4]
     9b4:	e006      	b.n	9c4 <CONFIG_ISR_STACK_SIZE+0x1c4>
					(sint_value_type)va_arg(ap, ptrdiff_t);
     9b6:	cc08      	ldmia	r4!, {r3}
     9b8:	9312      	str	r3, [sp, #72]	; 0x48
     9ba:	17db      	asrs	r3, r3, #31
					(uint_value_type)va_arg(ap, size_t);
     9bc:	604b      	str	r3, [r1, #4]
			} else if (length_mod == LENGTH_H) {
     9be:	e002      	b.n	9c6 <CONFIG_ISR_STACK_SIZE+0x1c6>
			} else if (length_mod == LENGTH_H) {
     9c0:	2a02      	cmp	r2, #2
     9c2:	d014      	beq.n	9ee <CONFIG_ISR_STACK_SIZE+0x1ee>
				value->sint = va_arg(ap, int);
     9c4:	3404      	adds	r4, #4
		if (conv->invalid || conv->unsupported) {
     9c6:	a912      	add	r1, sp, #72	; 0x48
     9c8:	7a0b      	ldrb	r3, [r1, #8]
     9ca:	2003      	movs	r0, #3
     9cc:	001d      	movs	r5, r3
     9ce:	4005      	ands	r5, r0
     9d0:	4203      	tst	r3, r0
     9d2:	d045      	beq.n	a60 <CONFIG_ISR_STACK_SIZE+0x260>
			OUTS(sp, fp);
     9d4:	9b07      	ldr	r3, [sp, #28]
     9d6:	9a08      	ldr	r2, [sp, #32]
     9d8:	9905      	ldr	r1, [sp, #20]
     9da:	9804      	ldr	r0, [sp, #16]
     9dc:	f004 ff6a 	bl	58b4 <outs>
     9e0:	2800      	cmp	r0, #0
     9e2:	da00      	bge.n	9e6 <CONFIG_ISR_STACK_SIZE+0x1e6>
     9e4:	e137      	b.n	c56 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x9e>
     9e6:	183f      	adds	r7, r7, r0
			continue;
     9e8:	9b07      	ldr	r3, [sp, #28]
     9ea:	9308      	str	r3, [sp, #32]
     9ec:	e605      	b.n	5fa <z_cbvprintf_impl+0xe>
				value->sint = (short)value->sint;
     9ee:	b21b      	sxth	r3, r3
     9f0:	e7dd      	b.n	9ae <CONFIG_ISR_STACK_SIZE+0x1ae>
		} else if (specifier_cat == SPECIFIER_UINT) {
     9f2:	2b02      	cmp	r3, #2
     9f4:	d125      	bne.n	a42 <CONFIG_ISR_STACK_SIZE+0x242>
			switch (length_mod) {
     9f6:	1ed0      	subs	r0, r2, #3
     9f8:	2804      	cmp	r0, #4
     9fa:	d804      	bhi.n	a06 <CONFIG_ISR_STACK_SIZE+0x206>
     9fc:	f7ff fb54 	bl	a8 <__gnu_thumb1_case_uqi>
     a00:	1912120d 	.word	0x1912120d
     a04:	19          	.byte	0x19
     a05:	00          	.byte	0x00
				value->uint = va_arg(ap, unsigned int);
     a06:	cc08      	ldmia	r4!, {r3}
			if (length_mod == LENGTH_HH) {
     a08:	2a01      	cmp	r2, #1
     a0a:	d016      	beq.n	a3a <CONFIG_ISR_STACK_SIZE+0x23a>
				value->uint = va_arg(ap, unsigned int);
     a0c:	9312      	str	r3, [sp, #72]	; 0x48
     a0e:	604d      	str	r5, [r1, #4]
				value->uint = (unsigned short)value->uint;
     a10:	b29b      	uxth	r3, r3
			} else if (length_mod == LENGTH_H) {
     a12:	2a02      	cmp	r2, #2
     a14:	d1d7      	bne.n	9c6 <CONFIG_ISR_STACK_SIZE+0x1c6>
			value->ptr = va_arg(ap, void *);
     a16:	9312      	str	r3, [sp, #72]	; 0x48
     a18:	e7d5      	b.n	9c6 <CONFIG_ISR_STACK_SIZE+0x1c6>
					value->uint = (wchar_t)va_arg(ap,
     a1a:	cc08      	ldmia	r4!, {r3}
     a1c:	9312      	str	r3, [sp, #72]	; 0x48
     a1e:	2300      	movs	r3, #0
     a20:	9313      	str	r3, [sp, #76]	; 0x4c
     a22:	e7d0      	b.n	9c6 <CONFIG_ISR_STACK_SIZE+0x1c6>
					(uint_value_type)va_arg(ap,
     a24:	2307      	movs	r3, #7
     a26:	3407      	adds	r4, #7
     a28:	439c      	bics	r4, r3
				value->uint =
     a2a:	cc03      	ldmia	r4!, {r0, r1}
     a2c:	9012      	str	r0, [sp, #72]	; 0x48
     a2e:	9113      	str	r1, [sp, #76]	; 0x4c
			if (length_mod == LENGTH_HH) {
     a30:	e7c9      	b.n	9c6 <CONFIG_ISR_STACK_SIZE+0x1c6>
					(uint_value_type)va_arg(ap, size_t);
     a32:	cc08      	ldmia	r4!, {r3}
     a34:	9312      	str	r3, [sp, #72]	; 0x48
     a36:	2300      	movs	r3, #0
     a38:	e7c0      	b.n	9bc <CONFIG_ISR_STACK_SIZE+0x1bc>
				value->uint = (unsigned char)value->uint;
     a3a:	b2db      	uxtb	r3, r3
     a3c:	9312      	str	r3, [sp, #72]	; 0x48
     a3e:	604d      	str	r5, [r1, #4]
     a40:	e7c1      	b.n	9c6 <CONFIG_ISR_STACK_SIZE+0x1c6>
		} else if (specifier_cat == SPECIFIER_FP) {
     a42:	2b04      	cmp	r3, #4
     a44:	d108      	bne.n	a58 <CONFIG_ISR_STACK_SIZE+0x258>
					(sint_value_type)va_arg(ap, long long);
     a46:	3407      	adds	r4, #7
				value->ldbl = va_arg(ap, long double);
     a48:	3303      	adds	r3, #3
     a4a:	439c      	bics	r4, r3
     a4c:	6820      	ldr	r0, [r4, #0]
     a4e:	6861      	ldr	r1, [r4, #4]
     a50:	3408      	adds	r4, #8
     a52:	9012      	str	r0, [sp, #72]	; 0x48
     a54:	9113      	str	r1, [sp, #76]	; 0x4c
     a56:	e7b6      	b.n	9c6 <CONFIG_ISR_STACK_SIZE+0x1c6>
		} else if (specifier_cat == SPECIFIER_PTR) {
     a58:	2b03      	cmp	r3, #3
     a5a:	d1b4      	bne.n	9c6 <CONFIG_ISR_STACK_SIZE+0x1c6>
			value->ptr = va_arg(ap, void *);
     a5c:	cc08      	ldmia	r4!, {r3}
     a5e:	e7da      	b.n	a16 <CONFIG_ISR_STACK_SIZE+0x216>
		switch (conv->specifier) {
     a60:	7ac8      	ldrb	r0, [r1, #11]
     a62:	2878      	cmp	r0, #120	; 0x78
     a64:	d8c0      	bhi.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
     a66:	2862      	cmp	r0, #98	; 0x62
     a68:	d82b      	bhi.n	ac2 <CONFIG_ISR_STACK_SIZE+0x2c2>
     a6a:	2825      	cmp	r0, #37	; 0x25
     a6c:	d100      	bne.n	a70 <CONFIG_ISR_STACK_SIZE+0x270>
     a6e:	e5cf      	b.n	610 <z_cbvprintf_impl+0x24>
     a70:	2858      	cmp	r0, #88	; 0x58
     a72:	d1b9      	bne.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
			bps = encode_uint(value->uint, conv, buf, bpe);
     a74:	9812      	ldr	r0, [sp, #72]	; 0x48
     a76:	9913      	ldr	r1, [sp, #76]	; 0x4c
     a78:	231e      	movs	r3, #30
     a7a:	aa0a      	add	r2, sp, #40	; 0x28
     a7c:	189b      	adds	r3, r3, r2
     a7e:	9300      	str	r3, [sp, #0]
     a80:	aa14      	add	r2, sp, #80	; 0x50
     a82:	ab0c      	add	r3, sp, #48	; 0x30
     a84:	f004 fec9 	bl	581a <encode_uint>
			if (precision >= 0) {
     a88:	9b06      	ldr	r3, [sp, #24]
			bps = encode_uint(value->uint, conv, buf, bpe);
     a8a:	0006      	movs	r6, r0
			if (precision >= 0) {
     a8c:	2b00      	cmp	r3, #0
     a8e:	db0d      	blt.n	aac <CONFIG_ISR_STACK_SIZE+0x2ac>
				size_t len = bpe - bps;
     a90:	231e      	movs	r3, #30
				conv->flag_zero = false;
     a92:	2040      	movs	r0, #64	; 0x40
				size_t len = bpe - bps;
     a94:	aa0a      	add	r2, sp, #40	; 0x28
     a96:	189b      	adds	r3, r3, r2
				conv->flag_zero = false;
     a98:	aa12      	add	r2, sp, #72	; 0x48
     a9a:	7a11      	ldrb	r1, [r2, #8]
				size_t len = bpe - bps;
     a9c:	1b9b      	subs	r3, r3, r6
				conv->flag_zero = false;
     a9e:	4381      	bics	r1, r0
     aa0:	7211      	strb	r1, [r2, #8]
				if (len < (size_t)precision) {
     aa2:	9906      	ldr	r1, [sp, #24]
     aa4:	4299      	cmp	r1, r3
     aa6:	d901      	bls.n	aac <CONFIG_ISR_STACK_SIZE+0x2ac>
					conv->pad0_value = precision - (int)len;
     aa8:	1acb      	subs	r3, r1, r3
     aaa:	9315      	str	r3, [sp, #84]	; 0x54
		if (bps == NULL) {
     aac:	2e00      	cmp	r6, #0
     aae:	d09b      	beq.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
		size_t nj_len = (bpe - bps);
     ab0:	231e      	movs	r3, #30
     ab2:	aa0a      	add	r2, sp, #40	; 0x28
     ab4:	189b      	adds	r3, r3, r2
     ab6:	1b98      	subs	r0, r3, r6
		if (sign != 0) {
     ab8:	9306      	str	r3, [sp, #24]
     aba:	2d00      	cmp	r5, #0
     abc:	d032      	beq.n	b24 <CONFIG_ISR_STACK_SIZE+0x324>
			nj_len += 1U;
     abe:	3001      	adds	r0, #1
     ac0:	e030      	b.n	b24 <CONFIG_ISR_STACK_SIZE+0x324>
		switch (conv->specifier) {
     ac2:	3863      	subs	r0, #99	; 0x63
     ac4:	2815      	cmp	r0, #21
     ac6:	d88f      	bhi.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
     ac8:	f7ff faf8 	bl	bc <__gnu_thumb1_case_shi>
     acc:	0068005e 	.word	0x0068005e
     ad0:	ff8eff8e 	.word	0xff8eff8e
     ad4:	ff8eff8e 	.word	0xff8eff8e
     ad8:	ff8e0068 	.word	0xff8e0068
     adc:	ff8eff8e 	.word	0xff8eff8e
     ae0:	00a0ff8e 	.word	0x00a0ff8e
     ae4:	007c007a 	.word	0x007c007a
     ae8:	ff8eff8e 	.word	0xff8eff8e
     aec:	ff8e001e 	.word	0xff8e001e
     af0:	ff8e007a 	.word	0xff8e007a
     af4:	007aff8e 	.word	0x007aff8e
     af8:	ffff87fd 	.word	0xffff87fd
     afc:	00004002 	.word	0x00004002
     b00:	00000482 	.word	0x00000482
     b04:	00000801 	.word	0x00000801
			if (precision >= 0) {
     b08:	9b06      	ldr	r3, [sp, #24]
			bps = (const char *)value->ptr;
     b0a:	9e12      	ldr	r6, [sp, #72]	; 0x48
			if (precision >= 0) {
     b0c:	2b00      	cmp	r3, #0
     b0e:	db37      	blt.n	b80 <CONFIG_ISR_STACK_SIZE+0x380>
				len = strnlen(bps, precision);
     b10:	0019      	movs	r1, r3
     b12:	0030      	movs	r0, r6
     b14:	f004 ff5c 	bl	59d0 <strnlen>
			bpe = bps + len;
     b18:	1833      	adds	r3, r6, r0
		char sign = 0;
     b1a:	2500      	movs	r5, #0
			bpe = bps + len;
     b1c:	9306      	str	r3, [sp, #24]
		if (bps == NULL) {
     b1e:	2e00      	cmp	r6, #0
     b20:	d100      	bne.n	b24 <CONFIG_ISR_STACK_SIZE+0x324>
     b22:	e761      	b.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
		if (conv->altform_0c) {
     b24:	ab12      	add	r3, sp, #72	; 0x48
     b26:	7a9b      	ldrb	r3, [r3, #10]
     b28:	2210      	movs	r2, #16
     b2a:	0019      	movs	r1, r3
     b2c:	4011      	ands	r1, r2
     b2e:	910b      	str	r1, [sp, #44]	; 0x2c
     b30:	4213      	tst	r3, r2
     b32:	d100      	bne.n	b36 <CONFIG_ISR_STACK_SIZE+0x336>
     b34:	e085      	b.n	c42 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x8a>
			nj_len += 2U;
     b36:	3002      	adds	r0, #2
		nj_len += conv->pad0_value;
     b38:	9a15      	ldr	r2, [sp, #84]	; 0x54
     b3a:	920a      	str	r2, [sp, #40]	; 0x28
     b3c:	1880      	adds	r0, r0, r2
		if (conv->pad_fp) {
     b3e:	065b      	lsls	r3, r3, #25
     b40:	d501      	bpl.n	b46 <CONFIG_ISR_STACK_SIZE+0x346>
			nj_len += conv->pad0_pre_exp;
     b42:	9b16      	ldr	r3, [sp, #88]	; 0x58
     b44:	18c0      	adds	r0, r0, r3
		if (width > 0) {
     b46:	9b03      	ldr	r3, [sp, #12]
     b48:	2b00      	cmp	r3, #0
     b4a:	dc00      	bgt.n	b4e <CONFIG_ISR_STACK_SIZE+0x34e>
     b4c:	e094      	b.n	c78 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0xc0>
			width -= (int)nj_len;
     b4e:	1a1b      	subs	r3, r3, r0
     b50:	9303      	str	r3, [sp, #12]
			if (!conv->flag_dash) {
     b52:	ab12      	add	r3, sp, #72	; 0x48
     b54:	7a1b      	ldrb	r3, [r3, #8]
     b56:	075a      	lsls	r2, r3, #29
     b58:	0fd1      	lsrs	r1, r2, #31
     b5a:	9108      	str	r1, [sp, #32]
     b5c:	2a00      	cmp	r2, #0
     b5e:	da00      	bge.n	b62 <CONFIG_ISR_STACK_SIZE+0x362>
     b60:	e08a      	b.n	c78 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0xc0>
				if (conv->flag_zero) {
     b62:	065b      	lsls	r3, r3, #25
     b64:	d400      	bmi.n	b68 <CONFIG_ISR_STACK_SIZE+0x368>
     b66:	e078      	b.n	c5a <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0xa2>
					if (sign != 0) {
     b68:	2d00      	cmp	r5, #0
     b6a:	d007      	beq.n	b7c <CONFIG_ISR_STACK_SIZE+0x37c>
						OUTC(sign);
     b6c:	0028      	movs	r0, r5
     b6e:	9905      	ldr	r1, [sp, #20]
     b70:	9b04      	ldr	r3, [sp, #16]
     b72:	4798      	blx	r3
     b74:	2800      	cmp	r0, #0
     b76:	db6e      	blt.n	c56 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x9e>
     b78:	9d08      	ldr	r5, [sp, #32]
     b7a:	3701      	adds	r7, #1
					pad = '0';
     b7c:	2330      	movs	r3, #48	; 0x30
     b7e:	e06d      	b.n	c5c <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0xa4>
				len = strlen(bps);
     b80:	0030      	movs	r0, r6
     b82:	f004 fefd 	bl	5980 <strlen>
     b86:	e7c7      	b.n	b18 <CONFIG_ISR_STACK_SIZE+0x318>
			bpe = buf + 1;
     b88:	2309      	movs	r3, #9
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
     b8a:	9a12      	ldr	r2, [sp, #72]	; 0x48
     b8c:	ae0c      	add	r6, sp, #48	; 0x30
     b8e:	7032      	strb	r2, [r6, #0]
			bpe = buf + 1;
     b90:	aa0a      	add	r2, sp, #40	; 0x28
     b92:	189b      	adds	r3, r3, r2
		char sign = 0;
     b94:	2500      	movs	r5, #0
		size_t nj_len = (bpe - bps);
     b96:	2001      	movs	r0, #1
			bpe = buf + 1;
     b98:	9306      	str	r3, [sp, #24]
     b9a:	e7c3      	b.n	b24 <CONFIG_ISR_STACK_SIZE+0x324>
				sign = '+';
     b9c:	252b      	movs	r5, #43	; 0x2b
			if (conv->flag_plus) {
     b9e:	071a      	lsls	r2, r3, #28
     ba0:	d402      	bmi.n	ba8 <CONFIG_ISR_STACK_SIZE+0x3a8>
			} else if (conv->flag_space) {
     ba2:	06db      	lsls	r3, r3, #27
     ba4:	0fdb      	lsrs	r3, r3, #31
     ba6:	015d      	lsls	r5, r3, #5
			sint = value->sint;
     ba8:	9a12      	ldr	r2, [sp, #72]	; 0x48
     baa:	9b13      	ldr	r3, [sp, #76]	; 0x4c
			if (sint < 0) {
     bac:	2b00      	cmp	r3, #0
     bae:	db00      	blt.n	bb2 <CONFIG_ISR_STACK_SIZE+0x3b2>
     bb0:	e760      	b.n	a74 <CONFIG_ISR_STACK_SIZE+0x274>
				value->uint = (uint_value_type)-sint;
     bb2:	2100      	movs	r1, #0
     bb4:	4250      	negs	r0, r2
     bb6:	4199      	sbcs	r1, r3
				sign = '-';
     bb8:	252d      	movs	r5, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
     bba:	9012      	str	r0, [sp, #72]	; 0x48
     bbc:	9113      	str	r1, [sp, #76]	; 0x4c
     bbe:	e759      	b.n	a74 <CONFIG_ISR_STACK_SIZE+0x274>
		switch (conv->specifier) {
     bc0:	2500      	movs	r5, #0
     bc2:	e757      	b.n	a74 <CONFIG_ISR_STACK_SIZE+0x274>
			if (value->ptr != NULL) {
     bc4:	9812      	ldr	r0, [sp, #72]	; 0x48
     bc6:	ad12      	add	r5, sp, #72	; 0x48
     bc8:	2800      	cmp	r0, #0
     bca:	d034      	beq.n	c36 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x7e>
				bps = encode_uint((uintptr_t)value->ptr, conv,
     bcc:	231e      	movs	r3, #30
     bce:	aa0a      	add	r2, sp, #40	; 0x28
     bd0:	189b      	adds	r3, r3, r2
     bd2:	9300      	str	r3, [sp, #0]
     bd4:	aa14      	add	r2, sp, #80	; 0x50
     bd6:	ab0c      	add	r3, sp, #48	; 0x30
     bd8:	2100      	movs	r1, #0
     bda:	f004 fe1e 	bl	581a <encode_uint>
				conv->altform_0c = true;
     bde:	23ef      	movs	r3, #239	; 0xef
     be0:	896a      	ldrh	r2, [r5, #10]
				bps = encode_uint((uintptr_t)value->ptr, conv,
     be2:	0006      	movs	r6, r0
				conv->altform_0c = true;
     be4:	401a      	ands	r2, r3
     be6:	4b48      	ldr	r3, [pc, #288]	; (d08 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x150>)
     be8:	4313      	orrs	r3, r2
     bea:	816b      	strh	r3, [r5, #10]
		char sign = 0;
     bec:	2500      	movs	r5, #0
			if (precision >= 0) {
     bee:	9b06      	ldr	r3, [sp, #24]
     bf0:	42ab      	cmp	r3, r5
     bf2:	db00      	blt.n	bf6 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x3e>
     bf4:	e74c      	b.n	a90 <CONFIG_ISR_STACK_SIZE+0x290>
		if (bps == NULL) {
     bf6:	42a8      	cmp	r0, r5
     bf8:	d100      	bne.n	bfc <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x44>
     bfa:	e6f5      	b.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
		size_t nj_len = (bpe - bps);
     bfc:	231e      	movs	r3, #30
     bfe:	aa0a      	add	r2, sp, #40	; 0x28
     c00:	189b      	adds	r3, r3, r2
     c02:	1a18      	subs	r0, r3, r0
     c04:	231e      	movs	r3, #30
     c06:	189b      	adds	r3, r3, r2
     c08:	9306      	str	r3, [sp, #24]
     c0a:	e78b      	b.n	b24 <CONFIG_ISR_STACK_SIZE+0x324>
				store_count(conv, value->ptr, count);
     c0c:	9b12      	ldr	r3, [sp, #72]	; 0x48
	switch ((enum length_mod_enum)conv->length_mod) {
     c0e:	2a07      	cmp	r2, #7
     c10:	d900      	bls.n	c14 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x5c>
     c12:	e6e9      	b.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
     c14:	0010      	movs	r0, r2
     c16:	f7ff fa47 	bl	a8 <__gnu_thumb1_case_uqi>
     c1a:	040c      	.short	0x040c
     c1c:	08080c06 	.word	0x08080c06
     c20:	0c0c      	.short	0x0c0c
		*(signed char *)dp = (signed char)count;
     c22:	701f      	strb	r7, [r3, #0]
		if (bps == NULL) {
     c24:	e6e0      	b.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
		*(short *)dp = (short)count;
     c26:	801f      	strh	r7, [r3, #0]
		if (bps == NULL) {
     c28:	e6de      	b.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
		*(intmax_t *)dp = (intmax_t)count;
     c2a:	17fa      	asrs	r2, r7, #31
     c2c:	601f      	str	r7, [r3, #0]
     c2e:	605a      	str	r2, [r3, #4]
		if (bps == NULL) {
     c30:	e6da      	b.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
     c32:	601f      	str	r7, [r3, #0]
		if (bps == NULL) {
     c34:	e6d8      	b.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
			bpe = bps + 5;
     c36:	4b35      	ldr	r3, [pc, #212]	; (d0c <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x154>)
		char sign = 0;
     c38:	0005      	movs	r5, r0
     c3a:	4e35      	ldr	r6, [pc, #212]	; (d10 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x158>)
		size_t nj_len = (bpe - bps);
     c3c:	2005      	movs	r0, #5
			bpe = bps + 5;
     c3e:	9306      	str	r3, [sp, #24]
     c40:	e770      	b.n	b24 <CONFIG_ISR_STACK_SIZE+0x324>
		} else if (conv->altform_0) {
     c42:	071a      	lsls	r2, r3, #28
			nj_len += 1U;
     c44:	0fd2      	lsrs	r2, r2, #31
     c46:	1880      	adds	r0, r0, r2
     c48:	e776      	b.n	b38 <CONFIG_ISR_STACK_SIZE+0x338>
					OUTC(pad);
     c4a:	9905      	ldr	r1, [sp, #20]
     c4c:	9809      	ldr	r0, [sp, #36]	; 0x24
     c4e:	9b04      	ldr	r3, [sp, #16]
     c50:	4798      	blx	r3
     c52:	2800      	cmp	r0, #0
     c54:	da05      	bge.n	c62 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0xaa>
#undef OUTS
#undef OUTC
}
     c56:	b019      	add	sp, #100	; 0x64
     c58:	bdf0      	pop	{r4, r5, r6, r7, pc}
				char pad = ' ';
     c5a:	2320      	movs	r3, #32
					pad = '0';
     c5c:	9309      	str	r3, [sp, #36]	; 0x24
     c5e:	9b03      	ldr	r3, [sp, #12]
     c60:	9308      	str	r3, [sp, #32]
				while (width-- > 0) {
     c62:	9b08      	ldr	r3, [sp, #32]
     c64:	001a      	movs	r2, r3
     c66:	3a01      	subs	r2, #1
     c68:	9208      	str	r2, [sp, #32]
     c6a:	2b00      	cmp	r3, #0
     c6c:	dced      	bgt.n	c4a <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x92>
     c6e:	9a03      	ldr	r2, [sp, #12]
     c70:	19d7      	adds	r7, r2, r7
     c72:	1aff      	subs	r7, r7, r3
     c74:	9b08      	ldr	r3, [sp, #32]
     c76:	9303      	str	r3, [sp, #12]
		if (sign != 0) {
     c78:	2d00      	cmp	r5, #0
     c7a:	d006      	beq.n	c8a <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0xd2>
			OUTC(sign);
     c7c:	0028      	movs	r0, r5
     c7e:	9905      	ldr	r1, [sp, #20]
     c80:	9b04      	ldr	r3, [sp, #16]
     c82:	4798      	blx	r3
     c84:	2800      	cmp	r0, #0
     c86:	dbe6      	blt.n	c56 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x9e>
     c88:	3701      	adds	r7, #1
			if (conv->altform_0c | conv->altform_0) {
     c8a:	ab12      	add	r3, sp, #72	; 0x48
     c8c:	7a9b      	ldrb	r3, [r3, #10]
     c8e:	06da      	lsls	r2, r3, #27
     c90:	d401      	bmi.n	c96 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0xde>
     c92:	071b      	lsls	r3, r3, #28
     c94:	d506      	bpl.n	ca4 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0xec>
				OUTC('0');
     c96:	2030      	movs	r0, #48	; 0x30
     c98:	9905      	ldr	r1, [sp, #20]
     c9a:	9b04      	ldr	r3, [sp, #16]
     c9c:	4798      	blx	r3
     c9e:	2800      	cmp	r0, #0
     ca0:	dbd9      	blt.n	c56 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x9e>
     ca2:	3701      	adds	r7, #1
			if (conv->altform_0c) {
     ca4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
     ca6:	2b00      	cmp	r3, #0
     ca8:	d007      	beq.n	cba <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x102>
				OUTC(conv->specifier);
     caa:	ab12      	add	r3, sp, #72	; 0x48
     cac:	7ad8      	ldrb	r0, [r3, #11]
     cae:	9905      	ldr	r1, [sp, #20]
     cb0:	9b04      	ldr	r3, [sp, #16]
     cb2:	4798      	blx	r3
     cb4:	2800      	cmp	r0, #0
     cb6:	dbce      	blt.n	c56 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x9e>
     cb8:	3701      	adds	r7, #1
				while (width-- > 0) {
     cba:	003d      	movs	r5, r7
     cbc:	e006      	b.n	ccc <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x114>
				OUTC('0');
     cbe:	2030      	movs	r0, #48	; 0x30
     cc0:	9905      	ldr	r1, [sp, #20]
     cc2:	9b04      	ldr	r3, [sp, #16]
     cc4:	4798      	blx	r3
     cc6:	2800      	cmp	r0, #0
     cc8:	dbc5      	blt.n	c56 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x9e>
     cca:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
     ccc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
     cce:	19db      	adds	r3, r3, r7
     cd0:	1b5b      	subs	r3, r3, r5
     cd2:	2b00      	cmp	r3, #0
     cd4:	dcf3      	bgt.n	cbe <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x106>
			OUTS(bps, bpe);
     cd6:	0032      	movs	r2, r6
     cd8:	9b06      	ldr	r3, [sp, #24]
     cda:	9905      	ldr	r1, [sp, #20]
     cdc:	9804      	ldr	r0, [sp, #16]
     cde:	f004 fde9 	bl	58b4 <outs>
     ce2:	2800      	cmp	r0, #0
     ce4:	dbb7      	blt.n	c56 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x9e>
     ce6:	1947      	adds	r7, r0, r5
     ce8:	003d      	movs	r5, r7
		while (width > 0) {
     cea:	9b03      	ldr	r3, [sp, #12]
     cec:	195b      	adds	r3, r3, r5
     cee:	1bdb      	subs	r3, r3, r7
     cf0:	2b00      	cmp	r3, #0
     cf2:	dc00      	bgt.n	cf6 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x13e>
     cf4:	e678      	b.n	9e8 <CONFIG_ISR_STACK_SIZE+0x1e8>
			OUTC(' ');
     cf6:	2020      	movs	r0, #32
     cf8:	9905      	ldr	r1, [sp, #20]
     cfa:	9b04      	ldr	r3, [sp, #16]
     cfc:	4798      	blx	r3
     cfe:	2800      	cmp	r0, #0
     d00:	dba9      	blt.n	c56 <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x9e>
     d02:	3701      	adds	r7, #1
			--width;
     d04:	e7f1      	b.n	cea <CONFIG_ZTEST_CPU_HOLD_TIME_MS+0x132>
     d06:	46c0      	nop			; (mov r8, r8)
     d08:	00007810 	.word	0x00007810
     d0c:	00006304 	.word	0x00006304
     d10:	000062ff 	.word	0x000062ff

00000d14 <z_arm_platform_init>:
	/* Implement z_arm_platform_init() directly in ASM,
	 * and ensure no stack access is performed until
	 * we jump to SystemInit().
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
     d14:	4800      	ldr	r0, [pc, #0]	; (d18 <z_arm_platform_init+0x4>)
	bx r0
     d16:	4700      	bx	r0
	ldr r0, =SystemInit
     d18:	00002a09 	.word	0x00002a09

00000d1c <timer0_nrf_isr>:
}

NRF_STATIC_INLINE void nrf_timer_event_clear(NRF_TIMER_Type *  p_reg,
                                             nrf_timer_event_t event)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
     d1c:	2200      	movs	r2, #0
     d1e:	4b0a      	ldr	r3, [pc, #40]	; (d48 <timer0_nrf_isr+0x2c>)

	int_enable();
}

void timer0_nrf_isr(void *arg)
{
     d20:	b570      	push	{r4, r5, r6, lr}
     d22:	601a      	str	r2, [r3, #0]
}

NRF_STATIC_INLINE uint32_t nrf_timer_cc_get(NRF_TIMER_Type const * p_reg,
                                            nrf_timer_cc_channel_t cc_channel)
{
    return (uint32_t)p_reg->CC[cc_channel];
     d24:	23a8      	movs	r3, #168	; 0xa8
     d26:	4a09      	ldr	r2, [pc, #36]	; (d4c <timer0_nrf_isr+0x30>)
	ARG_UNUSED(arg);
	event_clear();


	uint32_t t = get_comparator();
	uint32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
     d28:	4c09      	ldr	r4, [pc, #36]	; (d50 <timer0_nrf_isr+0x34>)
     d2a:	00db      	lsls	r3, r3, #3
     d2c:	58d0      	ldr	r0, [r2, r3]
     d2e:	6825      	ldr	r5, [r4, #0]
     d30:	4908      	ldr	r1, [pc, #32]	; (d54 <timer0_nrf_isr+0x38>)
	return (a - b) & COUNTER_MAX;
     d32:	1b40      	subs	r0, r0, r5
	uint32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
     d34:	f7ff f9cc 	bl	d0 <__udivsi3>

	last_count += dticks * CYC_PER_TICK;
     d38:	4b06      	ldr	r3, [pc, #24]	; (d54 <timer0_nrf_isr+0x38>)
     d3a:	4343      	muls	r3, r0
     d3c:	195b      	adds	r3, r3, r5
     d3e:	6023      	str	r3, [r4, #0]
		 * so it won't get preempted by the interrupt.
		 */
		set_absolute_ticks(last_count + CYC_PER_TICK);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : (dticks > 0));
     d40:	f004 fb4c 	bl	53dc <sys_clock_announce>
}
     d44:	bd70      	pop	{r4, r5, r6, pc}
     d46:	46c0      	nop			; (mov r8, r8)
     d48:	40008140 	.word	0x40008140
     d4c:	40008000 	.word	0x40008000
     d50:	20000280 	.word	0x20000280
     d54:	00002710 	.word	0x00002710

00000d58 <sys_clock_driver_init>:
    p_reg->PRESCALER = prescaler_factor;
     d58:	22a2      	movs	r2, #162	; 0xa2
     d5a:	2303      	movs	r3, #3
    p_reg->BITMODE = (p_reg->BITMODE & ~TIMER_BITMODE_BITMODE_Msk) |
     d5c:	21a1      	movs	r1, #161	; 0xa1
	k_spin_unlock(&lock, key);
	return ret;
}

static int sys_clock_driver_init(void)
{
     d5e:	b510      	push	{r4, lr}
    p_reg->PRESCALER = prescaler_factor;
     d60:	4c11      	ldr	r4, [pc, #68]	; (da8 <sys_clock_driver_init+0x50>)
     d62:	00d2      	lsls	r2, r2, #3
     d64:	50a3      	str	r3, [r4, r2]
    p_reg->BITMODE = (p_reg->BITMODE & ~TIMER_BITMODE_BITMODE_Msk) |
     d66:	00c9      	lsls	r1, r1, #3
     d68:	5862      	ldr	r2, [r4, r1]

	/* FIXME switch to 1 MHz once this is fixed in QEMU */
	nrf_timer_prescaler_set(TIMER, NRF_TIMER_FREQ_2MHz);
	nrf_timer_bit_width_set(TIMER, NRF_TIMER_BIT_WIDTH_32);

	IRQ_CONNECT(TIMER0_IRQn, 1, timer0_nrf_isr, 0, 0);
     d6a:	2008      	movs	r0, #8
     d6c:	439a      	bics	r2, r3
     d6e:	4313      	orrs	r3, r2
     d70:	5063      	str	r3, [r4, r1]
     d72:	2200      	movs	r2, #0
     d74:	2101      	movs	r1, #1
     d76:	f000 fb4f 	bl	1418 <z_arm_irq_priority_set>
	irq_enable(TIMER0_IRQn);
     d7a:	2008      	movs	r0, #8
     d7c:	f000 fb32 	bl	13e4 <arch_irq_enable>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
     d80:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
     d82:	2000      	movs	r0, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
     d84:	4a09      	ldr	r2, [pc, #36]	; (dac <sys_clock_driver_init+0x54>)
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     d86:	2180      	movs	r1, #128	; 0x80
     d88:	6013      	str	r3, [r2, #0]
     d8a:	6023      	str	r3, [r4, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
     d8c:	4b08      	ldr	r3, [pc, #32]	; (db0 <sys_clock_driver_init+0x58>)
     d8e:	4a09      	ldr	r2, [pc, #36]	; (db4 <sys_clock_driver_init+0x5c>)
     d90:	6018      	str	r0, [r3, #0]
     d92:	23c0      	movs	r3, #192	; 0xc0
     d94:	0049      	lsls	r1, r1, #1
     d96:	005b      	lsls	r3, r3, #1
     d98:	50d1      	str	r1, [r2, r3]
    p_reg->INTENSET = mask;
     d9a:	2280      	movs	r2, #128	; 0x80
     d9c:	3385      	adds	r3, #133	; 0x85
     d9e:	33ff      	adds	r3, #255	; 0xff
     da0:	0252      	lsls	r2, r2, #9
     da2:	50e2      	str	r2, [r4, r3]
	event_clear();
	NVIC_ClearPendingIRQ(TIMER0_IRQn);
	int_enable();

	return 0;
}
     da4:	bd10      	pop	{r4, pc}
     da6:	46c0      	nop			; (mov r8, r8)
     da8:	40008000 	.word	0x40008000
     dac:	4000800c 	.word	0x4000800c
     db0:	40008140 	.word	0x40008140
     db4:	e000e100 	.word	0xe000e100

00000db8 <sys_clock_set_timeout>:
{
     db8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
     dba:	1c43      	adds	r3, r0, #1
     dbc:	d05e      	beq.n	e7c <sys_clock_set_timeout+0xc4>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
     dbe:	2300      	movs	r3, #0
     dc0:	2801      	cmp	r0, #1
     dc2:	dd04      	ble.n	dce <sys_clock_set_timeout+0x16>
     dc4:	4a31      	ldr	r2, [pc, #196]	; (e8c <sys_clock_set_timeout+0xd4>)
     dc6:	0013      	movs	r3, r2
     dc8:	4290      	cmp	r0, r2
     dca:	dc00      	bgt.n	dce <sys_clock_set_timeout+0x16>
     dcc:	1e43      	subs	r3, r0, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
     dce:	2201      	movs	r2, #1
     dd0:	4f2f      	ldr	r7, [pc, #188]	; (e90 <sys_clock_set_timeout+0xd8>)
    return (uint32_t)p_reg->CC[cc_channel];
     dd2:	4c30      	ldr	r4, [pc, #192]	; (e94 <sys_clock_set_timeout+0xdc>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
     dd4:	603a      	str	r2, [r7, #0]
    return (uint32_t)p_reg->CC[cc_channel];
     dd6:	4e30      	ldr	r6, [pc, #192]	; (e98 <sys_clock_set_timeout+0xe0>)
	uint32_t unannounced = counter_sub(counter(), last_count);
     dd8:	4a30      	ldr	r2, [pc, #192]	; (e9c <sys_clock_set_timeout+0xe4>)
     dda:	59a0      	ldr	r0, [r4, r6]
     ddc:	6812      	ldr	r2, [r2, #0]
	return (a - b) & COUNTER_MAX;
     dde:	1a80      	subs	r0, r0, r2
	uint32_t unannounced = counter_sub(counter(), last_count);
     de0:	9201      	str	r2, [sp, #4]
		ticks = 0;
     de2:	43c2      	mvns	r2, r0
     de4:	17d2      	asrs	r2, r2, #31
     de6:	4013      	ands	r3, r2
	cyc += (CYC_PER_TICK - 1);
     de8:	4a2d      	ldr	r2, [pc, #180]	; (ea0 <sys_clock_set_timeout+0xe8>)
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
     dea:	4353      	muls	r3, r2
	cyc += (CYC_PER_TICK - 1);
     dec:	1880      	adds	r0, r0, r2
     dee:	18c0      	adds	r0, r0, r3
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
     df0:	0011      	movs	r1, r2
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
     df2:	0015      	movs	r5, r2
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
     df4:	f7ff f96c 	bl	d0 <__udivsi3>
     df8:	4345      	muls	r5, r0
	if (cyc > MAX_CYCLES) {
     dfa:	4b2a      	ldr	r3, [pc, #168]	; (ea4 <sys_clock_set_timeout+0xec>)
     dfc:	429d      	cmp	r5, r3
     dfe:	d900      	bls.n	e02 <sys_clock_set_timeout+0x4a>
     e00:	001d      	movs	r5, r3
	cyc += last_count;
     e02:	9b01      	ldr	r3, [sp, #4]
    p_reg->INTENCLR = mask;
     e04:	2280      	movs	r2, #128	; 0x80
     e06:	195b      	adds	r3, r3, r5
     e08:	9301      	str	r3, [sp, #4]
     e0a:	23c2      	movs	r3, #194	; 0xc2
     e0c:	0252      	lsls	r2, r2, #9
     e0e:	009b      	lsls	r3, r3, #2
     e10:	50e2      	str	r2, [r4, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
     e12:	2301      	movs	r3, #1
    return (uint32_t)p_reg->CC[cc_channel];
     e14:	22a8      	movs	r2, #168	; 0xa8
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
     e16:	2100      	movs	r1, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
     e18:	603b      	str	r3, [r7, #0]
    return (uint32_t)p_reg->CC[cc_channel];
     e1a:	00d2      	lsls	r2, r2, #3
     e1c:	59a3      	ldr	r3, [r4, r6]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
     e1e:	4d22      	ldr	r5, [pc, #136]	; (ea8 <sys_clock_set_timeout+0xf0>)
    return (uint32_t)p_reg->CC[cc_channel];
     e20:	58a0      	ldr	r0, [r4, r2]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
     e22:	6029      	str	r1, [r5, #0]
	return (a - b) & COUNTER_MAX;
     e24:	1ac0      	subs	r0, r0, r3
    p_reg->CC[cc_channel] = cc_value;
     e26:	50a3      	str	r3, [r4, r2]
	if (counter_sub(prev_val, now) == 1) {
     e28:	2801      	cmp	r0, #1
     e2a:	d103      	bne.n	e34 <sys_clock_set_timeout+0x7c>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_BUSY_WAIT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_busy_wait(usec_to_wait);
     e2c:	f004 ff6c 	bl	5d08 <z_impl_k_busy_wait>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
     e30:	2300      	movs	r3, #0
     e32:	602b      	str	r3, [r5, #0]
     e34:	23c0      	movs	r3, #192	; 0xc0
     e36:	2280      	movs	r2, #128	; 0x80
     e38:	491c      	ldr	r1, [pc, #112]	; (eac <sys_clock_set_timeout+0xf4>)
     e3a:	005b      	lsls	r3, r3, #1
     e3c:	0052      	lsls	r2, r2, #1
     e3e:	50ca      	str	r2, [r1, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
     e40:	3b80      	subs	r3, #128	; 0x80
     e42:	3bff      	subs	r3, #255	; 0xff
     e44:	603b      	str	r3, [r7, #0]
	return (a - b) & COUNTER_MAX;
     e46:	9a01      	ldr	r2, [sp, #4]
    return (uint32_t)p_reg->CC[cc_channel];
     e48:	59a3      	ldr	r3, [r4, r6]
     e4a:	1ad1      	subs	r1, r2, r3
     e4c:	22a8      	movs	r2, #168	; 0xa8
     e4e:	00d2      	lsls	r2, r2, #3
	if (diff == 1U) {
     e50:	2901      	cmp	r1, #1
     e52:	d118      	bne.n	e86 <sys_clock_set_timeout+0xce>
		set_comparator(t + 2U);
     e54:	1c98      	adds	r0, r3, #2
    p_reg->CC[cc_channel] = cc_value;
     e56:	50a0      	str	r0, [r4, r2]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
     e58:	6039      	str	r1, [r7, #0]
    return (uint32_t)p_reg->CC[cc_channel];
     e5a:	59a0      	ldr	r0, [r4, r6]
	while (t != counter()) {
     e5c:	4298      	cmp	r0, r3
     e5e:	d10f      	bne.n	e80 <sys_clock_set_timeout+0xc8>
    p_reg->INTENSET = mask;
     e60:	23c1      	movs	r3, #193	; 0xc1
     e62:	2280      	movs	r2, #128	; 0x80
     e64:	009b      	lsls	r3, r3, #2
     e66:	0252      	lsls	r2, r2, #9
     e68:	50e2      	str	r2, [r4, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
     e6a:	2300      	movs	r3, #0
     e6c:	2280      	movs	r2, #128	; 0x80
     e6e:	602b      	str	r3, [r5, #0]
     e70:	490e      	ldr	r1, [pc, #56]	; (eac <sys_clock_set_timeout+0xf4>)
     e72:	3381      	adds	r3, #129	; 0x81
     e74:	33ff      	adds	r3, #255	; 0xff
     e76:	0052      	lsls	r2, r2, #1
     e78:	50ca      	str	r2, [r1, r3]
}
     e7a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
     e7c:	4803      	ldr	r0, [pc, #12]	; (e8c <sys_clock_set_timeout+0xd4>)
     e7e:	e7a5      	b.n	dcc <sys_clock_set_timeout+0x14>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
     e80:	6039      	str	r1, [r7, #0]
    return (uint32_t)p_reg->CC[cc_channel];
     e82:	59a3      	ldr	r3, [r4, r6]
     e84:	e7e6      	b.n	e54 <sys_clock_set_timeout+0x9c>
    p_reg->CC[cc_channel] = cc_value;
     e86:	9b01      	ldr	r3, [sp, #4]
     e88:	50a3      	str	r3, [r4, r2]
}
     e8a:	e7e9      	b.n	e60 <sys_clock_set_timeout+0xa8>
     e8c:	000346db 	.word	0x000346db
     e90:	40008044 	.word	0x40008044
     e94:	40008000 	.word	0x40008000
     e98:	00000544 	.word	0x00000544
     e9c:	20000280 	.word	0x20000280
     ea0:	00002710 	.word	0x00002710
     ea4:	7fffcab0 	.word	0x7fffcab0
     ea8:	40008140 	.word	0x40008140
     eac:	e000e100 	.word	0xe000e100

00000eb0 <sys_clock_elapsed>:
{
     eb0:	b570      	push	{r4, r5, r6, lr}
static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	unsigned int key;

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	__asm__ volatile("mrs %0, PRIMASK;"
     eb2:	f3ef 8610 	mrs	r6, PRIMASK
     eb6:	b672      	cpsid	i
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
     eb8:	4c1e      	ldr	r4, [pc, #120]	; (f34 <sys_clock_elapsed+0x84>)
     eba:	0020      	movs	r0, r4
     ebc:	f002 fee8 	bl	3c90 <z_spin_lock_valid>
     ec0:	2800      	cmp	r0, #0
     ec2:	d10e      	bne.n	ee2 <sys_clock_elapsed+0x32>
     ec4:	4d1c      	ldr	r5, [pc, #112]	; (f38 <sys_clock_elapsed+0x88>)
     ec6:	2394      	movs	r3, #148	; 0x94
     ec8:	002a      	movs	r2, r5
     eca:	491c      	ldr	r1, [pc, #112]	; (f3c <sys_clock_elapsed+0x8c>)
     ecc:	481c      	ldr	r0, [pc, #112]	; (f40 <sys_clock_elapsed+0x90>)
     ece:	f004 fd0b 	bl	58e8 <assert_print>
     ed2:	0021      	movs	r1, r4
     ed4:	481b      	ldr	r0, [pc, #108]	; (f44 <sys_clock_elapsed+0x94>)
     ed6:	f004 fd07 	bl	58e8 <assert_print>
     eda:	2194      	movs	r1, #148	; 0x94
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
     edc:	0028      	movs	r0, r5
     ede:	f004 fcff 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
     ee2:	0020      	movs	r0, r4
     ee4:	f002 fef2 	bl	3ccc <z_spin_lock_set_owner>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
     ee8:	2201      	movs	r2, #1
     eea:	4b17      	ldr	r3, [pc, #92]	; (f48 <sys_clock_elapsed+0x98>)
	uint32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
     eec:	4917      	ldr	r1, [pc, #92]	; (f4c <sys_clock_elapsed+0x9c>)
     eee:	601a      	str	r2, [r3, #0]
    return (uint32_t)p_reg->CC[cc_channel];
     ef0:	4a17      	ldr	r2, [pc, #92]	; (f50 <sys_clock_elapsed+0xa0>)
     ef2:	4b18      	ldr	r3, [pc, #96]	; (f54 <sys_clock_elapsed+0xa4>)
     ef4:	58d0      	ldr	r0, [r2, r3]
     ef6:	4b18      	ldr	r3, [pc, #96]	; (f58 <sys_clock_elapsed+0xa8>)
	return (a - b) & COUNTER_MAX;
     ef8:	681b      	ldr	r3, [r3, #0]
     efa:	1ac0      	subs	r0, r0, r3
	uint32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
     efc:	f7ff f8e8 	bl	d0 <__udivsi3>
     f00:	0005      	movs	r5, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
     f02:	0020      	movs	r0, r4
     f04:	f002 fed4 	bl	3cb0 <z_spin_unlock_valid>
     f08:	2800      	cmp	r0, #0
     f0a:	d10c      	bne.n	f26 <sys_clock_elapsed+0x76>
     f0c:	4d0a      	ldr	r5, [pc, #40]	; (f38 <sys_clock_elapsed+0x88>)
     f0e:	23c3      	movs	r3, #195	; 0xc3
     f10:	002a      	movs	r2, r5
     f12:	4912      	ldr	r1, [pc, #72]	; (f5c <sys_clock_elapsed+0xac>)
     f14:	480a      	ldr	r0, [pc, #40]	; (f40 <sys_clock_elapsed+0x90>)
     f16:	f004 fce7 	bl	58e8 <assert_print>
     f1a:	0021      	movs	r1, r4
     f1c:	4810      	ldr	r0, [pc, #64]	; (f60 <sys_clock_elapsed+0xb0>)
     f1e:	f004 fce3 	bl	58e8 <assert_print>
     f22:	21c3      	movs	r1, #195	; 0xc3
     f24:	e7da      	b.n	edc <sys_clock_elapsed+0x2c>
 */

static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	if (key != 0U) {
     f26:	2e00      	cmp	r6, #0
     f28:	d102      	bne.n	f30 <sys_clock_elapsed+0x80>
		return;
	}
	__asm__ volatile(
     f2a:	b662      	cpsie	i
     f2c:	f3bf 8f6f 	isb	sy
}
     f30:	0028      	movs	r0, r5
     f32:	bd70      	pop	{r4, r5, r6, pc}
     f34:	20000284 	.word	0x20000284
     f38:	00006305 	.word	0x00006305
     f3c:	00006332 	.word	0x00006332
     f40:	00006347 	.word	0x00006347
     f44:	00006364 	.word	0x00006364
     f48:	40008044 	.word	0x40008044
     f4c:	00002710 	.word	0x00002710
     f50:	40008000 	.word	0x40008000
     f54:	00000544 	.word	0x00000544
     f58:	20000280 	.word	0x20000280
     f5c:	0000637c 	.word	0x0000637c
     f60:	00006393 	.word	0x00006393

00000f64 <sys_clock_cycle_get_32>:
{
     f64:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
     f66:	f3ef 8610 	mrs	r6, PRIMASK
     f6a:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
     f6c:	4c1b      	ldr	r4, [pc, #108]	; (fdc <sys_clock_cycle_get_32+0x78>)
     f6e:	0020      	movs	r0, r4
     f70:	f002 fe8e 	bl	3c90 <z_spin_lock_valid>
     f74:	2800      	cmp	r0, #0
     f76:	d10e      	bne.n	f96 <sys_clock_cycle_get_32+0x32>
     f78:	4d19      	ldr	r5, [pc, #100]	; (fe0 <sys_clock_cycle_get_32+0x7c>)
     f7a:	2394      	movs	r3, #148	; 0x94
     f7c:	002a      	movs	r2, r5
     f7e:	4919      	ldr	r1, [pc, #100]	; (fe4 <sys_clock_cycle_get_32+0x80>)
     f80:	4819      	ldr	r0, [pc, #100]	; (fe8 <sys_clock_cycle_get_32+0x84>)
     f82:	f004 fcb1 	bl	58e8 <assert_print>
     f86:	0021      	movs	r1, r4
     f88:	4818      	ldr	r0, [pc, #96]	; (fec <sys_clock_cycle_get_32+0x88>)
     f8a:	f004 fcad 	bl	58e8 <assert_print>
     f8e:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
     f90:	0028      	movs	r0, r5
     f92:	f004 fca5 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
     f96:	0020      	movs	r0, r4
     f98:	f002 fe98 	bl	3ccc <z_spin_lock_set_owner>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
     f9c:	2201      	movs	r2, #1
     f9e:	4b14      	ldr	r3, [pc, #80]	; (ff0 <sys_clock_cycle_get_32+0x8c>)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
     fa0:	0020      	movs	r0, r4
     fa2:	601a      	str	r2, [r3, #0]
    return (uint32_t)p_reg->CC[cc_channel];
     fa4:	4a13      	ldr	r2, [pc, #76]	; (ff4 <sys_clock_cycle_get_32+0x90>)
     fa6:	4b14      	ldr	r3, [pc, #80]	; (ff8 <sys_clock_cycle_get_32+0x94>)
     fa8:	58d5      	ldr	r5, [r2, r3]
     faa:	f002 fe81 	bl	3cb0 <z_spin_unlock_valid>
     fae:	2800      	cmp	r0, #0
     fb0:	d10c      	bne.n	fcc <sys_clock_cycle_get_32+0x68>
     fb2:	4d0b      	ldr	r5, [pc, #44]	; (fe0 <sys_clock_cycle_get_32+0x7c>)
     fb4:	23c3      	movs	r3, #195	; 0xc3
     fb6:	002a      	movs	r2, r5
     fb8:	4910      	ldr	r1, [pc, #64]	; (ffc <sys_clock_cycle_get_32+0x98>)
     fba:	480b      	ldr	r0, [pc, #44]	; (fe8 <sys_clock_cycle_get_32+0x84>)
     fbc:	f004 fc94 	bl	58e8 <assert_print>
     fc0:	0021      	movs	r1, r4
     fc2:	480f      	ldr	r0, [pc, #60]	; (1000 <CONFIG_NRF_MPU_FLASH_REGION_SIZE>)
     fc4:	f004 fc90 	bl	58e8 <assert_print>
     fc8:	21c3      	movs	r1, #195	; 0xc3
     fca:	e7e1      	b.n	f90 <sys_clock_cycle_get_32+0x2c>
	if (key != 0U) {
     fcc:	2e00      	cmp	r6, #0
     fce:	d102      	bne.n	fd6 <sys_clock_cycle_get_32+0x72>
	__asm__ volatile(
     fd0:	b662      	cpsie	i
     fd2:	f3bf 8f6f 	isb	sy
}
     fd6:	0028      	movs	r0, r5
     fd8:	bd70      	pop	{r4, r5, r6, pc}
     fda:	46c0      	nop			; (mov r8, r8)
     fdc:	20000284 	.word	0x20000284
     fe0:	00006305 	.word	0x00006305
     fe4:	00006332 	.word	0x00006332
     fe8:	00006347 	.word	0x00006347
     fec:	00006364 	.word	0x00006364
     ff0:	40008044 	.word	0x40008044
     ff4:	40008000 	.word	0x40008000
     ff8:	00000544 	.word	0x00000544
     ffc:	0000637c 	.word	0x0000637c
    1000:	00006393 	.word	0x00006393

00001004 <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
    1004:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    1006:	9001      	str	r0, [sp, #4]
	__asm__ volatile("mrs %0, PRIMASK;"
    1008:	f3ef 8610 	mrs	r6, PRIMASK
    100c:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    100e:	4c22      	ldr	r4, [pc, #136]	; (1098 <pm_state_notify+0x94>)
    1010:	0020      	movs	r0, r4
    1012:	f002 fe3d 	bl	3c90 <z_spin_lock_valid>
    1016:	2800      	cmp	r0, #0
    1018:	d10e      	bne.n	1038 <pm_state_notify+0x34>
    101a:	4d20      	ldr	r5, [pc, #128]	; (109c <pm_state_notify+0x98>)
    101c:	2394      	movs	r3, #148	; 0x94
    101e:	002a      	movs	r2, r5
    1020:	491f      	ldr	r1, [pc, #124]	; (10a0 <pm_state_notify+0x9c>)
    1022:	4820      	ldr	r0, [pc, #128]	; (10a4 <pm_state_notify+0xa0>)
    1024:	f004 fc60 	bl	58e8 <assert_print>
    1028:	0021      	movs	r1, r4
    102a:	481f      	ldr	r0, [pc, #124]	; (10a8 <pm_state_notify+0xa4>)
    102c:	f004 fc5c 	bl	58e8 <assert_print>
    1030:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    1032:	0028      	movs	r0, r5
    1034:	f004 fc54 	bl	58e0 <assert_post_action>
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_cpus_pm_state[_current_cpu->id].state);
    1038:	270c      	movs	r7, #12
	z_spin_lock_set_owner(l);
    103a:	0020      	movs	r0, r4
    103c:	f002 fe46 	bl	3ccc <z_spin_lock_set_owner>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
    1040:	4b1a      	ldr	r3, [pc, #104]	; (10ac <pm_state_notify+0xa8>)
    1042:	681d      	ldr	r5, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    1044:	2d00      	cmp	r5, #0
    1046:	d111      	bne.n	106c <pm_state_notify+0x68>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    1048:	0020      	movs	r0, r4
    104a:	f002 fe31 	bl	3cb0 <z_spin_unlock_valid>
    104e:	2800      	cmp	r0, #0
    1050:	d11c      	bne.n	108c <pm_state_notify+0x88>
    1052:	4d12      	ldr	r5, [pc, #72]	; (109c <pm_state_notify+0x98>)
    1054:	23c3      	movs	r3, #195	; 0xc3
    1056:	002a      	movs	r2, r5
    1058:	4915      	ldr	r1, [pc, #84]	; (10b0 <pm_state_notify+0xac>)
    105a:	4812      	ldr	r0, [pc, #72]	; (10a4 <pm_state_notify+0xa0>)
    105c:	f004 fc44 	bl	58e8 <assert_print>
    1060:	0021      	movs	r1, r4
    1062:	4814      	ldr	r0, [pc, #80]	; (10b4 <pm_state_notify+0xb0>)
    1064:	f004 fc40 	bl	58e8 <assert_print>
    1068:	21c3      	movs	r1, #195	; 0xc3
    106a:	e7e2      	b.n	1032 <pm_state_notify+0x2e>
		if (entering_state) {
    106c:	9b01      	ldr	r3, [sp, #4]
    106e:	2b00      	cmp	r3, #0
    1070:	d00a      	beq.n	1088 <pm_state_notify+0x84>
			callback = notifier->state_entry;
    1072:	686b      	ldr	r3, [r5, #4]
		if (callback) {
    1074:	2b00      	cmp	r3, #0
    1076:	d005      	beq.n	1084 <pm_state_notify+0x80>
			callback(z_cpus_pm_state[_current_cpu->id].state);
    1078:	490f      	ldr	r1, [pc, #60]	; (10b8 <pm_state_notify+0xb4>)
    107a:	4a10      	ldr	r2, [pc, #64]	; (10bc <pm_state_notify+0xb8>)
    107c:	7c09      	ldrb	r1, [r1, #16]
    107e:	4379      	muls	r1, r7
    1080:	5c88      	ldrb	r0, [r1, r2]
    1082:	4798      	blx	r3
	return node->next;
    1084:	682d      	ldr	r5, [r5, #0]
    1086:	e7dd      	b.n	1044 <pm_state_notify+0x40>
			callback = notifier->state_exit;
    1088:	68ab      	ldr	r3, [r5, #8]
    108a:	e7f3      	b.n	1074 <pm_state_notify+0x70>
	if (key != 0U) {
    108c:	2e00      	cmp	r6, #0
    108e:	d102      	bne.n	1096 <pm_state_notify+0x92>
	__asm__ volatile(
    1090:	b662      	cpsie	i
    1092:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
    1096:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    1098:	20000288 	.word	0x20000288
    109c:	00006305 	.word	0x00006305
    10a0:	00006332 	.word	0x00006332
    10a4:	00006347 	.word	0x00006347
    10a8:	00006364 	.word	0x00006364
    10ac:	200002a8 	.word	0x200002a8
    10b0:	0000637c 	.word	0x0000637c
    10b4:	00006393 	.word	0x00006393
    10b8:	20000330 	.word	0x20000330
    10bc:	2000029c 	.word	0x2000029c

000010c0 <pm_system_resume>:

void pm_system_resume(void)
{
    10c0:	b570      	push	{r4, r5, r6, lr}
	uint8_t id = CURRENT_CPU;
    10c2:	4b14      	ldr	r3, [pc, #80]	; (1114 <pm_system_resume+0x54>)
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    10c4:	2501      	movs	r5, #1
    10c6:	7c1c      	ldrb	r4, [r3, #16]
    10c8:	231f      	movs	r3, #31
    10ca:	4023      	ands	r3, r4
    10cc:	409d      	lsls	r5, r3
	atomic_val_t old;

	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    10ce:	4b12      	ldr	r3, [pc, #72]	; (1118 <pm_system_resume+0x58>)
    10d0:	0960      	lsrs	r0, r4, #5
    10d2:	0080      	lsls	r0, r0, #2
    10d4:	43e9      	mvns	r1, r5
    10d6:	18c0      	adds	r0, r0, r3
		union { uintptr_t x; atomic_val_t val; } parm1 = { .val = value };
		return (atomic_val_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_ATOMIC_AND);
	}
#endif
	compiler_barrier();
	return z_impl_atomic_and(target, value);
    10d8:	f004 fb1e 	bl	5718 <z_impl_atomic_and>
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
    10dc:	4228      	tst	r0, r5
    10de:	d013      	beq.n	1108 <pm_system_resume+0x48>
	if (pm_state_exit_post_ops != NULL) {
    10e0:	4b0e      	ldr	r3, [pc, #56]	; (111c <pm_system_resume+0x5c>)
    10e2:	4d0f      	ldr	r5, [pc, #60]	; (1120 <pm_system_resume+0x60>)
    10e4:	2b00      	cmp	r3, #0
    10e6:	d010      	beq.n	110a <pm_system_resume+0x4a>
		pm_state_exit_post_ops(info->state, info->substate_id);
    10e8:	230c      	movs	r3, #12
    10ea:	4363      	muls	r3, r4
    10ec:	18ea      	adds	r2, r5, r3
    10ee:	7851      	ldrb	r1, [r2, #1]
    10f0:	5ce8      	ldrb	r0, [r5, r3]
    10f2:	f004 fc8e 	bl	5a12 <pm_state_exit_post_ops>
		pm_exit_pos_ops(&z_cpus_pm_state[id]);
		pm_state_notify(false);
    10f6:	2000      	movs	r0, #0
    10f8:	f7ff ff84 	bl	1004 <pm_state_notify>
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
    10fc:	220c      	movs	r2, #12
    10fe:	4354      	muls	r4, r2
    1100:	2100      	movs	r1, #0
    1102:	1928      	adds	r0, r5, r4
    1104:	f004 fc58 	bl	59b8 <memset>
			0, 0};
	}
}
    1108:	bd70      	pop	{r4, r5, r6, pc}
    110a:	b662      	cpsie	i
    110c:	f3bf 8f6f 	isb	sy
    1110:	e7f1      	b.n	10f6 <pm_system_resume+0x36>
    1112:	46c0      	nop			; (mov r8, r8)
    1114:	20000330 	.word	0x20000330
    1118:	200002b0 	.word	0x200002b0
    111c:	00005a13 	.word	0x00005a13
    1120:	2000029c 	.word	0x2000029c

00001124 <pm_system_suspend>:

	return true;
}

bool pm_system_suspend(int32_t ticks)
{
    1124:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t id = CURRENT_CPU;
    1126:	4b4c      	ldr	r3, [pc, #304]	; (1258 <pm_system_suspend+0x134>)
{
    1128:	b085      	sub	sp, #20
    112a:	9002      	str	r0, [sp, #8]
	uint8_t id = CURRENT_CPU;
    112c:	7c1f      	ldrb	r7, [r3, #16]
	__asm__ volatile("mrs %0, PRIMASK;"
    112e:	f3ef 8310 	mrs	r3, PRIMASK
    1132:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    1134:	4e49      	ldr	r6, [pc, #292]	; (125c <pm_system_suspend+0x138>)
    1136:	9303      	str	r3, [sp, #12]
    1138:	0030      	movs	r0, r6
    113a:	f002 fda9 	bl	3c90 <z_spin_lock_valid>
    113e:	2800      	cmp	r0, #0
    1140:	d10e      	bne.n	1160 <pm_system_suspend+0x3c>
    1142:	4c47      	ldr	r4, [pc, #284]	; (1260 <pm_system_suspend+0x13c>)
    1144:	2394      	movs	r3, #148	; 0x94
    1146:	0022      	movs	r2, r4
    1148:	4946      	ldr	r1, [pc, #280]	; (1264 <pm_system_suspend+0x140>)
    114a:	4847      	ldr	r0, [pc, #284]	; (1268 <pm_system_suspend+0x144>)
    114c:	f004 fbcc 	bl	58e8 <assert_print>
    1150:	0031      	movs	r1, r6
    1152:	4846      	ldr	r0, [pc, #280]	; (126c <pm_system_suspend+0x148>)
    1154:	f004 fbc8 	bl	58e8 <assert_print>
    1158:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    115a:	0020      	movs	r0, r4
    115c:	f004 fbc0 	bl	58e0 <assert_post_action>
	k_spinlock_key_t key;

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	key = k_spin_lock(&pm_forced_state_lock);
	if (z_cpus_pm_forced_state[id].state != PM_STATE_ACTIVE) {
    1160:	240c      	movs	r4, #12
    1162:	437c      	muls	r4, r7
	z_spin_lock_set_owner(l);
    1164:	0030      	movs	r0, r6
    1166:	f002 fdb1 	bl	3ccc <z_spin_lock_set_owner>
    116a:	4b41      	ldr	r3, [pc, #260]	; (1270 <pm_system_suspend+0x14c>)
    116c:	0022      	movs	r2, r4
    116e:	469c      	mov	ip, r3
    1170:	5ce3      	ldrb	r3, [r4, r3]
    1172:	4d40      	ldr	r5, [pc, #256]	; (1274 <pm_system_suspend+0x150>)
    1174:	9401      	str	r4, [sp, #4]
    1176:	2b00      	cmp	r3, #0
    1178:	d019      	beq.n	11ae <pm_system_suspend+0x8a>
		z_cpus_pm_state[id] = z_cpus_pm_forced_state[id];
    117a:	192b      	adds	r3, r5, r4
    117c:	4462      	add	r2, ip
    117e:	ca13      	ldmia	r2!, {r0, r1, r4}
    1180:	c313      	stmia	r3!, {r0, r1, r4}
		z_cpus_pm_forced_state[id].state = PM_STATE_ACTIVE;
    1182:	2300      	movs	r3, #0
    1184:	4662      	mov	r2, ip
    1186:	9901      	ldr	r1, [sp, #4]
    1188:	548b      	strb	r3, [r1, r2]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    118a:	0030      	movs	r0, r6
    118c:	f002 fd90 	bl	3cb0 <z_spin_unlock_valid>
    1190:	1e04      	subs	r4, r0, #0
    1192:	d117      	bne.n	11c4 <pm_system_suspend+0xa0>
    1194:	4c32      	ldr	r4, [pc, #200]	; (1260 <pm_system_suspend+0x13c>)
    1196:	23c3      	movs	r3, #195	; 0xc3
    1198:	0022      	movs	r2, r4
    119a:	4937      	ldr	r1, [pc, #220]	; (1278 <pm_system_suspend+0x154>)
    119c:	4832      	ldr	r0, [pc, #200]	; (1268 <pm_system_suspend+0x144>)
    119e:	f004 fba3 	bl	58e8 <assert_print>
    11a2:	0031      	movs	r1, r6
    11a4:	4835      	ldr	r0, [pc, #212]	; (127c <pm_system_suspend+0x158>)
    11a6:	f004 fb9f 	bl	58e8 <assert_print>
    11aa:	21c3      	movs	r1, #195	; 0xc3
    11ac:	e7d5      	b.n	115a <pm_system_suspend+0x36>
	} else {
		const struct pm_state_info *info;

		info = pm_policy_next_state(id, ticks);
    11ae:	0038      	movs	r0, r7
    11b0:	9902      	ldr	r1, [sp, #8]
    11b2:	f000 f86d 	bl	1290 <pm_policy_next_state>
		if (info != NULL) {
    11b6:	2800      	cmp	r0, #0
    11b8:	d0e7      	beq.n	118a <pm_system_suspend+0x66>
			z_cpus_pm_state[id] = *info;
    11ba:	9b01      	ldr	r3, [sp, #4]
    11bc:	18ec      	adds	r4, r5, r3
    11be:	c80e      	ldmia	r0!, {r1, r2, r3}
    11c0:	c40e      	stmia	r4!, {r1, r2, r3}
    11c2:	e7e2      	b.n	118a <pm_system_suspend+0x66>
	if (key != 0U) {
    11c4:	9b03      	ldr	r3, [sp, #12]
    11c6:	2b00      	cmp	r3, #0
    11c8:	d102      	bne.n	11d0 <pm_system_suspend+0xac>
	__asm__ volatile(
    11ca:	b662      	cpsie	i
    11cc:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_forced_state_lock, key);

	if (z_cpus_pm_state[id].state == PM_STATE_ACTIVE) {
    11d0:	230c      	movs	r3, #12
    11d2:	437b      	muls	r3, r7
    11d4:	5cea      	ldrb	r2, [r5, r3]
    11d6:	2a00      	cmp	r2, #0
    11d8:	d03b      	beq.n	1252 <pm_system_suspend+0x12e>
		SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);
		return false;
	}

	if (ticks != K_TICKS_FOREVER) {
    11da:	9a02      	ldr	r2, [sp, #8]
    11dc:	3201      	adds	r2, #1
    11de:	d013      	beq.n	1208 <pm_system_suspend+0xe4>
		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		sys_clock_set_timeout(ticks -
		     k_us_to_ticks_ceil32(
    11e0:	18eb      	adds	r3, r5, r3
    11e2:	689e      	ldr	r6, [r3, #8]
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_us_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_us, Z_HZ_ticks, true, true, true, false);
    11e4:	2100      	movs	r1, #0
    11e6:	0030      	movs	r0, r6
		t += off;
    11e8:	2300      	movs	r3, #0
    11ea:	4a25      	ldr	r2, [pc, #148]	; (1280 <pm_system_suspend+0x15c>)
    11ec:	1880      	adds	r0, r0, r2
    11ee:	4159      	adcs	r1, r3
		if (result32 && (t < BIT64(32))) {
    11f0:	2900      	cmp	r1, #0
    11f2:	d129      	bne.n	1248 <pm_system_suspend+0x124>
			return ((uint32_t)t) / (from_hz / to_hz);
    11f4:	4b22      	ldr	r3, [pc, #136]	; (1280 <pm_system_suspend+0x15c>)
    11f6:	4923      	ldr	r1, [pc, #140]	; (1284 <pm_system_suspend+0x160>)
    11f8:	18f0      	adds	r0, r6, r3
    11fa:	f7fe ff69 	bl	d0 <__udivsi3>
		sys_clock_set_timeout(ticks -
    11fe:	9b02      	ldr	r3, [sp, #8]
    1200:	2101      	movs	r1, #1
    1202:	1a18      	subs	r0, r3, r0
    1204:	f7ff fdd8 	bl	db8 <sys_clock_set_timeout>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
    1208:	f003 f850 	bl	42ac <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
    120c:	2001      	movs	r0, #1
    120e:	f7ff fef9 	bl	1004 <pm_state_notify>
 * @param target Address of atomic variable or array.
 * @param bit Bit number (starting from 0).
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    1212:	231f      	movs	r3, #31
    1214:	2101      	movs	r1, #1
    1216:	403b      	ands	r3, r7
    1218:	4099      	lsls	r1, r3

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    121a:	0978      	lsrs	r0, r7, #5
    121c:	4b1a      	ldr	r3, [pc, #104]	; (1288 <pm_system_suspend+0x164>)
    121e:	0080      	lsls	r0, r0, #2
    1220:	18c0      	adds	r0, r0, r3
	return z_impl_atomic_or(target, value);
    1222:	f004 fa2f 	bl	5684 <z_impl_atomic_or>
	if (pm_state_set != NULL) {
    1226:	4b19      	ldr	r3, [pc, #100]	; (128c <pm_system_suspend+0x168>)
    1228:	2b00      	cmp	r3, #0
    122a:	d006      	beq.n	123a <pm_system_suspend+0x116>
		pm_state_set(info->state, info->substate_id);
    122c:	230c      	movs	r3, #12
    122e:	437b      	muls	r3, r7
    1230:	18ea      	adds	r2, r5, r3
    1232:	7851      	ldrb	r1, [r2, #1]
    1234:	5ce8      	ldrb	r0, [r5, r3]
    1236:	f004 fbdf 	bl	59f8 <pm_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_cpus_pm_state[id].state);
	pm_system_resume();
    123a:	f7ff ff41 	bl	10c0 <pm_system_resume>
	k_sched_unlock();
    123e:	f003 f8a5 	bl	438c <k_sched_unlock>
	SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);

	return true;
}
    1242:	0020      	movs	r0, r4
    1244:	b005      	add	sp, #20
    1246:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return t / ((uint64_t)from_hz / to_hz);
    1248:	2300      	movs	r3, #0
    124a:	4a0e      	ldr	r2, [pc, #56]	; (1284 <pm_system_suspend+0x160>)
    124c:	f7ff f81a 	bl	284 <__aeabi_uldivmod>
    1250:	e7d5      	b.n	11fe <pm_system_suspend+0xda>
		return false;
    1252:	0014      	movs	r4, r2
    1254:	e7f5      	b.n	1242 <pm_system_suspend+0x11e>
    1256:	46c0      	nop			; (mov r8, r8)
    1258:	20000330 	.word	0x20000330
    125c:	2000028c 	.word	0x2000028c
    1260:	00006305 	.word	0x00006305
    1264:	00006332 	.word	0x00006332
    1268:	00006347 	.word	0x00006347
    126c:	00006364 	.word	0x00006364
    1270:	20000290 	.word	0x20000290
    1274:	2000029c 	.word	0x2000029c
    1278:	0000637c 	.word	0x0000637c
    127c:	00006393 	.word	0x00006393
    1280:	0000270f 	.word	0x0000270f
    1284:	00002710 	.word	0x00002710
    1288:	200002b0 	.word	0x200002b0
    128c:	000059f9 	.word	0x000059f9

00001290 <pm_policy_next_state>:
	next_event_cyc = new_next_event_cyc;
}

#ifdef CONFIG_PM_POLICY_DEFAULT
const struct pm_state_info *pm_policy_next_state(uint8_t cpu, int32_t ticks)
{
    1290:	b5f0      	push	{r4, r5, r6, r7, lr}
    1292:	b087      	sub	sp, #28
	int64_t cyc = -1;
    1294:	9102      	str	r1, [sp, #8]
    1296:	9101      	str	r1, [sp, #4]
	uint8_t num_cpu_states;
	const struct pm_state_info *cpu_states;

	if (ticks != K_TICKS_FOREVER) {
    1298:	1c4b      	adds	r3, r1, #1
    129a:	d004      	beq.n	12a6 <pm_policy_next_state+0x16>
			return ((uint32_t)t) * (to_hz / from_hz);
    129c:	4b2d      	ldr	r3, [pc, #180]	; (1354 <pm_policy_next_state+0xc4>)
    129e:	434b      	muls	r3, r1
    12a0:	9302      	str	r3, [sp, #8]
		cyc = k_ticks_to_cyc_ceil32(ticks);
    12a2:	2300      	movs	r3, #0
    12a4:	9301      	str	r3, [sp, #4]
	}

	num_cpu_states = pm_state_cpu_get_all(cpu, &cpu_states);
    12a6:	a905      	add	r1, sp, #20
    12a8:	f000 f85a 	bl	1360 <pm_state_cpu_get_all>

	if (next_event_cyc >= 0) {
    12ac:	4c2a      	ldr	r4, [pc, #168]	; (1358 <pm_policy_next_state+0xc8>)
	num_cpu_states = pm_state_cpu_get_all(cpu, &cpu_states);
    12ae:	9003      	str	r0, [sp, #12]
	if (next_event_cyc >= 0) {
    12b0:	6863      	ldr	r3, [r4, #4]
    12b2:	2b00      	cmp	r3, #0
    12b4:	db18      	blt.n	12e8 <pm_policy_next_state+0x58>
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
    12b6:	f7ff fe55 	bl	f64 <sys_clock_cycle_get_32>
		uint32_t cyc_curr = k_cycle_get_32();
		int64_t cyc_evt = next_event_cyc - cyc_curr;
    12ba:	6826      	ldr	r6, [r4, #0]
    12bc:	6867      	ldr	r7, [r4, #4]
    12be:	2500      	movs	r5, #0
    12c0:	0004      	movs	r4, r0
    12c2:	0032      	movs	r2, r6
    12c4:	003b      	movs	r3, r7
    12c6:	1b12      	subs	r2, r2, r4
    12c8:	41ab      	sbcs	r3, r5

		/* event happening after cycle counter max value, pad */
		if (next_event_cyc <= cyc_curr) {
    12ca:	42af      	cmp	r7, r5
    12cc:	dc07      	bgt.n	12de <pm_policy_next_state+0x4e>
    12ce:	d101      	bne.n	12d4 <pm_policy_next_state+0x44>
    12d0:	4286      	cmp	r6, r0
    12d2:	d804      	bhi.n	12de <pm_policy_next_state+0x4e>
			cyc_evt += UINT32_MAX;
    12d4:	2001      	movs	r0, #1
    12d6:	2100      	movs	r1, #0
    12d8:	4240      	negs	r0, r0
    12da:	1812      	adds	r2, r2, r0
    12dc:	414b      	adcs	r3, r1
		}

		if (cyc_evt > 0) {
    12de:	2b00      	cmp	r3, #0
    12e0:	dc05      	bgt.n	12ee <pm_policy_next_state+0x5e>
    12e2:	d101      	bne.n	12e8 <pm_policy_next_state+0x58>
    12e4:	2a00      	cmp	r2, #0
    12e6:	d102      	bne.n	12ee <pm_policy_next_state+0x5e>
			 * otherwise, who comes earlier wins
			 */
			if (cyc < 0) {
				cyc = cyc_evt;
			} else {
				cyc = MIN(cyc, cyc_evt);
    12e8:	9a02      	ldr	r2, [sp, #8]
    12ea:	9b01      	ldr	r3, [sp, #4]
    12ec:	e00c      	b.n	1308 <pm_policy_next_state+0x78>
			if (cyc < 0) {
    12ee:	9902      	ldr	r1, [sp, #8]
    12f0:	3101      	adds	r1, #1
    12f2:	d102      	bne.n	12fa <pm_policy_next_state+0x6a>
    12f4:	9901      	ldr	r1, [sp, #4]
    12f6:	3101      	adds	r1, #1
    12f8:	d006      	beq.n	1308 <pm_policy_next_state+0x78>
				cyc = MIN(cyc, cyc_evt);
    12fa:	9901      	ldr	r1, [sp, #4]
    12fc:	428b      	cmp	r3, r1
    12fe:	dcf3      	bgt.n	12e8 <pm_policy_next_state+0x58>
    1300:	d102      	bne.n	1308 <pm_policy_next_state+0x78>
    1302:	9902      	ldr	r1, [sp, #8]
    1304:	428a      	cmp	r2, r1
    1306:	d8ef      	bhi.n	12e8 <pm_policy_next_state+0x58>

		min_residency_cyc = k_us_to_cyc_ceil32(state->min_residency_us);
		exit_latency_cyc = k_us_to_cyc_ceil32(state->exit_latency_us);

		/* skip state if it brings too much latency */
		if ((max_latency_cyc >= 0) &&
    1308:	4814      	ldr	r0, [pc, #80]	; (135c <pm_policy_next_state+0xcc>)
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
    130a:	9903      	ldr	r1, [sp, #12]
		if ((max_latency_cyc >= 0) &&
    130c:	6806      	ldr	r6, [r0, #0]
    130e:	200c      	movs	r0, #12
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
    1310:	1e4c      	subs	r4, r1, #1
    1312:	b224      	sxth	r4, r4
    1314:	4360      	muls	r0, r4
    1316:	9c05      	ldr	r4, [sp, #20]
    1318:	1824      	adds	r4, r4, r0
    131a:	2900      	cmp	r1, #0
    131c:	d102      	bne.n	1324 <pm_policy_next_state+0x94>
		    (cyc >= (min_residency_cyc + exit_latency_cyc))) {
			return state;
		}
	}

	return NULL;
    131e:	0008      	movs	r0, r1
}
    1320:	b007      	add	sp, #28
    1322:	bdf0      	pop	{r4, r5, r6, r7, pc}
		const struct pm_state_info *state = &cpu_states[i];
    1324:	0020      	movs	r0, r4
		exit_latency_cyc = k_us_to_cyc_ceil32(state->exit_latency_us);
    1326:	68a5      	ldr	r5, [r4, #8]
		if ((max_latency_cyc >= 0) &&
    1328:	2e00      	cmp	r6, #0
    132a:	db01      	blt.n	1330 <pm_policy_next_state+0xa0>
    132c:	42b5      	cmp	r5, r6
    132e:	d20c      	bcs.n	134a <pm_policy_next_state+0xba>
		if ((cyc < 0) ||
    1330:	1c57      	adds	r7, r2, #1
    1332:	d101      	bne.n	1338 <pm_policy_next_state+0xa8>
    1334:	1c5f      	adds	r7, r3, #1
    1336:	d0f3      	beq.n	1320 <pm_policy_next_state+0x90>
		    (cyc >= (min_residency_cyc + exit_latency_cyc))) {
    1338:	6867      	ldr	r7, [r4, #4]
    133a:	46bc      	mov	ip, r7
		if ((cyc < 0) ||
    133c:	2700      	movs	r7, #0
		    (cyc >= (min_residency_cyc + exit_latency_cyc))) {
    133e:	4465      	add	r5, ip
		if ((cyc < 0) ||
    1340:	429f      	cmp	r7, r3
    1342:	dc02      	bgt.n	134a <pm_policy_next_state+0xba>
    1344:	d1ec      	bne.n	1320 <pm_policy_next_state+0x90>
    1346:	4295      	cmp	r5, r2
    1348:	d9ea      	bls.n	1320 <pm_policy_next_state+0x90>
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
    134a:	3901      	subs	r1, #1
    134c:	b289      	uxth	r1, r1
    134e:	3c0c      	subs	r4, #12
    1350:	e7e3      	b.n	131a <pm_policy_next_state+0x8a>
    1352:	46c0      	nop			; (mov r8, r8)
    1354:	00002710 	.word	0x00002710
    1358:	20000000 	.word	0x20000000
    135c:	2000000c 	.word	0x2000000c

00001360 <pm_state_cpu_get_all>:
	DT_FOREACH_CHILD_SEP(DT_PATH(cpus), DT_NUM_CPU_POWER_STATES, (,))
};

uint8_t pm_state_cpu_get_all(uint8_t cpu, const struct pm_state_info **states)
{
	if (cpu >= ARRAY_SIZE(cpus_states)) {
    1360:	2800      	cmp	r0, #0
    1362:	d101      	bne.n	1368 <pm_state_cpu_get_all+0x8>
		return 0;
	}

	*states = cpus_states[cpu];
    1364:	4b01      	ldr	r3, [pc, #4]	; (136c <pm_state_cpu_get_all+0xc>)
    1366:	600b      	str	r3, [r1, #0]

	return states_per_cpu[cpu];
}
    1368:	2000      	movs	r0, #0
    136a:	4770      	bx	lr
    136c:	00005ee8 	.word	0x00005ee8

00001370 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    1370:	4901      	ldr	r1, [pc, #4]	; (1378 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    1372:	2210      	movs	r2, #16
	str	r2, [r1]
    1374:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    1376:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    1378:	e000ed10 	.word	0xe000ed10

0000137c <arch_cpu_idle>:
	 * (i.e. if the caller sets _kernel.idle).
	 */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	/* Enter low power state */
	_sleep_if_allowed wfi
    137c:	f3bf 8f4f 	dsb	sy
    1380:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    1382:	b662      	cpsie	i
	isb
    1384:	f3bf 8f6f 	isb	sy

	bx	lr
    1388:	4770      	bx	lr
    138a:	46c0      	nop			; (mov r8, r8)

0000138c <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    138c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    138e:	0005      	movs	r5, r0
    1390:	1e0c      	subs	r4, r1, #0

	if (esf != NULL) {
    1392:	d019      	beq.n	13c8 <z_arm_fatal_error+0x3c>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    1394:	688b      	ldr	r3, [r1, #8]
    1396:	480f      	ldr	r0, [pc, #60]	; (13d4 <z_arm_fatal_error+0x48>)
    1398:	9300      	str	r3, [sp, #0]
    139a:	684b      	ldr	r3, [r1, #4]
    139c:	680a      	ldr	r2, [r1, #0]
    139e:	2145      	movs	r1, #69	; 0x45
    13a0:	f004 faae 	bl	5900 <z_log_minimal_printk>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    13a4:	6963      	ldr	r3, [r4, #20]
    13a6:	2145      	movs	r1, #69	; 0x45
    13a8:	9300      	str	r3, [sp, #0]
    13aa:	480b      	ldr	r0, [pc, #44]	; (13d8 <z_arm_fatal_error+0x4c>)
    13ac:	6923      	ldr	r3, [r4, #16]
    13ae:	68e2      	ldr	r2, [r4, #12]
    13b0:	f004 faa6 	bl	5900 <z_log_minimal_printk>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    13b4:	2145      	movs	r1, #69	; 0x45
    13b6:	4809      	ldr	r0, [pc, #36]	; (13dc <z_arm_fatal_error+0x50>)
    13b8:	69e2      	ldr	r2, [r4, #28]
    13ba:	f004 faa1 	bl	5900 <z_log_minimal_printk>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    13be:	2145      	movs	r1, #69	; 0x45
    13c0:	4807      	ldr	r0, [pc, #28]	; (13e0 <z_arm_fatal_error+0x54>)
    13c2:	69a2      	ldr	r2, [r4, #24]
    13c4:	f004 fa9c 	bl	5900 <z_log_minimal_printk>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    13c8:	0028      	movs	r0, r5
    13ca:	0021      	movs	r1, r4
    13cc:	f002 f9f2 	bl	37b4 <z_fatal_error>
}
    13d0:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    13d2:	46c0      	nop			; (mov r8, r8)
    13d4:	000063ab 	.word	0x000063ab
    13d8:	000063df 	.word	0x000063df
    13dc:	00006413 	.word	0x00006413
    13e0:	00006427 	.word	0x00006427

000013e4 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    13e4:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    13e6:	0600      	lsls	r0, r0, #24
    13e8:	d405      	bmi.n	13f6 <arch_irq_enable+0x12>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    13ea:	221f      	movs	r2, #31
    13ec:	401a      	ands	r2, r3
    13ee:	2301      	movs	r3, #1
    13f0:	4093      	lsls	r3, r2
    13f2:	4a01      	ldr	r2, [pc, #4]	; (13f8 <arch_irq_enable+0x14>)
    13f4:	6013      	str	r3, [r2, #0]
}
    13f6:	4770      	bx	lr
    13f8:	e000e100 	.word	0xe000e100

000013fc <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    13fc:	4a05      	ldr	r2, [pc, #20]	; (1414 <arch_irq_is_enabled+0x18>)
    13fe:	0943      	lsrs	r3, r0, #5
    1400:	009b      	lsls	r3, r3, #2
    1402:	589b      	ldr	r3, [r3, r2]
    1404:	221f      	movs	r2, #31
    1406:	4010      	ands	r0, r2
    1408:	3a1e      	subs	r2, #30
    140a:	4082      	lsls	r2, r0
    140c:	4013      	ands	r3, r2
    140e:	0018      	movs	r0, r3
}
    1410:	4770      	bx	lr
    1412:	46c0      	nop			; (mov r8, r8)
    1414:	e000e100 	.word	0xe000e100

00001418 <z_arm_irq_priority_set>:
 * The priority is verified if ASSERT_ON is enabled. The maximum number
 * of priority levels is a little complex, as there are some hardware
 * priority levels which are reserved.
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
    1418:	b570      	push	{r4, r5, r6, lr}
    141a:	0005      	movs	r5, r0
    141c:	000c      	movs	r4, r1
	/* The last priority level is also used by PendSV exception, but
	 * allow other interrupts to use the same level, even if it ends up
	 * affecting performance (can still be useful on systems with a
	 * reduced set of priorities, like Cortex-M0/M0+).
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
    141e:	2903      	cmp	r1, #3
    1420:	d910      	bls.n	1444 <z_arm_irq_priority_set+0x2c>
    1422:	4e19      	ldr	r6, [pc, #100]	; (1488 <z_arm_irq_priority_set+0x70>)
    1424:	235c      	movs	r3, #92	; 0x5c
    1426:	0032      	movs	r2, r6
    1428:	4918      	ldr	r1, [pc, #96]	; (148c <z_arm_irq_priority_set+0x74>)
    142a:	4819      	ldr	r0, [pc, #100]	; (1490 <z_arm_irq_priority_set+0x78>)
    142c:	f004 fa5c 	bl	58e8 <assert_print>
    1430:	0021      	movs	r1, r4
    1432:	4818      	ldr	r0, [pc, #96]	; (1494 <z_arm_irq_priority_set+0x7c>)
    1434:	2304      	movs	r3, #4
    1436:	002a      	movs	r2, r5
    1438:	f004 fa56 	bl	58e8 <assert_print>
    143c:	215c      	movs	r1, #92	; 0x5c
    143e:	0030      	movs	r0, r6
    1440:	f004 fa4e 	bl	58e0 <assert_post_action>
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    1444:	2203      	movs	r2, #3
    1446:	21ff      	movs	r1, #255	; 0xff
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    1448:	b240      	sxtb	r0, r0
    144a:	4002      	ands	r2, r0
    144c:	00d2      	lsls	r2, r2, #3
    144e:	4091      	lsls	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    1450:	01a3      	lsls	r3, r4, #6
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    1452:	43c9      	mvns	r1, r1
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    1454:	4093      	lsls	r3, r2
  if ((int32_t)(IRQn) >= 0)
    1456:	2800      	cmp	r0, #0
    1458:	db0a      	blt.n	1470 <z_arm_irq_priority_set+0x58>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    145a:	24c0      	movs	r4, #192	; 0xc0
    145c:	4a0e      	ldr	r2, [pc, #56]	; (1498 <z_arm_irq_priority_set+0x80>)
    145e:	0880      	lsrs	r0, r0, #2
    1460:	0080      	lsls	r0, r0, #2
    1462:	1880      	adds	r0, r0, r2
    1464:	00a4      	lsls	r4, r4, #2
    1466:	5902      	ldr	r2, [r0, r4]
    1468:	400a      	ands	r2, r1
    146a:	4313      	orrs	r3, r2
    146c:	5103      	str	r3, [r0, r4]
}
    146e:	bd70      	pop	{r4, r5, r6, pc}
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    1470:	220f      	movs	r2, #15
    1472:	4010      	ands	r0, r2
    1474:	3808      	subs	r0, #8
    1476:	4a09      	ldr	r2, [pc, #36]	; (149c <z_arm_irq_priority_set+0x84>)
    1478:	0880      	lsrs	r0, r0, #2
    147a:	0080      	lsls	r0, r0, #2
    147c:	1880      	adds	r0, r0, r2
    147e:	69c2      	ldr	r2, [r0, #28]
    1480:	4011      	ands	r1, r2
    1482:	4319      	orrs	r1, r3
    1484:	61c1      	str	r1, [r0, #28]
    1486:	e7f2      	b.n	146e <z_arm_irq_priority_set+0x56>
    1488:	0000645a 	.word	0x0000645a
    148c:	00006490 	.word	0x00006490
    1490:	00006347 	.word	0x00006347
    1494:	000064ab 	.word	0x000064ab
    1498:	e000e100 	.word	0xe000e100
    149c:	e000ed00 	.word	0xe000ed00

000014a0 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    14a0:	bf30      	wfi
    b z_SysNmiOnReset
    14a2:	e7fd      	b.n	14a0 <z_SysNmiOnReset>

000014a4 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
    14a4:	4a0a      	ldr	r2, [pc, #40]	; (14d0 <arch_swap+0x2c>)
    14a6:	6893      	ldr	r3, [r2, #8]
    14a8:	0019      	movs	r1, r3
    14aa:	3188      	adds	r1, #136	; 0x88
    14ac:	6008      	str	r0, [r1, #0]
	_current->arch.swap_return_value = _k_neg_eagain;
    14ae:	4909      	ldr	r1, [pc, #36]	; (14d4 <arch_swap+0x30>)
    14b0:	338c      	adds	r3, #140	; 0x8c
    14b2:	6809      	ldr	r1, [r1, #0]
    14b4:	6019      	str	r1, [r3, #0]

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    14b6:	2380      	movs	r3, #128	; 0x80
    14b8:	4907      	ldr	r1, [pc, #28]	; (14d8 <arch_swap+0x34>)
    14ba:	055b      	lsls	r3, r3, #21
    14bc:	6848      	ldr	r0, [r1, #4]
    14be:	4303      	orrs	r3, r0
    14c0:	604b      	str	r3, [r1, #4]
    14c2:	b662      	cpsie	i
    14c4:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    14c8:	6893      	ldr	r3, [r2, #8]
    14ca:	338c      	adds	r3, #140	; 0x8c
    14cc:	6818      	ldr	r0, [r3, #0]
}
    14ce:	4770      	bx	lr
    14d0:	20000330 	.word	0x20000330
    14d4:	00005fc0 	.word	0x00005fc0
    14d8:	e000ed00 	.word	0xe000ed00

000014dc <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    14dc:	4914      	ldr	r1, [pc, #80]	; (1530 <_thread_irq_disabled+0x1e>)
    ldr r2, [r1, #_kernel_offset_to_current]
    14de:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    14e0:	4814      	ldr	r0, [pc, #80]	; (1534 <_thread_irq_disabled+0x22>)
    add r0, r2
    14e2:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    14e4:	f3ef 8c09 	mrs	ip, PSP
#endif

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    /* Store current r4-r7 */
    stmea r0!, {r4-r7}
    14e8:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    /* copy r8-r12 into r3-r7 */
    mov r3, r8
    14ea:	4643      	mov	r3, r8
    mov r4, r9
    14ec:	464c      	mov	r4, r9
    mov r5, r10
    14ee:	4655      	mov	r5, sl
    mov r6, r11
    14f0:	465e      	mov	r6, fp
    mov r7, ip
    14f2:	4667      	mov	r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
    14f4:	c0f8      	stmia	r0!, {r3, r4, r5, r6, r7}
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
    14f6:	b672      	cpsid	i
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    14f8:	4f0f      	ldr	r7, [pc, #60]	; (1538 <_thread_irq_disabled+0x26>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    14fa:	4e10      	ldr	r6, [pc, #64]	; (153c <_thread_irq_disabled+0x2a>)
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    14fc:	698a      	ldr	r2, [r1, #24]

    str r2, [r1, #_kernel_offset_to_current]
    14fe:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    1500:	603e      	str	r6, [r7, #0]
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) && (_thread_offset_to_basepri > 124)
    /* Doing it this way since the offset to thread->arch.basepri can in
     * some configurations be larger than the maximum of 124 for ldr/str
     * immediate offsets.
     */
    ldr r4, =_thread_offset_to_basepri
    1502:	4c0f      	ldr	r4, [pc, #60]	; (1540 <_thread_irq_disabled+0x2e>)
    adds r4, r2, r4
    1504:	1914      	adds	r4, r2, r4

    ldr r0, [r4]
    1506:	6820      	ldr	r0, [r4, #0]
    movs.n r3, #0
    1508:	2300      	movs	r3, #0
    str r3, [r4]
    150a:	6023      	str	r3, [r4, #0]
     * maps to PRIMASK.
     *
     * Only enable interrupts if value is 0, meaning interrupts
     * were enabled before irq_lock was called.
     */
    cmp r0, #0
    150c:	2800      	cmp	r0, #0
    bne _thread_irq_disabled
    150e:	d100      	bne.n	1512 <_thread_irq_disabled>
    cpsie i
    1510:	b662      	cpsie	i

00001512 <_thread_irq_disabled>:
     */
    isb

#endif

    ldr r4, =_thread_offset_to_callee_saved
    1512:	4c08      	ldr	r4, [pc, #32]	; (1534 <_thread_irq_disabled+0x22>)
    adds r0, r2, r4
    1514:	1910      	adds	r0, r2, r4

    /* restore r4-r12 for new thread */
    /* first restore r8-r12 located after r4-r7 (4*4bytes) */
    adds r0, #16
    1516:	3010      	adds	r0, #16
    ldmia r0!, {r3-r7}
    1518:	c8f8      	ldmia	r0!, {r3, r4, r5, r6, r7}
    /* move to correct registers */
    mov r8, r3
    151a:	4698      	mov	r8, r3
    mov r9, r4
    151c:	46a1      	mov	r9, r4
    mov r10, r5
    151e:	46aa      	mov	sl, r5
    mov r11, r6
    1520:	46b3      	mov	fp, r6
    mov ip, r7
    1522:	46bc      	mov	ip, r7
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    1524:	3824      	subs	r0, #36	; 0x24
    ldmia r0!, {r4-r7}
    1526:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    1528:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
    152c:	4770      	bx	lr
    152e:	0000      	.short	0x0000
    ldr r1, =_kernel
    1530:	20000330 	.word	0x20000330
    ldr r0, =_thread_offset_to_callee_saved
    1534:	00000030 	.word	0x00000030
    ldr v4, =_SCS_ICSR
    1538:	e000ed04 	.word	0xe000ed04
    ldr v3, =_SCS_ICSR_UNPENDSV
    153c:	08000000 	.word	0x08000000
    ldr r4, =_thread_offset_to_basepri
    1540:	00000088 	.word	0x00000088

00001544 <z_arm_svc>:
SECTION_FUNC(TEXT, z_arm_svc)
  /* Use EXC_RETURN state to find out if stack frame is on the
   * MSP or PSP
   */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
  movs r0, #_EXC_RETURN_SPSEL_Msk
    1544:	2004      	movs	r0, #4
  mov r1, lr
    1546:	4671      	mov	r1, lr
  tst r1, r0
    1548:	4201      	tst	r1, r0
  beq _stack_frame_msp
    154a:	d002      	beq.n	1552 <_stack_frame_msp>
  mrs r0, PSP
    154c:	f3ef 8009 	mrs	r0, PSP
  bne _stack_frame_endif
    1550:	d101      	bne.n	1556 <_stack_frame_endif>

00001552 <_stack_frame_msp>:
_stack_frame_msp:
  mrs r0, MSP
    1552:	f3ef 8008 	mrs	r0, MSP

00001556 <_stack_frame_endif>:
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    1556:	6981      	ldr	r1, [r0, #24]
    /* SVC is a two-byte instruction, point to it and read the
     * SVC number (lower byte of SCV instruction)
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    1558:	3902      	subs	r1, #2
    ldrb r1, [r1]
    155a:	7809      	ldrb	r1, [r1, #0]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    155c:	2902      	cmp	r1, #2
    beq _oops
    155e:	d0ff      	beq.n	1560 <_oops>

00001560 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    1560:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
    1562:	f004 f9d8 	bl	5916 <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
    1566:	bd01      	pop	{r0, pc}

00001568 <arch_new_thread>:
 * of the ESF.
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    1568:	b510      	push	{r4, lr}
	iframe->pc = (uint32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
    156a:	3a20      	subs	r2, #32
#endif
	iframe->a1 = (uint32_t)entry;
    156c:	6013      	str	r3, [r2, #0]
	iframe->a2 = (uint32_t)p1;
    156e:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
    1570:	2401      	movs	r4, #1
	iframe->a2 = (uint32_t)p1;
    1572:	6053      	str	r3, [r2, #4]
	iframe->a3 = (uint32_t)p2;
    1574:	9b03      	ldr	r3, [sp, #12]
	iframe->pc &= 0xfffffffe;
    1576:	4907      	ldr	r1, [pc, #28]	; (1594 <arch_new_thread+0x2c>)
	iframe->a3 = (uint32_t)p2;
    1578:	6093      	str	r3, [r2, #8]
	iframe->a4 = (uint32_t)p3;
    157a:	9b04      	ldr	r3, [sp, #16]
	iframe->pc &= 0xfffffffe;
    157c:	43a1      	bics	r1, r4
	iframe->a4 = (uint32_t)p3;
    157e:	60d3      	str	r3, [r2, #12]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    1580:	2380      	movs	r3, #128	; 0x80
    1582:	045b      	lsls	r3, r3, #17
    1584:	61d3      	str	r3, [r2, #28]
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
    1586:	2300      	movs	r3, #0
	iframe->pc &= 0xfffffffe;
    1588:	6191      	str	r1, [r2, #24]
	thread->callee_saved.psp = (uint32_t)iframe;
    158a:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
    158c:	3088      	adds	r0, #136	; 0x88
    158e:	6003      	str	r3, [r0, #0]
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    1590:	bd10      	pop	{r4, pc}
    1592:	46c0      	nop			; (mov r8, r8)
    1594:	000057d9 	.word	0x000057d9

00001598 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
    1598:	4b06      	ldr	r3, [pc, #24]	; (15b4 <arch_switch_to_main_thread+0x1c>)
    159a:	6098      	str	r0, [r3, #8]

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    159c:	1c10      	adds	r0, r2, #0
    159e:	f381 8809 	msr	PSP, r1
    15a2:	2100      	movs	r1, #0
    15a4:	b662      	cpsie	i
    15a6:	f3bf 8f6f 	isb	sy
    15aa:	2200      	movs	r2, #0
    15ac:	2300      	movs	r3, #0
    15ae:	f004 f913 	bl	57d8 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    15b2:	46c0      	nop			; (mov r8, r8)
    15b4:	20000330 	.word	0x20000330

000015b8 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    15b8:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    15ba:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    15bc:	4a0a      	ldr	r2, [pc, #40]	; (15e8 <_idle_state_cleared+0x1c>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    15be:	6950      	ldr	r0, [r2, #20]
	cmp r0, #0
    15c0:	2800      	cmp	r0, #0

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	beq _idle_state_cleared
    15c2:	d003      	beq.n	15cc <_idle_state_cleared>
	movs.n r1, #0
    15c4:	2100      	movs	r1, #0
	/* clear kernel idle state */
	str r1, [r2, #_kernel_offset_to_idle]
    15c6:	6151      	str	r1, [r2, #20]
	bl z_pm_save_idle_exit
    15c8:	f004 fb79 	bl	5cbe <z_pm_save_idle_exit>

000015cc <_idle_state_cleared>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    15cc:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    15ce:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
    15d2:	4906      	ldr	r1, [pc, #24]	; (15ec <_idle_state_cleared+0x20>)
	subs r0, r1	/* get IRQ number */
    15d4:	1a40      	subs	r0, r0, r1
	lsls r0, #3	/* table is 8-byte wide */
    15d6:	00c0      	lsls	r0, r0, #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    15d8:	4905      	ldr	r1, [pc, #20]	; (15f0 <_idle_state_cleared+0x24>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    15da:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    15dc:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    15de:	4798      	blx	r3
#ifdef CONFIG_TRACING_ISR
	bl sys_trace_isr_exit
#endif

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
    15e0:	bc09      	pop	{r0, r3}
	mov lr, r3
    15e2:	469e      	mov	lr, r3
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    15e4:	4903      	ldr	r1, [pc, #12]	; (15f4 <_idle_state_cleared+0x28>)
	bx r1
    15e6:	4708      	bx	r1
	ldr r2, =_kernel
    15e8:	20000330 	.word	0x20000330
	ldr r1, =16
    15ec:	00000010 	.word	0x00000010
	ldr r1, =_sw_isr_table
    15f0:	00005d94 	.word	0x00005d94
	ldr r1, =z_arm_int_exit
    15f4:	000015f9 	.word	0x000015f9

000015f8 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    15f8:	4b04      	ldr	r3, [pc, #16]	; (160c <_EXIT_EXC+0x4>)

	ldr r1, [r3, #_kernel_offset_to_current]
    15fa:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    15fc:	6998      	ldr	r0, [r3, #24]
	cmp r0, r1
    15fe:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    1600:	d002      	beq.n	1608 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    1602:	4903      	ldr	r1, [pc, #12]	; (1610 <_EXIT_EXC+0x8>)
	ldr r2, =_SCS_ICSR_PENDSV
    1604:	4a03      	ldr	r2, [pc, #12]	; (1614 <_EXIT_EXC+0xc>)
	str r2, [r1]
    1606:	600a      	str	r2, [r1, #0]

00001608 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    1608:	4770      	bx	lr
    160a:	0000      	.short	0x0000
	ldr r3, =_kernel
    160c:	20000330 	.word	0x20000330
	ldr r1, =_SCS_ICSR
    1610:	e000ed04 	.word	0xe000ed04
	ldr r2, =_SCS_ICSR_PENDSV
    1614:	10000000 	.word	0x10000000

00001618 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    1618:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    161a:	4b30      	ldr	r3, [pc, #192]	; (16dc <z_arm_fault+0xc4>)
{
    161c:	0004      	movs	r4, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    161e:	685d      	ldr	r5, [r3, #4]
{
    1620:	b088      	sub	sp, #32
    1622:	05eb      	lsls	r3, r5, #23
    1624:	0ddb      	lsrs	r3, r3, #23
    1626:	b662      	cpsie	i
    1628:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    162c:	0e10      	lsrs	r0, r2, #24
    162e:	28ff      	cmp	r0, #255	; 0xff
    1630:	d107      	bne.n	1642 <z_arm_fault+0x2a>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    1632:	38f3      	subs	r0, #243	; 0xf3
    1634:	4010      	ands	r0, r2
    1636:	2808      	cmp	r0, #8
    1638:	d111      	bne.n	165e <z_arm_fault+0x46>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    163a:	2145      	movs	r1, #69	; 0x45
    163c:	4828      	ldr	r0, [pc, #160]	; (16e0 <z_arm_fault+0xc8>)
    163e:	f004 f95f 	bl	5900 <z_log_minimal_printk>

	/* Retrieve the Exception Stack Frame (ESF) to be supplied
	 * as argument to the remainder of the fault handling process.
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
    1642:	4c28      	ldr	r4, [pc, #160]	; (16e4 <z_arm_fault+0xcc>)
    1644:	4928      	ldr	r1, [pc, #160]	; (16e8 <z_arm_fault+0xd0>)
    1646:	0022      	movs	r2, r4
    1648:	4828      	ldr	r0, [pc, #160]	; (16ec <z_arm_fault+0xd4>)
    164a:	4b29      	ldr	r3, [pc, #164]	; (16f0 <z_arm_fault+0xd8>)
    164c:	f004 f94c 	bl	58e8 <assert_print>
    1650:	4828      	ldr	r0, [pc, #160]	; (16f4 <z_arm_fault+0xdc>)
    1652:	f004 f949 	bl	58e8 <assert_print>
    1656:	0020      	movs	r0, r4
    1658:	4925      	ldr	r1, [pc, #148]	; (16f0 <z_arm_fault+0xd8>)
    165a:	f004 f941 	bl	58e0 <assert_post_action>
			*nested_exc = true;
    165e:	2601      	movs	r6, #1
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    1660:	0712      	lsls	r2, r2, #28
    1662:	d501      	bpl.n	1668 <z_arm_fault+0x50>
			ptr_esf =  (z_arch_esf_t *)psp;
    1664:	000c      	movs	r4, r1
	*nested_exc = false;
    1666:	2600      	movs	r6, #0
	__ASSERT(esf != NULL,
    1668:	2c00      	cmp	r4, #0
    166a:	d0ea      	beq.n	1642 <z_arm_fault+0x2a>
	switch (fault) {
    166c:	2b03      	cmp	r3, #3
    166e:	d125      	bne.n	16bc <z_arm_fault+0xa4>
	PR_FAULT_INFO("***** HARD FAULT *****");
    1670:	2145      	movs	r1, #69	; 0x45
    1672:	4821      	ldr	r0, [pc, #132]	; (16f8 <z_arm_fault+0xe0>)
    1674:	f004 f944 	bl	5900 <z_log_minimal_printk>
	uint16_t fault_insn = *(ret_addr - 1);
    1678:	69a3      	ldr	r3, [r4, #24]
    167a:	3b02      	subs	r3, #2
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
    167c:	881a      	ldrh	r2, [r3, #0]
    167e:	4b1f      	ldr	r3, [pc, #124]	; (16fc <z_arm_fault+0xe4>)
    1680:	429a      	cmp	r2, r3
    1682:	d126      	bne.n	16d2 <z_arm_fault+0xba>
		PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
    1684:	2145      	movs	r1, #69	; 0x45
    1686:	481e      	ldr	r0, [pc, #120]	; (1700 <z_arm_fault+0xe8>)
    1688:	6822      	ldr	r2, [r4, #0]
    168a:	f004 f939 	bl	5900 <z_log_minimal_printk>
		reason = esf->basic.r0;
    168e:	6825      	ldr	r5, [r4, #0]
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    1690:	2220      	movs	r2, #32
    1692:	0021      	movs	r1, r4
    1694:	4668      	mov	r0, sp
    1696:	f004 f986 	bl	59a6 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    169a:	9b07      	ldr	r3, [sp, #28]
    169c:	2e00      	cmp	r6, #0
    169e:	d01a      	beq.n	16d6 <z_arm_fault+0xbe>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    16a0:	05da      	lsls	r2, r3, #23
    16a2:	d102      	bne.n	16aa <z_arm_fault+0x92>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    16a4:	4a17      	ldr	r2, [pc, #92]	; (1704 <z_arm_fault+0xec>)
    16a6:	4313      	orrs	r3, r2
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    16a8:	9307      	str	r3, [sp, #28]
	}

	if (IS_ENABLED(CONFIG_SIMPLIFIED_EXCEPTION_CODES) && (reason >= K_ERR_ARCH_START)) {
    16aa:	2d0f      	cmp	r5, #15
    16ac:	d900      	bls.n	16b0 <z_arm_fault+0x98>
		reason = K_ERR_CPU_EXCEPTION;
    16ae:	2500      	movs	r5, #0
	}

	z_arm_fatal_error(reason, &esf_copy);
    16b0:	4669      	mov	r1, sp
    16b2:	0028      	movs	r0, r5
    16b4:	f7ff fe6a 	bl	138c <z_arm_fatal_error>
}
    16b8:	b008      	add	sp, #32
    16ba:	bd70      	pop	{r4, r5, r6, pc}
	PR_FAULT_INFO("***** %s %d) *****",
    16bc:	21f8      	movs	r1, #248	; 0xf8
    16be:	0049      	lsls	r1, r1, #1
    16c0:	4a11      	ldr	r2, [pc, #68]	; (1708 <z_arm_fault+0xf0>)
    16c2:	420d      	tst	r5, r1
    16c4:	d000      	beq.n	16c8 <z_arm_fault+0xb0>
    16c6:	4a11      	ldr	r2, [pc, #68]	; (170c <z_arm_fault+0xf4>)
    16c8:	2145      	movs	r1, #69	; 0x45
    16ca:	4811      	ldr	r0, [pc, #68]	; (1710 <z_arm_fault+0xf8>)
    16cc:	3b10      	subs	r3, #16
    16ce:	f004 f917 	bl	5900 <z_log_minimal_printk>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    16d2:	2500      	movs	r5, #0
    16d4:	e7dc      	b.n	1690 <z_arm_fault+0x78>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    16d6:	0a5b      	lsrs	r3, r3, #9
    16d8:	025b      	lsls	r3, r3, #9
    16da:	e7e5      	b.n	16a8 <z_arm_fault+0x90>
    16dc:	e000ed00 	.word	0xe000ed00
    16e0:	00006519 	.word	0x00006519
    16e4:	00006549 	.word	0x00006549
    16e8:	00006583 	.word	0x00006583
    16ec:	00006347 	.word	0x00006347
    16f0:	0000043f 	.word	0x0000043f
    16f4:	00006596 	.word	0x00006596
    16f8:	000065d4 	.word	0x000065d4
    16fc:	0000df02 	.word	0x0000df02
    1700:	000065f0 	.word	0x000065f0
    1704:	000001ff 	.word	0x000001ff
    1708:	000064eb 	.word	0x000064eb
    170c:	00006500 	.word	0x00006500
    1710:	00006611 	.word	0x00006611

00001714 <z_arm_exc_spurious>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    1714:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    1718:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    171c:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    171e:	4672      	mov	r2, lr
	bl z_arm_fault
    1720:	f7ff ff7a 	bl	1618 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    1724:	bd01      	pop	{r0, pc}
    1726:	46c0      	nop			; (mov r8, r8)

00001728 <z_arm_interrupt_init>:
 * interrupt locking via BASEPRI works as expected.
 *
 */

void z_arm_interrupt_init(void)
{
    1728:	b5f0      	push	{r4, r5, r6, r7, lr}
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    172a:	24c0      	movs	r4, #192	; 0xc0
	int irq = 0;
    172c:	2200      	movs	r2, #0
    172e:	2603      	movs	r6, #3
    1730:	25ff      	movs	r5, #255	; 0xff
    1732:	00a4      	lsls	r4, r4, #2
    1734:	0010      	movs	r0, r2
    1736:	002f      	movs	r7, r5
    1738:	4030      	ands	r0, r6
    173a:	00c0      	lsls	r0, r0, #3
    173c:	4087      	lsls	r7, r0
    173e:	4905      	ldr	r1, [pc, #20]	; (1754 <z_arm_interrupt_init+0x2c>)
    1740:	0893      	lsrs	r3, r2, #2
    1742:	009b      	lsls	r3, r3, #2
    1744:	185b      	adds	r3, r3, r1
    1746:	5919      	ldr	r1, [r3, r4]

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    1748:	3201      	adds	r2, #1
    174a:	43b9      	bics	r1, r7
    174c:	5119      	str	r1, [r3, r4]
    174e:	2a1a      	cmp	r2, #26
    1750:	d1f0      	bne.n	1734 <z_arm_interrupt_init+0xc>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    1752:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1754:	e000e100 	.word	0xe000e100

00001758 <__start>:
#if defined(CONFIG_PM_S2RAM)
    bl arch_pm_s2ram_resume
#endif /* CONFIG_PM_S2RAM */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
    1758:	f7ff fadc 	bl	d14 <z_arm_platform_init>
    bl z_arm_init_arch_hw_at_boot
#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
    175c:	b672      	cpsid	i

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    175e:	4807      	ldr	r0, [pc, #28]	; (177c <__start+0x24>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    1760:	4907      	ldr	r1, [pc, #28]	; (1780 <__start+0x28>)
    adds r0, r0, r1
    1762:	1840      	adds	r0, r0, r1
    msr PSP, r0
    1764:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    1768:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    176c:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    176e:	4308      	orrs	r0, r1
    msr CONTROL, r0
    1770:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    1774:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    1778:	f004 f8e0 	bl	593c <z_arm_prep_c>
    ldr r0, =z_interrupt_stacks
    177c:	20000780 	.word	0x20000780
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    1780:	00000800 	.word	0x00000800

00001784 <z_impl_k_thread_abort>:
#include <kswap.h>
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
    1784:	b510      	push	{r4, lr}
	if (_current == thread) {
    1786:	4b0a      	ldr	r3, [pc, #40]	; (17b0 <z_impl_k_thread_abort+0x2c>)
    1788:	689b      	ldr	r3, [r3, #8]
    178a:	4283      	cmp	r3, r0
    178c:	d10d      	bne.n	17aa <z_impl_k_thread_abort+0x26>
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    178e:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
    1792:	2b00      	cmp	r3, #0
    1794:	d009      	beq.n	17aa <z_impl_k_thread_abort+0x26>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    1796:	2280      	movs	r2, #128	; 0x80
    1798:	4b06      	ldr	r3, [pc, #24]	; (17b4 <z_impl_k_thread_abort+0x30>)
    179a:	0552      	lsls	r2, r2, #21
    179c:	6859      	ldr	r1, [r3, #4]
    179e:	430a      	orrs	r2, r1
    17a0:	605a      	str	r2, [r3, #4]
			/* Clear any system calls that may be pending
			 * as they have a higher priority than the PendSV
			 * handler and will check the stack of the thread
			 * being aborted.
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
    17a2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    17a4:	4904      	ldr	r1, [pc, #16]	; (17b8 <z_impl_k_thread_abort+0x34>)
    17a6:	400a      	ands	r2, r1
    17a8:	625a      	str	r2, [r3, #36]	; 0x24
		}
	}

	z_thread_abort(thread);
    17aa:	f003 fae9 	bl	4d80 <z_thread_abort>
}
    17ae:	bd10      	pop	{r4, pc}
    17b0:	20000330 	.word	0x20000330
    17b4:	e000ed00 	.word	0xe000ed00
    17b8:	ffff7fff 	.word	0xffff7fff

000017bc <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
    17bc:	4b01      	ldr	r3, [pc, #4]	; (17c4 <__stdout_hook_install+0x8>)
    17be:	6018      	str	r0, [r3, #0]
}
    17c0:	4770      	bx	lr
    17c2:	46c0      	nop			; (mov r8, r8)
    17c4:	20000010 	.word	0x20000010

000017c8 <arch_busy_wait>:
}

#define DELAY_CALL_OVERHEAD_US 2

void arch_busy_wait(uint32_t time_us)
{
    17c8:	b510      	push	{r4, lr}
	if (time_us <= DELAY_CALL_OVERHEAD_US) {
    17ca:	2802      	cmp	r0, #2
    17cc:	d905      	bls.n	17da <arch_busy_wait+0x12>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    17ce:	2301      	movs	r3, #1
    17d0:	4a02      	ldr	r2, [pc, #8]	; (17dc <arch_busy_wait+0x14>)
		return;
	}

	time_us -= DELAY_CALL_OVERHEAD_US;
    17d2:	3802      	subs	r0, #2
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    17d4:	0100      	lsls	r0, r0, #4
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    17d6:	4313      	orrs	r3, r2
    delay_cycles(cycles);
    17d8:	4798      	blx	r3
	nrfx_coredep_delay_us(time_us);
}
    17da:	bd10      	pop	{r4, pc}
    17dc:	00005ee0 	.word	0x00005ee0

000017e0 <ztest_find_test_suite>:
}

#endif /* !KERNEL */

static struct ztest_suite_node *ztest_find_test_suite(const char *name)
{
    17e0:	b570      	push	{r4, r5, r6, lr}
    17e2:	0005      	movs	r5, r0
	struct ztest_suite_node *node;

	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
    17e4:	4c07      	ldr	r4, [pc, #28]	; (1804 <ztest_find_test_suite+0x24>)
    17e6:	4b08      	ldr	r3, [pc, #32]	; (1808 <ztest_find_test_suite+0x28>)
    17e8:	429c      	cmp	r4, r3
    17ea:	d302      	bcc.n	17f2 <ztest_find_test_suite+0x12>
		if (strcmp(name, node->name) == 0) {
			return node;
		}
	}

	return NULL;
    17ec:	2400      	movs	r4, #0
}
    17ee:	0020      	movs	r0, r4
    17f0:	bd70      	pop	{r4, r5, r6, pc}
		if (strcmp(name, node->name) == 0) {
    17f2:	0028      	movs	r0, r5
    17f4:	6821      	ldr	r1, [r4, #0]
    17f6:	f004 f8cb 	bl	5990 <strcmp>
    17fa:	2800      	cmp	r0, #0
    17fc:	d0f7      	beq.n	17ee <ztest_find_test_suite+0xe>
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
    17fe:	341c      	adds	r4, #28
    1800:	e7f1      	b.n	17e6 <ztest_find_test_suite+0x6>
    1802:	46c0      	nop			; (mov r8, r8)
    1804:	00005e78 	.word	0x00005e78
    1808:	00005e94 	.word	0x00005e94

0000180c <test_cb>:
{
    180c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	test_result = ZTEST_RESULT_PENDING;
    180e:	4b11      	ldr	r3, [pc, #68]	; (1854 <test_cb+0x48>)
{
    1810:	0007      	movs	r7, r0
	test_result = ZTEST_RESULT_PENDING;
    1812:	9301      	str	r3, [sp, #4]
    1814:	2300      	movs	r3, #0
{
    1816:	000d      	movs	r5, r1
    1818:	0014      	movs	r4, r2
	test_result = ZTEST_RESULT_PENDING;
    181a:	9a01      	ldr	r2, [sp, #4]
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
    181c:	4e0e      	ldr	r6, [pc, #56]	; (1858 <test_cb+0x4c>)
	test_result = ZTEST_RESULT_PENDING;
    181e:	7013      	strb	r3, [r2, #0]
	     rule < _ztest_test_rule_list_end; ++rule) {
    1820:	4b0e      	ldr	r3, [pc, #56]	; (185c <test_cb+0x50>)
    1822:	429e      	cmp	r6, r3
    1824:	d30e      	bcc.n	1844 <test_cb+0x38>
	if (suite->before) {
    1826:	68bb      	ldr	r3, [r7, #8]
    1828:	2b00      	cmp	r3, #0
    182a:	d001      	beq.n	1830 <test_cb+0x24>
		suite->before(/*data=*/c);
    182c:	0020      	movs	r0, r4
    182e:	4798      	blx	r3
	phase = TEST_PHASE_TEST;
    1830:	2102      	movs	r1, #2
    1832:	4b0b      	ldr	r3, [pc, #44]	; (1860 <test_cb+0x54>)
    1834:	68aa      	ldr	r2, [r5, #8]
	test->test(data);
    1836:	0020      	movs	r0, r4
	phase = TEST_PHASE_TEST;
    1838:	7019      	strb	r1, [r3, #0]
	test->test(data);
    183a:	4790      	blx	r2
	test_result = ZTEST_RESULT_PASS;
    183c:	2301      	movs	r3, #1
    183e:	9a01      	ldr	r2, [sp, #4]
    1840:	7013      	strb	r3, [r2, #0]
}
    1842:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
		if (is_before && rule->before_each) {
    1844:	6833      	ldr	r3, [r6, #0]
    1846:	2b00      	cmp	r3, #0
    1848:	d002      	beq.n	1850 <test_cb+0x44>
			rule->before_each(test, data);
    184a:	0021      	movs	r1, r4
    184c:	0028      	movs	r0, r5
    184e:	4798      	blx	r3
	     rule < _ztest_test_rule_list_end; ++rule) {
    1850:	3608      	adds	r6, #8
    1852:	e7e5      	b.n	1820 <test_cb+0x14>
    1854:	20000375 	.word	0x20000375
    1858:	00005ea8 	.word	0x00005ea8
    185c:	00005ea8 	.word	0x00005ea8
    1860:	20000084 	.word	0x20000084

00001864 <test_finalize>:
{
    1864:	b510      	push	{r4, lr}
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
    1866:	4804      	ldr	r0, [pc, #16]	; (1878 <test_finalize+0x14>)
    1868:	f7ff ff8c 	bl	1784 <z_impl_k_thread_abort>
	return z_impl_z_current_get();
    186c:	f003 fa82 	bl	4d74 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
    1870:	f7ff ff88 	bl	1784 <z_impl_k_thread_abort>
}
    1874:	bd10      	pop	{r4, pc}
    1876:	46c0      	nop			; (mov r8, r8)
    1878:	20000090 	.word	0x20000090

0000187c <ztest_test_fail>:
{
    187c:	b510      	push	{r4, lr}
	switch (phase) {
    187e:	4b0e      	ldr	r3, [pc, #56]	; (18b8 <ztest_test_fail+0x3c>)
    1880:	781b      	ldrb	r3, [r3, #0]
    1882:	2b00      	cmp	r3, #0
    1884:	d00e      	beq.n	18a4 <ztest_test_fail+0x28>
    1886:	1e5a      	subs	r2, r3, #1
    1888:	2a01      	cmp	r2, #1
    188a:	d90f      	bls.n	18ac <ztest_test_fail+0x30>
    188c:	490b      	ldr	r1, [pc, #44]	; (18bc <ztest_test_fail+0x40>)
    188e:	2b05      	cmp	r3, #5
    1890:	d802      	bhi.n	1898 <ztest_test_fail+0x1c>
    1892:	4a0b      	ldr	r2, [pc, #44]	; (18c0 <ztest_test_fail+0x44>)
    1894:	009b      	lsls	r3, r3, #2
    1896:	5899      	ldr	r1, [r3, r2]
		PRINT(" ERROR: cannot fail in test phase '%s()', bailing\n",
    1898:	480a      	ldr	r0, [pc, #40]	; (18c4 <ztest_test_fail+0x48>)
    189a:	f003 ff92 	bl	57c2 <printk>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
    189e:	2202      	movs	r2, #2
    18a0:	4b09      	ldr	r3, [pc, #36]	; (18c8 <ztest_test_fail+0x4c>)
    18a2:	e001      	b.n	18a8 <ztest_test_fail+0x2c>
		test_result = ZTEST_RESULT_SUITE_FAIL;
    18a4:	2205      	movs	r2, #5
    18a6:	4b09      	ldr	r3, [pc, #36]	; (18cc <ztest_test_fail+0x50>)
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
    18a8:	701a      	strb	r2, [r3, #0]
}
    18aa:	e004      	b.n	18b6 <ztest_test_fail+0x3a>
		test_result = ZTEST_RESULT_FAIL;
    18ac:	2202      	movs	r2, #2
    18ae:	4b07      	ldr	r3, [pc, #28]	; (18cc <ztest_test_fail+0x50>)
    18b0:	701a      	strb	r2, [r3, #0]
		test_finalize();
    18b2:	f7ff ffd7 	bl	1864 <test_finalize>
}
    18b6:	bd10      	pop	{r4, pc}
    18b8:	20000084 	.word	0x20000084
    18bc:	0000662d 	.word	0x0000662d
    18c0:	00005ee8 	.word	0x00005ee8
    18c4:	00006637 	.word	0x00006637
    18c8:	20000376 	.word	0x20000376
    18cc:	20000375 	.word	0x20000375

000018d0 <z_ztest_get_next_test>:

struct ztest_unit_test *z_ztest_get_next_test(const char *suite, struct ztest_unit_test *prev)
{
    18d0:	b570      	push	{r4, r5, r6, lr}
    18d2:	0005      	movs	r5, r0
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
    18d4:	4c09      	ldr	r4, [pc, #36]	; (18fc <z_ztest_get_next_test+0x2c>)
    18d6:	2900      	cmp	r1, #0
    18d8:	d001      	beq.n	18de <z_ztest_get_next_test+0xe>
    18da:	3114      	adds	r1, #20
    18dc:	000c      	movs	r4, r1

	for (; test < _ztest_unit_test_list_end; ++test) {
    18de:	4b08      	ldr	r3, [pc, #32]	; (1900 <z_ztest_get_next_test+0x30>)
    18e0:	429c      	cmp	r4, r3
    18e2:	d302      	bcc.n	18ea <z_ztest_get_next_test+0x1a>
		if (strcmp(suite, test->test_suite_name) == 0) {
			return test;
		}
	}
	return NULL;
    18e4:	2400      	movs	r4, #0
}
    18e6:	0020      	movs	r0, r4
    18e8:	bd70      	pop	{r4, r5, r6, pc}
		if (strcmp(suite, test->test_suite_name) == 0) {
    18ea:	0028      	movs	r0, r5
    18ec:	6821      	ldr	r1, [r4, #0]
    18ee:	f004 f84f 	bl	5990 <strcmp>
    18f2:	2800      	cmp	r0, #0
    18f4:	d0f7      	beq.n	18e6 <z_ztest_get_next_test+0x16>
	for (; test < _ztest_unit_test_list_end; ++test) {
    18f6:	3414      	adds	r4, #20
    18f8:	e7f1      	b.n	18de <z_ztest_get_next_test+0xe>
    18fa:	46c0      	nop			; (mov r8, r8)
    18fc:	00005e94 	.word	0x00005e94
    1900:	00005ea8 	.word	0x00005ea8

00001904 <z_ztest_run_test_suite_ptr>:
	}
}
#endif /* CONFIG_ZTEST_SHUFFLE */

static int z_ztest_run_test_suite_ptr(struct ztest_suite_node *suite)
{
    1904:	b5f0      	push	{r4, r5, r6, r7, lr}
    1906:	0006      	movs	r6, r0
    1908:	b08f      	sub	sp, #60	; 0x3c

	if (test_status < 0) {
		return test_status;
	}

	if (suite == NULL) {
    190a:	2800      	cmp	r0, #0
    190c:	d108      	bne.n	1920 <z_ztest_run_test_suite_ptr+0x1c>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
    190e:	2202      	movs	r2, #2
    1910:	4b9a      	ldr	r3, [pc, #616]	; (1b7c <z_ztest_run_test_suite_ptr+0x278>)
    1912:	701a      	strb	r2, [r3, #0]
		return -1;
    1914:	2301      	movs	r3, #1
    1916:	425b      	negs	r3, r3
    1918:	9309      	str	r3, [sp, #36]	; 0x24
	if (suite->teardown != NULL) {
		suite->teardown(data);
	}

	return fail;
}
    191a:	9809      	ldr	r0, [sp, #36]	; 0x24
    191c:	b00f      	add	sp, #60	; 0x3c
    191e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	TC_SUITE_START(suite->name);
    1920:	4897      	ldr	r0, [pc, #604]	; (1b80 <z_ztest_run_test_suite_ptr+0x27c>)
    1922:	6831      	ldr	r1, [r6, #0]
    1924:	f003 ff4d 	bl	57c2 <printk>
    1928:	4896      	ldr	r0, [pc, #600]	; (1b84 <z_ztest_run_test_suite_ptr+0x280>)
    192a:	f003 ff4a 	bl	57c2 <printk>
	current_test_failed_assumption = false;
    192e:	2300      	movs	r3, #0
    1930:	4a95      	ldr	r2, [pc, #596]	; (1b88 <z_ztest_run_test_suite_ptr+0x284>)
    1932:	7013      	strb	r3, [r2, #0]
	test_result = ZTEST_RESULT_PENDING;
    1934:	4a95      	ldr	r2, [pc, #596]	; (1b8c <z_ztest_run_test_suite_ptr+0x288>)
    1936:	7013      	strb	r3, [r2, #0]
	phase = TEST_PHASE_SETUP;
    1938:	4a95      	ldr	r2, [pc, #596]	; (1b90 <z_ztest_run_test_suite_ptr+0x28c>)
    193a:	7013      	strb	r3, [r2, #0]
	if (test_result != ZTEST_RESULT_SUITE_FAIL && suite->setup != NULL) {
    193c:	6873      	ldr	r3, [r6, #4]
	void *data = NULL;
    193e:	930c      	str	r3, [sp, #48]	; 0x30
	if (test_result != ZTEST_RESULT_SUITE_FAIL && suite->setup != NULL) {
    1940:	2b00      	cmp	r3, #0
    1942:	d001      	beq.n	1948 <z_ztest_run_test_suite_ptr+0x44>
		data = suite->setup();
    1944:	4798      	blx	r3
    1946:	900c      	str	r0, [sp, #48]	; 0x30
		fail = 0;
    1948:	2300      	movs	r3, #0
	struct ztest_unit_test *test = NULL;
    194a:	001f      	movs	r7, r3
		fail = 0;
    194c:	9309      	str	r3, [sp, #36]	; 0x24
		while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
    194e:	0039      	movs	r1, r7
    1950:	6830      	ldr	r0, [r6, #0]
    1952:	f7ff ffbd 	bl	18d0 <z_ztest_get_next_test>
    1956:	1e07      	subs	r7, r0, #0
    1958:	d10f      	bne.n	197a <z_ztest_run_test_suite_ptr+0x76>
		if (test_status == ZTEST_STATUS_OK && fail != 0) {
    195a:	4b88      	ldr	r3, [pc, #544]	; (1b7c <z_ztest_run_test_suite_ptr+0x278>)
    195c:	781a      	ldrb	r2, [r3, #0]
    195e:	2a00      	cmp	r2, #0
    1960:	d000      	beq.n	1964 <z_ztest_run_test_suite_ptr+0x60>
    1962:	e0ef      	b.n	1b44 <z_ztest_run_test_suite_ptr+0x240>
    1964:	9a09      	ldr	r2, [sp, #36]	; 0x24
    1966:	2a00      	cmp	r2, #0
    1968:	d100      	bne.n	196c <z_ztest_run_test_suite_ptr+0x68>
    196a:	e0ef      	b.n	1b4c <z_ztest_run_test_suite_ptr+0x248>
			test_status = ZTEST_STATUS_HAS_FAILURE;
    196c:	2201      	movs	r2, #1
    196e:	701a      	strb	r2, [r3, #0]
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
    1970:	4888      	ldr	r0, [pc, #544]	; (1b94 <z_ztest_run_test_suite_ptr+0x290>)
    1972:	6831      	ldr	r1, [r6, #0]
    1974:	f003 ff25 	bl	57c2 <printk>
    1978:	e0ee      	b.n	1b58 <z_ztest_run_test_suite_ptr+0x254>
			if (ztest_api.should_test_run(suite->name, test->name)) {
    197a:	4b87      	ldr	r3, [pc, #540]	; (1b98 <z_ztest_run_test_suite_ptr+0x294>)
    197c:	6879      	ldr	r1, [r7, #4]
    197e:	689b      	ldr	r3, [r3, #8]
    1980:	6830      	ldr	r0, [r6, #0]
    1982:	4798      	blx	r3
    1984:	2800      	cmp	r0, #0
    1986:	d100      	bne.n	198a <z_ztest_run_test_suite_ptr+0x86>
    1988:	e0d7      	b.n	1b3a <z_ztest_run_test_suite_ptr+0x236>
				test->stats->run_count++;
    198a:	693a      	ldr	r2, [r7, #16]
	TC_START(test->name);
    198c:	4883      	ldr	r0, [pc, #524]	; (1b9c <z_ztest_run_test_suite_ptr+0x298>)
				test->stats->run_count++;
    198e:	6813      	ldr	r3, [r2, #0]
    1990:	3301      	adds	r3, #1
    1992:	6013      	str	r3, [r2, #0]
	TC_START(test->name);
    1994:	6879      	ldr	r1, [r7, #4]
    1996:	f003 ff14 	bl	57c2 <printk>
	phase = TEST_PHASE_BEFORE;
    199a:	2301      	movs	r3, #1
    199c:	4c7c      	ldr	r4, [pc, #496]	; (1b90 <z_ztest_run_test_suite_ptr+0x28c>)
    199e:	7023      	strb	r3, [r4, #0]
    19a0:	f7ff fae0 	bl	f64 <sys_clock_cycle_get_32>
				test->thread_options | K_INHERIT_PERMS, K_FOREVER);
    19a4:	2208      	movs	r2, #8
static uint32_t tc_start_time;
static uint32_t tc_spend_time;

static inline void get_start_time_cyc(void)
{
	tc_start_time = k_cycle_get_32();
    19a6:	4b7e      	ldr	r3, [pc, #504]	; (1ba0 <z_ztest_run_test_suite_ptr+0x29c>)
    19a8:	6018      	str	r0, [r3, #0]
    19aa:	68fb      	ldr	r3, [r7, #12]
    19ac:	431a      	orrs	r2, r3
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    19ae:	9204      	str	r2, [sp, #16]
    19b0:	2201      	movs	r2, #1
    19b2:	4252      	negs	r2, r2
    19b4:	497b      	ldr	r1, [pc, #492]	; (1ba4 <z_ztest_run_test_suite_ptr+0x2a0>)
    19b6:	9203      	str	r2, [sp, #12]
    19b8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    19ba:	910d      	str	r1, [sp, #52]	; 0x34
    19bc:	9202      	str	r2, [sp, #8]
    19be:	2001      	movs	r0, #1
    19c0:	4240      	negs	r0, r0
    19c2:	17c1      	asrs	r1, r0, #31
    19c4:	2280      	movs	r2, #128	; 0x80
    19c6:	4d78      	ldr	r5, [pc, #480]	; (1ba8 <z_ztest_run_test_suite_ptr+0x2a4>)
    19c8:	9006      	str	r0, [sp, #24]
    19ca:	9107      	str	r1, [sp, #28]
    19cc:	4b77      	ldr	r3, [pc, #476]	; (1bac <z_ztest_run_test_suite_ptr+0x2a8>)
    19ce:	0028      	movs	r0, r5
    19d0:	990d      	ldr	r1, [sp, #52]	; 0x34
    19d2:	9701      	str	r7, [sp, #4]
    19d4:	9600      	str	r6, [sp, #0]
    19d6:	00d2      	lsls	r2, r2, #3
    19d8:	f002 f896 	bl	3b08 <z_impl_k_thread_create>
		if (test->name != NULL) {
    19dc:	6879      	ldr	r1, [r7, #4]
    19de:	2900      	cmp	r1, #0
    19e0:	d002      	beq.n	19e8 <z_ztest_run_test_suite_ptr+0xe4>
		union { uintptr_t x; const char * val; } parm1 = { .val = str };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread, str);
    19e2:	0028      	movs	r0, r5
    19e4:	f002 f81c 	bl	3a20 <z_impl_k_thread_name_set>
		if (test_result != ZTEST_RESULT_SUITE_SKIP &&
    19e8:	4b68      	ldr	r3, [pc, #416]	; (1b8c <z_ztest_run_test_suite_ptr+0x288>)
    19ea:	781b      	ldrb	r3, [r3, #0]
    19ec:	3b04      	subs	r3, #4
    19ee:	2b01      	cmp	r3, #1
    19f0:	d909      	bls.n	1a06 <z_ztest_run_test_suite_ptr+0x102>
	z_impl_k_thread_start(thread);
    19f2:	4d6d      	ldr	r5, [pc, #436]	; (1ba8 <z_ztest_run_test_suite_ptr+0x2a4>)
    19f4:	0028      	movs	r0, r5
    19f6:	f004 f95e 	bl	5cb6 <z_impl_k_thread_start>
	return z_impl_k_thread_join(thread, timeout);
    19fa:	2201      	movs	r2, #1
    19fc:	4252      	negs	r2, r2
    19fe:	17d3      	asrs	r3, r2, #31
    1a00:	0028      	movs	r0, r5
    1a02:	f003 fa8f 	bl	4f24 <z_impl_k_thread_join>
	phase = TEST_PHASE_AFTER;
    1a06:	2303      	movs	r3, #3
    1a08:	7023      	strb	r3, [r4, #0]
	if (suite->after != NULL) {
    1a0a:	68f3      	ldr	r3, [r6, #12]
    1a0c:	2b00      	cmp	r3, #0
    1a0e:	d001      	beq.n	1a14 <z_ztest_run_test_suite_ptr+0x110>
		suite->after(data);
    1a10:	980c      	ldr	r0, [sp, #48]	; 0x30
    1a12:	4798      	blx	r3
	void *data = NULL;
    1a14:	4c66      	ldr	r4, [pc, #408]	; (1bb0 <z_ztest_run_test_suite_ptr+0x2ac>)
    1a16:	e006      	b.n	1a26 <z_ztest_run_test_suite_ptr+0x122>
		} else if (!is_before && rule->after_each) {
    1a18:	6863      	ldr	r3, [r4, #4]
    1a1a:	2b00      	cmp	r3, #0
    1a1c:	d002      	beq.n	1a24 <z_ztest_run_test_suite_ptr+0x120>
			rule->after_each(test, data);
    1a1e:	0038      	movs	r0, r7
    1a20:	990c      	ldr	r1, [sp, #48]	; 0x30
    1a22:	4798      	blx	r3
	     rule < _ztest_test_rule_list_end; ++rule) {
    1a24:	3408      	adds	r4, #8
    1a26:	4b63      	ldr	r3, [pc, #396]	; (1bb4 <z_ztest_run_test_suite_ptr+0x2b0>)
    1a28:	429c      	cmp	r4, r3
    1a2a:	d3f5      	bcc.n	1a18 <z_ztest_run_test_suite_ptr+0x114>
    1a2c:	f7ff fa9a 	bl	f64 <sys_clock_cycle_get_32>
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_cyc_to_ms_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_cyc, Z_HZ_ms, Z_CCYC, true, true, false);
    1a30:	2200      	movs	r2, #0
		t += off;
    1a32:	2100      	movs	r1, #0
}

static inline void get_test_duration_ms(void)
{
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
    1a34:	4b5a      	ldr	r3, [pc, #360]	; (1ba0 <z_ztest_run_test_suite_ptr+0x29c>)
	return z_tmcvt(t, Z_HZ_cyc, Z_HZ_ms, Z_CCYC, true, true, false);
    1a36:	920b      	str	r2, [sp, #44]	; 0x2c
    1a38:	681b      	ldr	r3, [r3, #0]
    1a3a:	1ac3      	subs	r3, r0, r3
		t += off;
    1a3c:	485e      	ldr	r0, [pc, #376]	; (1bb8 <z_ztest_run_test_suite_ptr+0x2b4>)
	return z_tmcvt(t, Z_HZ_cyc, Z_HZ_ms, Z_CCYC, true, true, false);
    1a3e:	930a      	str	r3, [sp, #40]	; 0x28
		t += off;
    1a40:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    1a42:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    1a44:	1900      	adds	r0, r0, r4
    1a46:	4169      	adcs	r1, r5
		if (result32 && (t < BIT64(32))) {
    1a48:	4291      	cmp	r1, r2
    1a4a:	d14b      	bne.n	1ae4 <z_ztest_run_test_suite_ptr+0x1e0>
			return ((uint32_t)t) / (from_hz / to_hz);
    1a4c:	21fa      	movs	r1, #250	; 0xfa
    1a4e:	4a5a      	ldr	r2, [pc, #360]	; (1bb8 <z_ztest_run_test_suite_ptr+0x2b4>)
    1a50:	0089      	lsls	r1, r1, #2
    1a52:	1898      	adds	r0, r3, r2
    1a54:	f7fe fb3c 	bl	d0 <__udivsi3>

	tc_spend_time = k_cyc_to_ms_ceil32(spend_cycle);
    1a58:	4b58      	ldr	r3, [pc, #352]	; (1bbc <z_ztest_run_test_suite_ptr+0x2b8>)
    1a5a:	6018      	str	r0, [r3, #0]
	if (tc_spend_time > test->stats->duration_worst_ms) {
    1a5c:	693b      	ldr	r3, [r7, #16]
    1a5e:	691a      	ldr	r2, [r3, #16]
    1a60:	4282      	cmp	r2, r0
    1a62:	d200      	bcs.n	1a66 <z_ztest_run_test_suite_ptr+0x162>
		test->stats->duration_worst_ms = tc_spend_time;
    1a64:	6118      	str	r0, [r3, #16]
	phase = TEST_PHASE_FRAMEWORK;
    1a66:	2205      	movs	r2, #5
    1a68:	4b49      	ldr	r3, [pc, #292]	; (1b90 <z_ztest_run_test_suite_ptr+0x28c>)
    1a6a:	4955      	ldr	r1, [pc, #340]	; (1bc0 <z_ztest_run_test_suite_ptr+0x2bc>)
    1a6c:	701a      	strb	r2, [r3, #0]
	if (test_result == ZTEST_RESULT_FAIL || test_result == ZTEST_RESULT_SUITE_FAIL ||
    1a6e:	4b47      	ldr	r3, [pc, #284]	; (1b8c <z_ztest_run_test_suite_ptr+0x288>)
    1a70:	781b      	ldrb	r3, [r3, #0]
    1a72:	2b02      	cmp	r3, #2
    1a74:	d004      	beq.n	1a80 <z_ztest_run_test_suite_ptr+0x17c>
    1a76:	4293      	cmp	r3, r2
    1a78:	d002      	beq.n	1a80 <z_ztest_run_test_suite_ptr+0x17c>
    1a7a:	780a      	ldrb	r2, [r1, #0]
    1a7c:	2a00      	cmp	r2, #0
    1a7e:	d037      	beq.n	1af0 <z_ztest_run_test_suite_ptr+0x1ec>
		failed_expectation = false;
    1a80:	2300      	movs	r3, #0
		ret = TC_FAIL;
    1a82:	2501      	movs	r5, #1
		failed_expectation = false;
    1a84:	700b      	strb	r3, [r1, #0]
	z_impl_k_thread_abort(thread);
    1a86:	4848      	ldr	r0, [pc, #288]	; (1ba8 <z_ztest_run_test_suite_ptr+0x2a4>)
    1a88:	f7ff fe7c 	bl	1784 <z_impl_k_thread_abort>
	for (struct ztest_expected_result_entry *expectation =
    1a8c:	4c4d      	ldr	r4, [pc, #308]	; (1bc4 <z_ztest_run_test_suite_ptr+0x2c0>)
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
    1a8e:	4b4e      	ldr	r3, [pc, #312]	; (1bc8 <z_ztest_run_test_suite_ptr+0x2c4>)
		if (strcmp(expectation->test_name, test->name) == 0 &&
    1a90:	6879      	ldr	r1, [r7, #4]
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
    1a92:	429c      	cmp	r4, r3
    1a94:	d333      	bcc.n	1afe <z_ztest_run_test_suite_ptr+0x1fa>
	Z_TC_END_RESULT(ret, test->name);
    1a96:	21fa      	movs	r1, #250	; 0xfa
    1a98:	4b48      	ldr	r3, [pc, #288]	; (1bbc <z_ztest_run_test_suite_ptr+0x2b8>)
    1a9a:	0089      	lsls	r1, r1, #2
    1a9c:	681c      	ldr	r4, [r3, #0]
    1a9e:	0020      	movs	r0, r4
    1aa0:	f7fe fb16 	bl	d0 <__udivsi3>
    1aa4:	21fa      	movs	r1, #250	; 0xfa
    1aa6:	900d      	str	r0, [sp, #52]	; 0x34
    1aa8:	0089      	lsls	r1, r1, #2
    1aaa:	0020      	movs	r0, r4
    1aac:	f7fe fb4c 	bl	148 <__aeabi_uidivmod>
    1ab0:	9100      	str	r1, [sp, #0]
    1ab2:	4946      	ldr	r1, [pc, #280]	; (1bcc <z_ztest_run_test_suite_ptr+0x2c8>)
    1ab4:	00a8      	lsls	r0, r5, #2
    1ab6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    1ab8:	5841      	ldr	r1, [r0, r1]
    1aba:	687a      	ldr	r2, [r7, #4]
    1abc:	4844      	ldr	r0, [pc, #272]	; (1bd0 <z_ztest_run_test_suite_ptr+0x2cc>)
    1abe:	f003 fe80 	bl	57c2 <printk>
    1ac2:	4830      	ldr	r0, [pc, #192]	; (1b84 <z_ztest_run_test_suite_ptr+0x280>)
    1ac4:	f003 fe7d 	bl	57c2 <printk>
	if (ret == TC_SKIP && current_test_failed_assumption) {
    1ac8:	693b      	ldr	r3, [r7, #16]
    1aca:	2d02      	cmp	r5, #2
    1acc:	d130      	bne.n	1b30 <z_ztest_run_test_suite_ptr+0x22c>
    1ace:	4a2e      	ldr	r2, [pc, #184]	; (1b88 <z_ztest_run_test_suite_ptr+0x284>)
    1ad0:	7812      	ldrb	r2, [r2, #0]
    1ad2:	2a00      	cmp	r2, #0
    1ad4:	d002      	beq.n	1adc <z_ztest_run_test_suite_ptr+0x1d8>
		test_status = 1;
    1ad6:	2101      	movs	r1, #1
    1ad8:	4a28      	ldr	r2, [pc, #160]	; (1b7c <z_ztest_run_test_suite_ptr+0x278>)
    1ada:	7011      	strb	r1, [r2, #0]
					test->stats->skip_count++;
    1adc:	685a      	ldr	r2, [r3, #4]
    1ade:	3201      	adds	r2, #1
    1ae0:	605a      	str	r2, [r3, #4]
				if (tc_result == TC_FAIL) {
    1ae2:	e02a      	b.n	1b3a <z_ztest_run_test_suite_ptr+0x236>
			return t / ((uint64_t)from_hz / to_hz);
    1ae4:	22fa      	movs	r2, #250	; 0xfa
    1ae6:	2300      	movs	r3, #0
    1ae8:	0092      	lsls	r2, r2, #2
    1aea:	f7fe fbcb 	bl	284 <__aeabi_uldivmod>
    1aee:	e7b3      	b.n	1a58 <z_ztest_run_test_suite_ptr+0x154>
	} else if (test_result == ZTEST_RESULT_SKIP || test_result == ZTEST_RESULT_SUITE_SKIP) {
    1af0:	2101      	movs	r1, #1
    1af2:	3b03      	subs	r3, #3
    1af4:	b2db      	uxtb	r3, r3
    1af6:	4299      	cmp	r1, r3
    1af8:	4152      	adcs	r2, r2
    1afa:	0055      	lsls	r5, r2, #1
    1afc:	e7c3      	b.n	1a86 <z_ztest_run_test_suite_ptr+0x182>
		if (strcmp(expectation->test_name, test->name) == 0 &&
    1afe:	6860      	ldr	r0, [r4, #4]
    1b00:	f003 ff46 	bl	5990 <strcmp>
    1b04:	2800      	cmp	r0, #0
    1b06:	d10c      	bne.n	1b22 <z_ztest_run_test_suite_ptr+0x21e>
		    strcmp(expectation->test_suite_name, test->test_suite_name) == 0) {
    1b08:	6839      	ldr	r1, [r7, #0]
    1b0a:	6820      	ldr	r0, [r4, #0]
    1b0c:	f003 ff40 	bl	5990 <strcmp>
		if (strcmp(expectation->test_name, test->name) == 0 &&
    1b10:	2800      	cmp	r0, #0
    1b12:	d106      	bne.n	1b22 <z_ztest_run_test_suite_ptr+0x21e>
			expected_result = expectation->expected_result;
    1b14:	7a23      	ldrb	r3, [r4, #8]
	if (expected_result == ZTEST_EXPECTED_RESULT_FAIL) {
    1b16:	2b00      	cmp	r3, #0
    1b18:	d005      	beq.n	1b26 <z_ztest_run_test_suite_ptr+0x222>
	if (expected_result == ZTEST_EXPECTED_RESULT_SKIP) {
    1b1a:	2b01      	cmp	r3, #1
    1b1c:	d1bb      	bne.n	1a96 <z_ztest_run_test_suite_ptr+0x192>
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
    1b1e:	1eab      	subs	r3, r5, #2
    1b20:	e002      	b.n	1b28 <z_ztest_run_test_suite_ptr+0x224>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
    1b22:	340c      	adds	r4, #12
    1b24:	e7b3      	b.n	1a8e <z_ztest_run_test_suite_ptr+0x18a>
		return (ret == TC_FAIL) ? TC_PASS : TC_FAIL;
    1b26:	1e6b      	subs	r3, r5, #1
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
    1b28:	1e5a      	subs	r2, r3, #1
    1b2a:	4193      	sbcs	r3, r2
    1b2c:	b2dd      	uxtb	r5, r3
	switch (result) {
    1b2e:	e7b2      	b.n	1a96 <z_ztest_run_test_suite_ptr+0x192>
				if (tc_result == TC_PASS) {
    1b30:	2d00      	cmp	r5, #0
    1b32:	d11b      	bne.n	1b6c <z_ztest_run_test_suite_ptr+0x268>
					test->stats->pass_count++;
    1b34:	68da      	ldr	r2, [r3, #12]
    1b36:	3201      	adds	r2, #1
    1b38:	60da      	str	r2, [r3, #12]
			if ((fail && FAIL_FAST) || test_status == ZTEST_STATUS_CRITICAL_ERROR) {
    1b3a:	4b10      	ldr	r3, [pc, #64]	; (1b7c <z_ztest_run_test_suite_ptr+0x278>)
    1b3c:	781b      	ldrb	r3, [r3, #0]
    1b3e:	2b02      	cmp	r3, #2
    1b40:	d000      	beq.n	1b44 <z_ztest_run_test_suite_ptr+0x240>
    1b42:	e704      	b.n	194e <z_ztest_run_test_suite_ptr+0x4a>
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
    1b44:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1b46:	2b00      	cmp	r3, #0
    1b48:	d000      	beq.n	1b4c <z_ztest_run_test_suite_ptr+0x248>
    1b4a:	e711      	b.n	1970 <z_ztest_run_test_suite_ptr+0x6c>
    1b4c:	4821      	ldr	r0, [pc, #132]	; (1bd4 <z_ztest_run_test_suite_ptr+0x2d0>)
    1b4e:	6831      	ldr	r1, [r6, #0]
    1b50:	f003 fe37 	bl	57c2 <printk>
    1b54:	2300      	movs	r3, #0
    1b56:	9309      	str	r3, [sp, #36]	; 0x24
	phase = TEST_PHASE_TEARDOWN;
    1b58:	2204      	movs	r2, #4
    1b5a:	4b0d      	ldr	r3, [pc, #52]	; (1b90 <z_ztest_run_test_suite_ptr+0x28c>)
    1b5c:	701a      	strb	r2, [r3, #0]
	if (suite->teardown != NULL) {
    1b5e:	6933      	ldr	r3, [r6, #16]
    1b60:	2b00      	cmp	r3, #0
    1b62:	d100      	bne.n	1b66 <z_ztest_run_test_suite_ptr+0x262>
    1b64:	e6d9      	b.n	191a <z_ztest_run_test_suite_ptr+0x16>
		suite->teardown(data);
    1b66:	980c      	ldr	r0, [sp, #48]	; 0x30
    1b68:	4798      	blx	r3
    1b6a:	e6d6      	b.n	191a <z_ztest_run_test_suite_ptr+0x16>
					test->stats->fail_count++;
    1b6c:	689a      	ldr	r2, [r3, #8]
    1b6e:	3201      	adds	r2, #1
    1b70:	609a      	str	r2, [r3, #8]
					fail++;
    1b72:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1b74:	3301      	adds	r3, #1
    1b76:	9309      	str	r3, [sp, #36]	; 0x24
    1b78:	e7df      	b.n	1b3a <z_ztest_run_test_suite_ptr+0x236>
    1b7a:	46c0      	nop			; (mov r8, r8)
    1b7c:	20000376 	.word	0x20000376
    1b80:	0000666a 	.word	0x0000666a
    1b84:	00006680 	.word	0x00006680
    1b88:	20000374 	.word	0x20000374
    1b8c:	20000375 	.word	0x20000375
    1b90:	20000084 	.word	0x20000084
    1b94:	00006706 	.word	0x00006706
    1b98:	00005f0c 	.word	0x00005f0c
    1b9c:	000066c5 	.word	0x000066c5
    1ba0:	200002b8 	.word	0x200002b8
    1ba4:	20000380 	.word	0x20000380
    1ba8:	20000090 	.word	0x20000090
    1bac:	0000180d 	.word	0x0000180d
    1bb0:	00005ea8 	.word	0x00005ea8
    1bb4:	00005ea8 	.word	0x00005ea8
    1bb8:	000003e7 	.word	0x000003e7
    1bbc:	200002b4 	.word	0x200002b4
    1bc0:	20000377 	.word	0x20000377
    1bc4:	00005e78 	.word	0x00005e78
    1bc8:	00005e78 	.word	0x00005e78
    1bcc:	00005f00 	.word	0x00005f00
    1bd0:	000066d1 	.word	0x000066d1
    1bd4:	000066ee 	.word	0x000066ee

00001bd8 <z_impl_ztest_run_test_suites>:

	return count;
}

int z_impl_ztest_run_test_suites(const void *state)
{
    1bd8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	int count = 0;

	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
    1bda:	4f1d      	ldr	r7, [pc, #116]	; (1c50 <z_impl_ztest_run_test_suites+0x78>)
		return count;
    1bdc:	2600      	movs	r6, #0
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
    1bde:	783b      	ldrb	r3, [r7, #0]
		    (test_status == ZTEST_STATUS_HAS_FAILURE && FAIL_FAST)) {
			break;
		}
	}
#else
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
    1be0:	4c1c      	ldr	r4, [pc, #112]	; (1c54 <z_impl_ztest_run_test_suites+0x7c>)
{
    1be2:	9001      	str	r0, [sp, #4]
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
    1be4:	2b02      	cmp	r3, #2
    1be6:	d122      	bne.n	1c2e <z_impl_ztest_run_test_suites+0x56>
		}
	}
#endif

	return count;
}
    1be8:	0030      	movs	r0, r6
    1bea:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		test->stats->run_count = 0;
    1bec:	2300      	movs	r3, #0
    1bee:	690a      	ldr	r2, [r1, #16]
    1bf0:	6013      	str	r3, [r2, #0]
		test->stats->skip_count = 0;
    1bf2:	690a      	ldr	r2, [r1, #16]
    1bf4:	6053      	str	r3, [r2, #4]
		test->stats->fail_count = 0;
    1bf6:	690a      	ldr	r2, [r1, #16]
    1bf8:	6093      	str	r3, [r2, #8]
		test->stats->pass_count = 0;
    1bfa:	690a      	ldr	r2, [r1, #16]
    1bfc:	60d3      	str	r3, [r2, #12]
		test->stats->duration_worst_ms = 0;
    1bfe:	690a      	ldr	r2, [r1, #16]
    1c00:	6113      	str	r3, [r2, #16]
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
    1c02:	6820      	ldr	r0, [r4, #0]
    1c04:	f7ff fe64 	bl	18d0 <z_ztest_get_next_test>
    1c08:	1e01      	subs	r1, r0, #0
    1c0a:	d1ef      	bne.n	1bec <z_impl_ztest_run_test_suites+0x14>
			int fail = z_ztest_run_test_suite_ptr(ptr);
    1c0c:	0020      	movs	r0, r4
    1c0e:	f7ff fe79 	bl	1904 <z_ztest_run_test_suite_ptr>
			stats->run_count++;
    1c12:	682b      	ldr	r3, [r5, #0]
    1c14:	3301      	adds	r3, #1
    1c16:	602b      	str	r3, [r5, #0]
			stats->fail_count += (fail != 0) ? 1 : 0;
    1c18:	1e43      	subs	r3, r0, #1
    1c1a:	4198      	sbcs	r0, r3
    1c1c:	68ab      	ldr	r3, [r5, #8]
    1c1e:	1818      	adds	r0, r3, r0
    1c20:	60a8      	str	r0, [r5, #8]
			count++;
    1c22:	2001      	movs	r0, #1
		if (test_status == ZTEST_STATUS_CRITICAL_ERROR ||
    1c24:	783b      	ldrb	r3, [r7, #0]
		count += __ztest_run_test_suite(ptr, state);
    1c26:	1836      	adds	r6, r6, r0
		if (test_status == ZTEST_STATUS_CRITICAL_ERROR ||
    1c28:	2b02      	cmp	r3, #2
    1c2a:	d0dd      	beq.n	1be8 <z_impl_ztest_run_test_suites+0x10>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
    1c2c:	341c      	adds	r4, #28
    1c2e:	4b0a      	ldr	r3, [pc, #40]	; (1c58 <z_impl_ztest_run_test_suites+0x80>)
    1c30:	429c      	cmp	r4, r3
    1c32:	d2d9      	bcs.n	1be8 <z_impl_ztest_run_test_suites+0x10>
		if (ztest_api.should_suite_run(state, ptr)) {
    1c34:	4b09      	ldr	r3, [pc, #36]	; (1c5c <z_impl_ztest_run_test_suites+0x84>)
    1c36:	0021      	movs	r1, r4
    1c38:	685b      	ldr	r3, [r3, #4]
    1c3a:	9801      	ldr	r0, [sp, #4]
	struct ztest_suite_stats *stats = ptr->stats;
    1c3c:	69a5      	ldr	r5, [r4, #24]
		if (ztest_api.should_suite_run(state, ptr)) {
    1c3e:	4798      	blx	r3
    1c40:	2800      	cmp	r0, #0
    1c42:	d001      	beq.n	1c48 <z_impl_ztest_run_test_suites+0x70>
	struct ztest_unit_test *test = NULL;
    1c44:	2100      	movs	r1, #0
    1c46:	e7dc      	b.n	1c02 <z_impl_ztest_run_test_suites+0x2a>
			stats->skip_count++;
    1c48:	686b      	ldr	r3, [r5, #4]
    1c4a:	3301      	adds	r3, #1
    1c4c:	606b      	str	r3, [r5, #4]
    1c4e:	e7e9      	b.n	1c24 <z_impl_ztest_run_test_suites+0x4c>
    1c50:	20000376 	.word	0x20000376
    1c54:	00005e78 	.word	0x00005e78
    1c58:	00005e94 	.word	0x00005e94
    1c5c:	00005f0c 	.word	0x00005f0c

00001c60 <ztest_verify_all_test_suites_ran>:

void ztest_verify_all_test_suites_ran(void)
{
    1c60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	bool all_tests_run = true;
    1c62:	2701      	movs	r7, #1
	struct ztest_suite_node *suite;
	struct ztest_unit_test *test;

	if (IS_ENABLED(CONFIG_ZTEST_VERIFY_RUN_ALL)) {
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
    1c64:	4c1d      	ldr	r4, [pc, #116]	; (1cdc <ztest_verify_all_test_suites_ran+0x7c>)
    1c66:	4b1e      	ldr	r3, [pc, #120]	; (1ce0 <ztest_verify_all_test_suites_ran+0x80>)
    1c68:	429c      	cmp	r4, r3
    1c6a:	d30d      	bcc.n	1c88 <ztest_verify_all_test_suites_ran+0x28>
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
				all_tests_run = false;
			}
		}

		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
    1c6c:	4d1d      	ldr	r5, [pc, #116]	; (1ce4 <ztest_verify_all_test_suites_ran+0x84>)
    1c6e:	002c      	movs	r4, r5
    1c70:	4e1d      	ldr	r6, [pc, #116]	; (1ce8 <ztest_verify_all_test_suites_ran+0x88>)
    1c72:	42b5      	cmp	r5, r6
    1c74:	d313      	bcc.n	1c9e <ztest_verify_all_test_suites_ran+0x3e>
				      test->name, test->test_suite_name);
				all_tests_run = false;
			}
		}

		if (!all_tests_run) {
    1c76:	2f00      	cmp	r7, #0
    1c78:	d102      	bne.n	1c80 <ztest_verify_all_test_suites_ran+0x20>
			test_status = ZTEST_STATUS_HAS_FAILURE;
    1c7a:	2201      	movs	r2, #1
    1c7c:	4b1b      	ldr	r3, [pc, #108]	; (1cec <ztest_verify_all_test_suites_ran+0x8c>)
    1c7e:	701a      	strb	r2, [r3, #0]

	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
		    test->stats->run_count) {
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
			test_status = 1;
    1c80:	2501      	movs	r5, #1
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
    1c82:	42b4      	cmp	r4, r6
    1c84:	d318      	bcc.n	1cb8 <ztest_verify_all_test_suites_ran+0x58>
		}
	}
}
    1c86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (suite->stats->run_count < 1) {
    1c88:	69a3      	ldr	r3, [r4, #24]
    1c8a:	681d      	ldr	r5, [r3, #0]
    1c8c:	2d00      	cmp	r5, #0
    1c8e:	d104      	bne.n	1c9a <ztest_verify_all_test_suites_ran+0x3a>
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
    1c90:	4817      	ldr	r0, [pc, #92]	; (1cf0 <ztest_verify_all_test_suites_ran+0x90>)
    1c92:	6821      	ldr	r1, [r4, #0]
    1c94:	f003 fd95 	bl	57c2 <printk>
				all_tests_run = false;
    1c98:	002f      	movs	r7, r5
		     ++suite) {
    1c9a:	341c      	adds	r4, #28
    1c9c:	e7e3      	b.n	1c66 <ztest_verify_all_test_suites_ran+0x6>
			suite = ztest_find_test_suite(test->test_suite_name);
    1c9e:	6828      	ldr	r0, [r5, #0]
    1ca0:	f7ff fd9e 	bl	17e0 <ztest_find_test_suite>
    1ca4:	1e06      	subs	r6, r0, #0
			if (suite == NULL) {
    1ca6:	d105      	bne.n	1cb4 <ztest_verify_all_test_suites_ran+0x54>
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
    1ca8:	4812      	ldr	r0, [pc, #72]	; (1cf4 <ztest_verify_all_test_suites_ran+0x94>)
    1caa:	682a      	ldr	r2, [r5, #0]
    1cac:	6869      	ldr	r1, [r5, #4]
    1cae:	f003 fd88 	bl	57c2 <printk>
				all_tests_run = false;
    1cb2:	0037      	movs	r7, r6
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
    1cb4:	3514      	adds	r5, #20
    1cb6:	e7db      	b.n	1c70 <ztest_verify_all_test_suites_ran+0x10>
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
    1cb8:	6922      	ldr	r2, [r4, #16]
    1cba:	68d1      	ldr	r1, [r2, #12]
    1cbc:	6893      	ldr	r3, [r2, #8]
    1cbe:	185b      	adds	r3, r3, r1
    1cc0:	6851      	ldr	r1, [r2, #4]
    1cc2:	6812      	ldr	r2, [r2, #0]
    1cc4:	185b      	adds	r3, r3, r1
    1cc6:	4293      	cmp	r3, r2
    1cc8:	d006      	beq.n	1cd8 <ztest_verify_all_test_suites_ran+0x78>
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
    1cca:	480b      	ldr	r0, [pc, #44]	; (1cf8 <ztest_verify_all_test_suites_ran+0x98>)
    1ccc:	6862      	ldr	r2, [r4, #4]
    1cce:	6821      	ldr	r1, [r4, #0]
    1cd0:	f003 fd77 	bl	57c2 <printk>
			test_status = 1;
    1cd4:	4b05      	ldr	r3, [pc, #20]	; (1cec <ztest_verify_all_test_suites_ran+0x8c>)
    1cd6:	701d      	strb	r5, [r3, #0]
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
    1cd8:	3414      	adds	r4, #20
    1cda:	e7d2      	b.n	1c82 <ztest_verify_all_test_suites_ran+0x22>
    1cdc:	00005e78 	.word	0x00005e78
    1ce0:	00005e94 	.word	0x00005e94
    1ce4:	00005e94 	.word	0x00005e94
    1ce8:	00005ea8 	.word	0x00005ea8
    1cec:	20000376 	.word	0x20000376
    1cf0:	0000671c 	.word	0x0000671c
    1cf4:	00006741 	.word	0x00006741
    1cf8:	00006783 	.word	0x00006783

00001cfc <ztest_run_all>:

void ztest_run_all(const void *state) { ztest_api.run_all(state); }
    1cfc:	b510      	push	{r4, lr}
    1cfe:	4b02      	ldr	r3, [pc, #8]	; (1d08 <ztest_run_all+0xc>)
    1d00:	681b      	ldr	r3, [r3, #0]
    1d02:	4798      	blx	r3
    1d04:	bd10      	pop	{r4, pc}
    1d06:	46c0      	nop			; (mov r8, r8)
    1d08:	00005f0c 	.word	0x00005f0c

00001d0c <main>:

	return test_status;
}
#else
int main(void)
{
    1d0c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d0e:	b091      	sub	sp, #68	; 0x44
	k_mem_domain_add_partition(&k_mem_domain_default, &z_malloc_partition);
#endif
#endif /* CONFIG_USERSPACE */

	z_init_mock();
	test_main();
    1d10:	f003 fe83 	bl	5a1a <test_main>
	TC_SUMMARY_PRINT("\n------ TESTSUITE SUMMARY START ------\n\n");
    1d14:	4863      	ldr	r0, [pc, #396]	; (1ea4 <main+0x198>)
    1d16:	f003 fd54 	bl	57c2 <printk>
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
    1d1a:	4b63      	ldr	r3, [pc, #396]	; (1ea8 <main+0x19c>)
	     ptr < _ztest_suite_node_list_end; ++ptr) {
    1d1c:	9308      	str	r3, [sp, #32]
    1d1e:	9a08      	ldr	r2, [sp, #32]
    1d20:	4b62      	ldr	r3, [pc, #392]	; (1eac <main+0x1a0>)
    1d22:	429a      	cmp	r2, r3
    1d24:	d200      	bcs.n	1d28 <main+0x1c>
    1d26:	e08d      	b.n	1e44 <main+0x138>
	TC_SUMMARY_PRINT("------ TESTSUITE SUMMARY END ------\n\n");
    1d28:	4861      	ldr	r0, [pc, #388]	; (1eb0 <main+0x1a4>)
    1d2a:	f003 fd4a 	bl	57c2 <printk>
	if (test_status) {
    1d2e:	4b61      	ldr	r3, [pc, #388]	; (1eb4 <main+0x1a8>)
    1d30:	4861      	ldr	r0, [pc, #388]	; (1eb8 <main+0x1ac>)
    1d32:	781b      	ldrb	r3, [r3, #0]
    1d34:	4d61      	ldr	r5, [pc, #388]	; (1ebc <main+0x1b0>)
    1d36:	4c62      	ldr	r4, [pc, #392]	; (1ec0 <main+0x1b4>)
    1d38:	2b00      	cmp	r3, #0
    1d3a:	d100      	bne.n	1d3e <main+0x32>
    1d3c:	e0aa      	b.n	1e94 <main+0x188>
		TC_END_REPORT(TC_FAIL);
    1d3e:	f003 fd40 	bl	57c2 <printk>
    1d42:	0028      	movs	r0, r5
    1d44:	f003 fd3d 	bl	57c2 <printk>
    1d48:	495e      	ldr	r1, [pc, #376]	; (1ec4 <main+0x1b8>)
		TC_END_REPORT(TC_PASS);
    1d4a:	0020      	movs	r0, r4
    1d4c:	f003 fd39 	bl	57c2 <printk>
			PRINT("Failed after %u attempts\n", state.boots);
			state.boots = 0;
		}
	}
	return 0;
}
    1d50:	2000      	movs	r0, #0
    1d52:	b011      	add	sp, #68	; 0x44
    1d54:	bdf0      	pop	{r4, r5, r6, r7, pc}
		distinct_total++;
    1d56:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1d58:	3301      	adds	r3, #1
    1d5a:	9309      	str	r3, [sp, #36]	; 0x24
		suite_duration_worst_ms += test->stats->duration_worst_ms;
    1d5c:	6923      	ldr	r3, [r4, #16]
    1d5e:	691a      	ldr	r2, [r3, #16]
		if (test->stats->skip_count == test->stats->run_count) {
    1d60:	6859      	ldr	r1, [r3, #4]
		suite_duration_worst_ms += test->stats->duration_worst_ms;
    1d62:	18ad      	adds	r5, r5, r2
		if (test->stats->skip_count == test->stats->run_count) {
    1d64:	681a      	ldr	r2, [r3, #0]
    1d66:	4291      	cmp	r1, r2
    1d68:	d161      	bne.n	1e2e <main+0x122>
			distinct_skip++;
    1d6a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1d6c:	3301      	adds	r3, #1
    1d6e:	930a      	str	r3, [sp, #40]	; 0x28
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
    1d70:	9b08      	ldr	r3, [sp, #32]
    1d72:	0021      	movs	r1, r4
    1d74:	6818      	ldr	r0, [r3, #0]
    1d76:	f7ff fdab 	bl	18d0 <z_ztest_get_next_test>
    1d7a:	1e04      	subs	r4, r0, #0
    1d7c:	d1eb      	bne.n	1d56 <main+0x4a>
	if (distinct_skip == distinct_total) {
    1d7e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    1d80:	990a      	ldr	r1, [sp, #40]	; 0x28
    1d82:	2302      	movs	r3, #2
		passrate_major = passrate_minor = 0;
    1d84:	0006      	movs	r6, r0
    1d86:	900d      	str	r0, [sp, #52]	; 0x34
	if (distinct_skip == distinct_total) {
    1d88:	428a      	cmp	r2, r1
    1d8a:	d01f      	beq.n	1dcc <main+0xc0>
		expanded_pass = distinct_pass * 100000;
    1d8c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1d8e:	484e      	ldr	r0, [pc, #312]	; (1ec8 <main+0x1bc>)
		effective_total = distinct_total - distinct_skip;
    1d90:	1a51      	subs	r1, r2, r1
		expanded_pass = distinct_pass * 100000;
    1d92:	4358      	muls	r0, r3
		expanded_passrate = expanded_pass / effective_total;
    1d94:	f7fe f9e2 	bl	15c <__divsi3>
		passrate_major = expanded_passrate / 1000;
    1d98:	21fa      	movs	r1, #250	; 0xfa
    1d9a:	0089      	lsls	r1, r1, #2
		expanded_passrate = expanded_pass / effective_total;
    1d9c:	0006      	movs	r6, r0
		passrate_major = expanded_passrate / 1000;
    1d9e:	f7fe f9dd 	bl	15c <__divsi3>
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
    1da2:	4f4a      	ldr	r7, [pc, #296]	; (1ecc <main+0x1c0>)
		passrate_major = expanded_passrate / 1000;
    1da4:	900d      	str	r0, [sp, #52]	; 0x34
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
    1da6:	4347      	muls	r7, r0
    1da8:	19bf      	adds	r7, r7, r6
    1daa:	210a      	movs	r1, #10
    1dac:	0038      	movs	r0, r7
    1dae:	f7fe f9d5 	bl	15c <__divsi3>
		suite_result = (distinct_fail > 0) ? TC_FAIL : TC_PASS;
    1db2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1db4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    1db6:	17db      	asrs	r3, r3, #31
    1db8:	1a9b      	subs	r3, r3, r2
		passrate_tail = expanded_passrate - passrate_major * 1000 - passrate_minor * 10;
    1dba:	220a      	movs	r2, #10
    1dbc:	4252      	negs	r2, r2
    1dbe:	4342      	muls	r2, r0
    1dc0:	19d2      	adds	r2, r2, r7
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
    1dc2:	0006      	movs	r6, r0
		suite_result = (distinct_fail > 0) ? TC_FAIL : TC_PASS;
    1dc4:	0fdb      	lsrs	r3, r3, #31
		if (passrate_tail >= 5) { /* rounding */
    1dc6:	2a04      	cmp	r2, #4
    1dc8:	dd00      	ble.n	1dcc <main+0xc0>
			passrate_minor++;
    1dca:	3601      	adds	r6, #1
	TC_SUMMARY_PRINT("SUITE %s - %3d.%02d%% [%s]: pass = %d, fail = %d, "
    1dcc:	21fa      	movs	r1, #250	; 0xfa
    1dce:	4a40      	ldr	r2, [pc, #256]	; (1ed0 <main+0x1c4>)
    1dd0:	009b      	lsls	r3, r3, #2
    1dd2:	0028      	movs	r0, r5
    1dd4:	0089      	lsls	r1, r1, #2
    1dd6:	920e      	str	r2, [sp, #56]	; 0x38
    1dd8:	930f      	str	r3, [sp, #60]	; 0x3c
    1dda:	f7fe f9b5 	bl	148 <__aeabi_uidivmod>
    1dde:	9106      	str	r1, [sp, #24]
    1de0:	21fa      	movs	r1, #250	; 0xfa
    1de2:	0028      	movs	r0, r5
    1de4:	0089      	lsls	r1, r1, #2
    1de6:	f7fe f973 	bl	d0 <__udivsi3>
    1dea:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1dec:	9005      	str	r0, [sp, #20]
    1dee:	9304      	str	r3, [sp, #16]
    1df0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1df2:	980f      	ldr	r0, [sp, #60]	; 0x3c
    1df4:	9303      	str	r3, [sp, #12]
    1df6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1df8:	4f36      	ldr	r7, [pc, #216]	; (1ed4 <main+0x1c8>)
    1dfa:	9302      	str	r3, [sp, #8]
    1dfc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1dfe:	990e      	ldr	r1, [sp, #56]	; 0x38
    1e00:	9301      	str	r3, [sp, #4]
    1e02:	9b08      	ldr	r3, [sp, #32]
    1e04:	5841      	ldr	r1, [r0, r1]
    1e06:	681b      	ldr	r3, [r3, #0]
    1e08:	0038      	movs	r0, r7
    1e0a:	9300      	str	r3, [sp, #0]
    1e0c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    1e0e:	0033      	movs	r3, r6
    1e10:	f003 fcd7 	bl	57c2 <printk>
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
    1e14:	9b08      	ldr	r3, [sp, #32]
    1e16:	0021      	movs	r1, r4
    1e18:	6818      	ldr	r0, [r3, #0]
    1e1a:	f7ff fd59 	bl	18d0 <z_ztest_get_next_test>
    1e1e:	1e04      	subs	r4, r0, #0
    1e20:	d117      	bne.n	1e52 <main+0x146>
	TC_SUMMARY_PRINT("\n");
    1e22:	482d      	ldr	r0, [pc, #180]	; (1ed8 <main+0x1cc>)
    1e24:	f003 fccd 	bl	57c2 <printk>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
    1e28:	9b08      	ldr	r3, [sp, #32]
    1e2a:	331c      	adds	r3, #28
    1e2c:	e776      	b.n	1d1c <main+0x10>
		} else if (test->stats->pass_count == test->stats->run_count) {
    1e2e:	68db      	ldr	r3, [r3, #12]
    1e30:	429a      	cmp	r2, r3
    1e32:	d103      	bne.n	1e3c <main+0x130>
			distinct_pass++;
    1e34:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1e36:	3301      	adds	r3, #1
    1e38:	930c      	str	r3, [sp, #48]	; 0x30
    1e3a:	e799      	b.n	1d70 <main+0x64>
			distinct_fail++;
    1e3c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1e3e:	3301      	adds	r3, #1
    1e40:	930b      	str	r3, [sp, #44]	; 0x2c
    1e42:	e795      	b.n	1d70 <main+0x64>
	unsigned int suite_duration_worst_ms = 0;
    1e44:	2500      	movs	r5, #0
	struct ztest_unit_test *test = NULL;
    1e46:	002c      	movs	r4, r5
	int distinct_pass = 0, distinct_fail = 0, distinct_skip = 0, distinct_total = 0;
    1e48:	9509      	str	r5, [sp, #36]	; 0x24
    1e4a:	950a      	str	r5, [sp, #40]	; 0x28
    1e4c:	950b      	str	r5, [sp, #44]	; 0x2c
    1e4e:	950c      	str	r5, [sp, #48]	; 0x30
    1e50:	e78e      	b.n	1d70 <main+0x64>
		if (test->stats->skip_count == test->stats->run_count) {
    1e52:	6923      	ldr	r3, [r4, #16]
    1e54:	2502      	movs	r5, #2
    1e56:	681a      	ldr	r2, [r3, #0]
    1e58:	6859      	ldr	r1, [r3, #4]
    1e5a:	4291      	cmp	r1, r2
    1e5c:	d003      	beq.n	1e66 <main+0x15a>
		} else if (test->stats->pass_count == test->stats->run_count) {
    1e5e:	68dd      	ldr	r5, [r3, #12]
    1e60:	1aad      	subs	r5, r5, r2
    1e62:	1e6a      	subs	r2, r5, #1
    1e64:	4195      	sbcs	r5, r2
		TC_SUMMARY_PRINT(" - %s - [%s.%s] duration = %u.%03u seconds\n",
    1e66:	21fa      	movs	r1, #250	; 0xfa
    1e68:	691f      	ldr	r7, [r3, #16]
    1e6a:	0089      	lsls	r1, r1, #2
    1e6c:	0038      	movs	r0, r7
    1e6e:	f7fe f96b 	bl	148 <__aeabi_uidivmod>
    1e72:	9101      	str	r1, [sp, #4]
    1e74:	21fa      	movs	r1, #250	; 0xfa
    1e76:	0038      	movs	r0, r7
    1e78:	0089      	lsls	r1, r1, #2
    1e7a:	f7fe f929 	bl	d0 <__udivsi3>
    1e7e:	4e17      	ldr	r6, [pc, #92]	; (1edc <main+0x1d0>)
    1e80:	990e      	ldr	r1, [sp, #56]	; 0x38
    1e82:	9000      	str	r0, [sp, #0]
    1e84:	00ad      	lsls	r5, r5, #2
    1e86:	0030      	movs	r0, r6
    1e88:	6863      	ldr	r3, [r4, #4]
    1e8a:	6822      	ldr	r2, [r4, #0]
    1e8c:	5949      	ldr	r1, [r1, r5]
    1e8e:	f003 fc98 	bl	57c2 <printk>
		flush_frequency++;
    1e92:	e7bf      	b.n	1e14 <main+0x108>
		TC_END_REPORT(TC_PASS);
    1e94:	f003 fc95 	bl	57c2 <printk>
    1e98:	0028      	movs	r0, r5
    1e9a:	f003 fc92 	bl	57c2 <printk>
    1e9e:	4910      	ldr	r1, [pc, #64]	; (1ee0 <main+0x1d4>)
    1ea0:	e753      	b.n	1d4a <main+0x3e>
    1ea2:	46c0      	nop			; (mov r8, r8)
    1ea4:	00006798 	.word	0x00006798
    1ea8:	00005e78 	.word	0x00005e78
    1eac:	00005e94 	.word	0x00005e94
    1eb0:	00006851 	.word	0x00006851
    1eb4:	20000376 	.word	0x20000376
    1eb8:	00006680 	.word	0x00006680
    1ebc:	00006877 	.word	0x00006877
    1ec0:	000068a7 	.word	0x000068a7
    1ec4:	000068a0 	.word	0x000068a0
    1ec8:	000186a0 	.word	0x000186a0
    1ecc:	fffffc18 	.word	0xfffffc18
    1ed0:	00005f00 	.word	0x00005f00
    1ed4:	000067c1 	.word	0x000067c1
    1ed8:	00006f87 	.word	0x00006f87
    1edc:	00006825 	.word	0x00006825
    1ee0:	000068bd 	.word	0x000068bd

00001ee4 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    1ee4:	b567      	push	{r0, r1, r2, r5, r6, lr}
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    1ee6:	2340      	movs	r3, #64	; 0x40
{
    1ee8:	000d      	movs	r5, r1
	size_t offset = (size_t)(mgr - data->mgr);
    1eea:	4907      	ldr	r1, [pc, #28]	; (1f08 <onoff_start+0x24>)
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    1eec:	9300      	str	r3, [sp, #0]
	size_t offset = (size_t)(mgr - data->mgr);
    1eee:	1a41      	subs	r1, r0, r1
    1ef0:	1149      	asrs	r1, r1, #5
{
    1ef2:	0006      	movs	r6, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    1ef4:	002b      	movs	r3, r5
    1ef6:	4a05      	ldr	r2, [pc, #20]	; (1f0c <onoff_start+0x28>)
    1ef8:	4805      	ldr	r0, [pc, #20]	; (1f10 <onoff_start+0x2c>)
    1efa:	f003 fda5 	bl	5a48 <async_start>
    1efe:	1e01      	subs	r1, r0, #0
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
    1f00:	da01      	bge.n	1f06 <onoff_start+0x22>
		notify(mgr, err);
    1f02:	0030      	movs	r0, r6
    1f04:	47a8      	blx	r5
	}
}
    1f06:	bd67      	pop	{r0, r1, r2, r5, r6, pc}
    1f08:	200002bc 	.word	0x200002bc
    1f0c:	00005ac3 	.word	0x00005ac3
    1f10:	00005d4c 	.word	0x00005d4c

00001f14 <get_status>:
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
    1f14:	b2cb      	uxtb	r3, r1
{
    1f16:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
    1f18:	2b01      	cmp	r3, #1
    1f1a:	d90a      	bls.n	1f32 <get_status+0x1e>
    1f1c:	4c09      	ldr	r4, [pc, #36]	; (1f44 <get_status+0x30>)
    1f1e:	490a      	ldr	r1, [pc, #40]	; (1f48 <get_status+0x34>)
    1f20:	480a      	ldr	r0, [pc, #40]	; (1f4c <get_status+0x38>)
    1f22:	237a      	movs	r3, #122	; 0x7a
    1f24:	0022      	movs	r2, r4
    1f26:	f003 fcdf 	bl	58e8 <assert_print>
    1f2a:	217a      	movs	r1, #122	; 0x7a
    1f2c:	0020      	movs	r0, r4
    1f2e:	f003 fcd7 	bl	58e0 <assert_post_action>
	return GET_STATUS(get_sub_data(dev, type)->flags);
    1f32:	220c      	movs	r2, #12
    1f34:	b2c9      	uxtb	r1, r1
    1f36:	434a      	muls	r2, r1
    1f38:	6903      	ldr	r3, [r0, #16]
    1f3a:	189b      	adds	r3, r3, r2
    1f3c:	6c98      	ldr	r0, [r3, #72]	; 0x48
    1f3e:	2307      	movs	r3, #7
    1f40:	4018      	ands	r0, r3
}
    1f42:	bd10      	pop	{r4, pc}
    1f44:	00006902 	.word	0x00006902
    1f48:	0000693f 	.word	0x0000693f
    1f4c:	00006347 	.word	0x00006347

00001f50 <stop>:
{
    1f50:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    1f52:	b2cc      	uxtb	r4, r1
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
    1f54:	b2c9      	uxtb	r1, r1
	struct nrf_clock_control_data *data = dev->data;
    1f56:	6903      	ldr	r3, [r0, #16]
{
    1f58:	9201      	str	r2, [sp, #4]
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
    1f5a:	2901      	cmp	r1, #1
    1f5c:	d90c      	bls.n	1f78 <stop+0x28>
    1f5e:	235e      	movs	r3, #94	; 0x5e
    1f60:	4c1a      	ldr	r4, [pc, #104]	; (1fcc <stop+0x7c>)
    1f62:	491b      	ldr	r1, [pc, #108]	; (1fd0 <stop+0x80>)
    1f64:	481b      	ldr	r0, [pc, #108]	; (1fd4 <stop+0x84>)
    1f66:	0022      	movs	r2, r4
    1f68:	33ff      	adds	r3, #255	; 0xff
    1f6a:	f003 fcbd 	bl	58e8 <assert_print>
    1f6e:	215e      	movs	r1, #94	; 0x5e
    1f70:	0020      	movs	r0, r4
    1f72:	31ff      	adds	r1, #255	; 0xff
    1f74:	f003 fcb4 	bl	58e0 <assert_post_action>
	__asm__ volatile("mrs %0, PRIMASK;"
    1f78:	f3ef 8610 	mrs	r6, PRIMASK
    1f7c:	b672      	cpsid	i
	uint32_t current_ctx = GET_CTX(*flags);
    1f7e:	210c      	movs	r1, #12
    1f80:	000d      	movs	r5, r1
    1f82:	4365      	muls	r5, r4
    1f84:	195d      	adds	r5, r3, r5
    1f86:	6caf      	ldr	r7, [r5, #72]	; 0x48
    1f88:	25c0      	movs	r5, #192	; 0xc0
    1f8a:	003a      	movs	r2, r7
    1f8c:	402a      	ands	r2, r5
    1f8e:	4694      	mov	ip, r2
	if ((current_ctx != 0) && (current_ctx != ctx)) {
    1f90:	422f      	tst	r7, r5
    1f92:	d00a      	beq.n	1faa <stop+0x5a>
    1f94:	9a01      	ldr	r2, [sp, #4]
    1f96:	4562      	cmp	r2, ip
    1f98:	d007      	beq.n	1faa <stop+0x5a>
	if (key != 0U) {
    1f9a:	2e00      	cmp	r6, #0
    1f9c:	d102      	bne.n	1fa4 <stop+0x54>
	__asm__ volatile(
    1f9e:	b662      	cpsie	i
    1fa0:	f3bf 8f6f 	isb	sy
		err = -EPERM;
    1fa4:	2001      	movs	r0, #1
    1fa6:	4240      	negs	r0, r0
}
    1fa8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		*flags = CLOCK_CONTROL_STATUS_OFF;
    1faa:	2201      	movs	r2, #1
    1fac:	4361      	muls	r1, r4
    1fae:	185b      	adds	r3, r3, r1
    1fb0:	649a      	str	r2, [r3, #72]	; 0x48
	if (key != 0U) {
    1fb2:	2e00      	cmp	r6, #0
    1fb4:	d102      	bne.n	1fbc <stop+0x6c>
	__asm__ volatile(
    1fb6:	b662      	cpsie	i
    1fb8:	f3bf 8f6f 	isb	sy
	get_sub_config(dev, type)->stop();
    1fbc:	220c      	movs	r2, #12
    1fbe:	4362      	muls	r2, r4
    1fc0:	6843      	ldr	r3, [r0, #4]
    1fc2:	189b      	adds	r3, r3, r2
    1fc4:	685b      	ldr	r3, [r3, #4]
    1fc6:	4798      	blx	r3
	return 0;
    1fc8:	2000      	movs	r0, #0
    1fca:	e7ed      	b.n	1fa8 <stop+0x58>
    1fcc:	00006902 	.word	0x00006902
    1fd0:	0000693f 	.word	0x0000693f
    1fd4:	00006347 	.word	0x00006347

00001fd8 <onoff_stop>:
{
    1fd8:	b570      	push	{r4, r5, r6, lr}
    1fda:	000d      	movs	r5, r1
	size_t offset = (size_t)(mgr - data->mgr);
    1fdc:	4905      	ldr	r1, [pc, #20]	; (1ff4 <onoff_stop+0x1c>)
{
    1fde:	0004      	movs	r4, r0
	size_t offset = (size_t)(mgr - data->mgr);
    1fe0:	1a41      	subs	r1, r0, r1
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    1fe2:	2240      	movs	r2, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
    1fe4:	1149      	asrs	r1, r1, #5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    1fe6:	4804      	ldr	r0, [pc, #16]	; (1ff8 <onoff_stop+0x20>)
    1fe8:	f7ff ffb2 	bl	1f50 <stop>
    1fec:	0001      	movs	r1, r0
	notify(mgr, res);
    1fee:	0020      	movs	r0, r4
    1ff0:	47a8      	blx	r5
}
    1ff2:	bd70      	pop	{r4, r5, r6, pc}
    1ff4:	200002bc 	.word	0x200002bc
    1ff8:	00005d4c 	.word	0x00005d4c

00001ffc <clk_init>:
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    1ffc:	2200      	movs	r2, #0
{
    1ffe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    2000:	2101      	movs	r1, #1
{
    2002:	0004      	movs	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    2004:	0010      	movs	r0, r2
    2006:	f7ff fa07 	bl	1418 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);

	nrfx_err = nrfx_clock_init(clock_event_handler);
    200a:	4810      	ldr	r0, [pc, #64]	; (204c <clk_init+0x50>)
    200c:	f000 fe0c 	bl	2c28 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
    2010:	4b0f      	ldr	r3, [pc, #60]	; (2050 <clk_init+0x54>)
    2012:	4298      	cmp	r0, r3
    2014:	d116      	bne.n	2044 <clk_init+0x48>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    2016:	f000 fe2f 	bl	2c78 <nrfx_clock_enable>
	struct nrf_clock_control_data *data = dev->data;
    201a:	6927      	ldr	r7, [r4, #16]
	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);

		err = onoff_manager_init(get_onoff_manager(dev, i),
    201c:	4e0d      	ldr	r6, [pc, #52]	; (2054 <clk_init+0x58>)
    201e:	0038      	movs	r0, r7
    2020:	0031      	movs	r1, r6
    2022:	f003 fbe3 	bl	57ec <onoff_manager_init>
					 &transitions);
		if (err < 0) {
    2026:	2800      	cmp	r0, #0
    2028:	db0b      	blt.n	2042 <clk_init+0x46>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    202a:	2501      	movs	r5, #1
    202c:	64bd      	str	r5, [r7, #72]	; 0x48
	struct nrf_clock_control_data *data = dev->data;
    202e:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
    2030:	0031      	movs	r1, r6
	return &data->mgr[type];
    2032:	0020      	movs	r0, r4
    2034:	3020      	adds	r0, #32
		err = onoff_manager_init(get_onoff_manager(dev, i),
    2036:	f003 fbd9 	bl	57ec <onoff_manager_init>
		if (err < 0) {
    203a:	2800      	cmp	r0, #0
    203c:	db01      	blt.n	2042 <clk_init+0x46>
	}

	return 0;
    203e:	2000      	movs	r0, #0
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    2040:	6565      	str	r5, [r4, #84]	; 0x54
}
    2042:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -EIO;
    2044:	2005      	movs	r0, #5
    2046:	4240      	negs	r0, r0
    2048:	e7fb      	b.n	2042 <clk_init+0x46>
    204a:	46c0      	nop			; (mov r8, r8)
    204c:	000020ed 	.word	0x000020ed
    2050:	0bad0000 	.word	0x0bad0000
    2054:	00005f18 	.word	0x00005f18

00002058 <api_blocking_start>:
{
    2058:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    205a:	466b      	mov	r3, sp
    205c:	9300      	str	r3, [sp, #0]
    205e:	9301      	str	r3, [sp, #4]
    2060:	2300      	movs	r3, #0
    2062:	9302      	str	r3, [sp, #8]
    2064:	3301      	adds	r3, #1
    2066:	9303      	str	r3, [sp, #12]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    2068:	4a06      	ldr	r2, [pc, #24]	; (2084 <api_blocking_start+0x2c>)
    206a:	466b      	mov	r3, sp
    206c:	f003 fd23 	bl	5ab6 <api_start>
	if (err < 0) {
    2070:	2800      	cmp	r0, #0
    2072:	db04      	blt.n	207e <api_blocking_start+0x26>
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm1 = { .val = timeout };
		return (int) arch_syscall_invoke3(parm0.x, parm1.split.lo, parm1.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
    2074:	2232      	movs	r2, #50	; 0x32
    2076:	2300      	movs	r3, #0
    2078:	4668      	mov	r0, sp
    207a:	f001 feb5 	bl	3de8 <z_impl_k_sem_take>
}
    207e:	b005      	add	sp, #20
    2080:	bd00      	pop	{pc}
    2082:	46c0      	nop			; (mov r8, r8)
    2084:	00005ae7 	.word	0x00005ae7

00002088 <generic_hfclk_stop>:
{
    2088:	b510      	push	{r4, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    208a:	f3ef 8410 	mrs	r4, PRIMASK
    208e:	b672      	cpsid	i
	hfclk_users &= ~HF_USER_GENERIC;
    2090:	4a08      	ldr	r2, [pc, #32]	; (20b4 <generic_hfclk_stop+0x2c>)
    2092:	2102      	movs	r1, #2
    2094:	6813      	ldr	r3, [r2, #0]
    2096:	0018      	movs	r0, r3
    2098:	4388      	bics	r0, r1
    209a:	6010      	str	r0, [r2, #0]
	if (!(hfclk_users & HF_USER_BT)) {
    209c:	2001      	movs	r0, #1
    209e:	4203      	tst	r3, r0
    20a0:	d101      	bne.n	20a6 <generic_hfclk_stop+0x1e>
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    20a2:	f000 fe7d 	bl	2da0 <nrfx_clock_stop>
	if (key != 0U) {
    20a6:	2c00      	cmp	r4, #0
    20a8:	d102      	bne.n	20b0 <generic_hfclk_stop+0x28>
	__asm__ volatile(
    20aa:	b662      	cpsie	i
    20ac:	f3bf 8f6f 	isb	sy
}
    20b0:	bd10      	pop	{r4, pc}
    20b2:	46c0      	nop			; (mov r8, r8)
    20b4:	20000314 	.word	0x20000314

000020b8 <clkstarted_handle.constprop.0>:
	clock_control_cb_t callback = sub_data->cb;
    20b8:	230c      	movs	r3, #12
static void clkstarted_handle(const struct device *dev,
    20ba:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
    20bc:	4343      	muls	r3, r0
static void clkstarted_handle(const struct device *dev,
    20be:	0004      	movs	r4, r0
	sub_data->cb = NULL;
    20c0:	2000      	movs	r0, #0
	clock_control_cb_t callback = sub_data->cb;
    20c2:	4a08      	ldr	r2, [pc, #32]	; (20e4 <clkstarted_handle.constprop.0+0x2c>)
    20c4:	18d1      	adds	r1, r2, r3
    20c6:	6c0d      	ldr	r5, [r1, #64]	; 0x40
	set_on_state(&sub_data->flags);
    20c8:	3348      	adds	r3, #72	; 0x48
	sub_data->cb = NULL;
    20ca:	6408      	str	r0, [r1, #64]	; 0x40
	set_on_state(&sub_data->flags);
    20cc:	1898      	adds	r0, r3, r2
	void *user_data = sub_data->user_data;
    20ce:	6c4e      	ldr	r6, [r1, #68]	; 0x44
	set_on_state(&sub_data->flags);
    20d0:	f003 fd13 	bl	5afa <set_on_state>
	if (callback) {
    20d4:	2d00      	cmp	r5, #0
    20d6:	d003      	beq.n	20e0 <clkstarted_handle.constprop.0+0x28>
		callback(dev, (clock_control_subsys_t)type, user_data);
    20d8:	0032      	movs	r2, r6
    20da:	0021      	movs	r1, r4
    20dc:	4802      	ldr	r0, [pc, #8]	; (20e8 <clkstarted_handle.constprop.0+0x30>)
    20de:	47a8      	blx	r5
}
    20e0:	bd70      	pop	{r4, r5, r6, pc}
    20e2:	46c0      	nop			; (mov r8, r8)
    20e4:	200002bc 	.word	0x200002bc
    20e8:	00005d4c 	.word	0x00005d4c

000020ec <clock_event_handler>:
{
    20ec:	b510      	push	{r4, lr}
	switch (event) {
    20ee:	2801      	cmp	r0, #1
    20f0:	d00a      	beq.n	2108 <clock_event_handler+0x1c>
    20f2:	2804      	cmp	r0, #4
    20f4:	d00b      	beq.n	210e <clock_event_handler+0x22>
    20f6:	2800      	cmp	r0, #0
    20f8:	d114      	bne.n	2124 <clock_event_handler+0x38>
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    20fa:	4b0f      	ldr	r3, [pc, #60]	; (2138 <clock_event_handler+0x4c>)
    20fc:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    20fe:	2307      	movs	r3, #7
    2100:	0010      	movs	r0, r2
    2102:	4018      	ands	r0, r3
    2104:	421a      	tst	r2, r3
    2106:	d101      	bne.n	210c <clock_event_handler+0x20>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    2108:	f7ff ffd6 	bl	20b8 <clkstarted_handle.constprop.0>
}
    210c:	bd10      	pop	{r4, pc}
			__ASSERT_NO_MSG(false);
    210e:	4c0b      	ldr	r4, [pc, #44]	; (213c <clock_event_handler+0x50>)
    2110:	490b      	ldr	r1, [pc, #44]	; (2140 <clock_event_handler+0x54>)
    2112:	0022      	movs	r2, r4
    2114:	480b      	ldr	r0, [pc, #44]	; (2144 <clock_event_handler+0x58>)
    2116:	4b0c      	ldr	r3, [pc, #48]	; (2148 <clock_event_handler+0x5c>)
    2118:	f003 fbe6 	bl	58e8 <assert_print>
    211c:	490a      	ldr	r1, [pc, #40]	; (2148 <clock_event_handler+0x5c>)
		__ASSERT_NO_MSG(0);
    211e:	0020      	movs	r0, r4
    2120:	f003 fbde 	bl	58e0 <assert_post_action>
    2124:	4c05      	ldr	r4, [pc, #20]	; (213c <clock_event_handler+0x50>)
    2126:	4906      	ldr	r1, [pc, #24]	; (2140 <clock_event_handler+0x54>)
    2128:	0022      	movs	r2, r4
    212a:	4806      	ldr	r0, [pc, #24]	; (2144 <clock_event_handler+0x58>)
    212c:	4b07      	ldr	r3, [pc, #28]	; (214c <clock_event_handler+0x60>)
    212e:	f003 fbdb 	bl	58e8 <assert_print>
    2132:	4906      	ldr	r1, [pc, #24]	; (214c <clock_event_handler+0x60>)
    2134:	e7f3      	b.n	211e <clock_event_handler+0x32>
    2136:	46c0      	nop			; (mov r8, r8)
    2138:	200002bc 	.word	0x200002bc
    213c:	00006902 	.word	0x00006902
    2140:	00006f16 	.word	0x00006f16
    2144:	00006347 	.word	0x00006347
    2148:	0000026e 	.word	0x0000026e
    214c:	00000272 	.word	0x00000272

00002150 <generic_hfclk_start>:
{
    2150:	b510      	push	{r4, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    2152:	f3ef 8410 	mrs	r4, PRIMASK
    2156:	b672      	cpsid	i
	hfclk_users |= HF_USER_GENERIC;
    2158:	2302      	movs	r3, #2
    215a:	4911      	ldr	r1, [pc, #68]	; (21a0 <generic_hfclk_start+0x50>)
    215c:	680a      	ldr	r2, [r1, #0]
    215e:	4313      	orrs	r3, r2
    2160:	600b      	str	r3, [r1, #0]
	if (hfclk_users & HF_USER_BT) {
    2162:	2301      	movs	r3, #1
    2164:	421a      	tst	r2, r3
    2166:	d108      	bne.n	217a <generic_hfclk_start+0x2a>
	if (key != 0U) {
    2168:	2c00      	cmp	r4, #0
    216a:	d102      	bne.n	2172 <generic_hfclk_start+0x22>
	__asm__ volatile(
    216c:	b662      	cpsie	i
    216e:	f3bf 8f6f 	isb	sy
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    2172:	2001      	movs	r0, #1
    2174:	f000 fda8 	bl	2cc8 <nrfx_clock_start>
    2178:	e011      	b.n	219e <generic_hfclk_start+0x4e>
                    (nrf_clock_lfclk_t)((p_reg->NRF_LFCLKSTAT & NRF_CLOCK_LFCLKSTAT_SRC_Msk)
                                        >> NRF_CLOCK_LFCLKSTAT_SRC_Pos);
            }
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            clock_running = p_reg->NRF_HFCLKSTAT & NRF_CLOCK_HFCLKSTAT_STATE_Msk;
    217a:	2180      	movs	r1, #128	; 0x80
    217c:	4a09      	ldr	r2, [pc, #36]	; (21a4 <generic_hfclk_start+0x54>)
    217e:	05c9      	lsls	r1, r1, #23
    2180:	5888      	ldr	r0, [r1, r2]
                 * It has to be derived from HFCLK state. */
                (*(nrf_clock_hfclk_t *)p_clk_src) = clock_running ? NRF_CLOCK_HFCLK_HIGH_ACCURACY :
                                                                    NRF_CLOCK_HFCLK_LOW_ACCURACY;
#else
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->NRF_HFCLKSTAT & NRF_CLOCK_HFCLKSTAT_SRC_Msk)
    2182:	588a      	ldr	r2, [r1, r2]
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    2184:	421a      	tst	r2, r3
    2186:	d0ef      	beq.n	2168 <generic_hfclk_start+0x18>
			set_on_state(get_hf_flags());
    2188:	4807      	ldr	r0, [pc, #28]	; (21a8 <generic_hfclk_start+0x58>)
    218a:	f003 fcb6 	bl	5afa <set_on_state>
	if (key != 0U) {
    218e:	2c00      	cmp	r4, #0
    2190:	d102      	bne.n	2198 <generic_hfclk_start+0x48>
	__asm__ volatile(
    2192:	b662      	cpsie	i
    2194:	f3bf 8f6f 	isb	sy
		clkstarted_handle(CLOCK_DEVICE,
    2198:	2000      	movs	r0, #0
    219a:	f7ff ff8d 	bl	20b8 <clkstarted_handle.constprop.0>
}
    219e:	bd10      	pop	{r4, pc}
    21a0:	20000314 	.word	0x20000314
    21a4:	0000040c 	.word	0x0000040c
    21a8:	20000304 	.word	0x20000304

000021ac <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(void)
{
    21ac:	b510      	push	{r4, lr}
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
    21ae:	4808      	ldr	r0, [pc, #32]	; (21d0 <uart_console_init+0x24>)
    21b0:	f003 fd60 	bl	5c74 <z_device_is_ready>
	if (!device_is_ready(uart_console_dev)) {
    21b4:	2800      	cmp	r0, #0
    21b6:	d008      	beq.n	21ca <uart_console_init+0x1e>
	__stdout_hook_install(console_out);
    21b8:	4c06      	ldr	r4, [pc, #24]	; (21d4 <uart_console_init+0x28>)
    21ba:	0020      	movs	r0, r4
    21bc:	f7ff fafe 	bl	17bc <__stdout_hook_install>
	__printk_hook_install(console_out);
    21c0:	0020      	movs	r0, r4
    21c2:	f7fe fa01 	bl	5c8 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
    21c6:	2000      	movs	r0, #0
}
    21c8:	bd10      	pop	{r4, pc}
		return -ENODEV;
    21ca:	2013      	movs	r0, #19
    21cc:	4240      	negs	r0, r0
    21ce:	e7fb      	b.n	21c8 <uart_console_init+0x1c>
    21d0:	00005d7c 	.word	0x00005d7c
    21d4:	000021d9 	.word	0x000021d9

000021d8 <console_out>:
{
    21d8:	b570      	push	{r4, r5, r6, lr}
    21da:	0004      	movs	r4, r0
    21dc:	4d07      	ldr	r5, [pc, #28]	; (21fc <console_out+0x24>)
	if ('\n' == c) {
    21de:	280a      	cmp	r0, #10
    21e0:	d104      	bne.n	21ec <console_out+0x14>
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    21e2:	68ab      	ldr	r3, [r5, #8]
    21e4:	210d      	movs	r1, #13
    21e6:	0028      	movs	r0, r5
    21e8:	685b      	ldr	r3, [r3, #4]
    21ea:	4798      	blx	r3
    21ec:	68ab      	ldr	r3, [r5, #8]
    21ee:	0028      	movs	r0, r5
    21f0:	685b      	ldr	r3, [r3, #4]
    21f2:	b2e1      	uxtb	r1, r4
    21f4:	4798      	blx	r3
}
    21f6:	0020      	movs	r0, r4
    21f8:	bd70      	pop	{r4, r5, r6, pc}
    21fa:	46c0      	nop			; (mov r8, r8)
    21fc:	00005d7c 	.word	0x00005d7c

00002200 <gpio_nrfx_port_set_masked_raw>:

static int gpio_nrfx_port_set_masked_raw(const struct device *port,
					 gpio_port_pins_t mask,
					 gpio_port_value_t value)
{
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    2200:	6843      	ldr	r3, [r0, #4]

	const uint32_t set_mask = value & mask;
    2202:	0008      	movs	r0, r1
    2204:	4010      	ands	r0, r2
	const uint32_t clear_mask = (~set_mask) & mask;
    2206:	4391      	bics	r1, r2
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
    2208:	22a1      	movs	r2, #161	; 0xa1
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    220a:	685b      	ldr	r3, [r3, #4]
    220c:	00d2      	lsls	r2, r2, #3
    220e:	5098      	str	r0, [r3, r2]
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
    2210:	4a01      	ldr	r2, [pc, #4]	; (2218 <gpio_nrfx_port_set_masked_raw+0x18>)

	nrf_gpio_port_out_set(reg, set_mask);
	nrf_gpio_port_out_clear(reg, clear_mask);

	return 0;
}
    2212:	2000      	movs	r0, #0
    2214:	5099      	str	r1, [r3, r2]
    2216:	4770      	bx	lr
    2218:	0000050c 	.word	0x0000050c

0000221c <gpio_nrfx_port_clear_bits_raw>:
}

static int gpio_nrfx_port_clear_bits_raw(const struct device *port,
					 gpio_port_pins_t mask)
{
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    221c:	6843      	ldr	r3, [r0, #4]

	nrf_gpio_port_out_clear(reg, mask);

	return 0;
}
    221e:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    2220:	685a      	ldr	r2, [r3, #4]
    2222:	4b01      	ldr	r3, [pc, #4]	; (2228 <gpio_nrfx_port_clear_bits_raw+0xc>)
    2224:	50d1      	str	r1, [r2, r3]
}
    2226:	4770      	bx	lr
    2228:	0000050c 	.word	0x0000050c

0000222c <gpio_nrfx_port_toggle_bits>:

static int gpio_nrfx_port_toggle_bits(const struct device *port,
				      gpio_port_pins_t mask)
{
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    222c:	6843      	ldr	r3, [r0, #4]
	const uint32_t value = nrf_gpio_port_out_read(reg) ^ mask;
	const uint32_t set_mask = value & mask;
    222e:	0008      	movs	r0, r1
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    2230:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
    2232:	4b05      	ldr	r3, [pc, #20]	; (2248 <gpio_nrfx_port_toggle_bits+0x1c>)
    2234:	58d3      	ldr	r3, [r2, r3]
	const uint32_t set_mask = value & mask;
    2236:	4398      	bics	r0, r3
	const uint32_t clear_mask = (~value) & mask;
    2238:	400b      	ands	r3, r1
    p_reg->OUTSET = set_mask;
    223a:	21a1      	movs	r1, #161	; 0xa1
    223c:	00c9      	lsls	r1, r1, #3
    223e:	5050      	str	r0, [r2, r1]
    p_reg->OUTCLR = clr_mask;
    2240:	4902      	ldr	r1, [pc, #8]	; (224c <gpio_nrfx_port_toggle_bits+0x20>)

	nrf_gpio_port_out_set(reg, set_mask);
	nrf_gpio_port_out_clear(reg, clear_mask);

	return 0;
}
    2242:	2000      	movs	r0, #0
    2244:	5053      	str	r3, [r2, r1]
    2246:	4770      	bx	lr
    2248:	00000504 	.word	0x00000504
    224c:	0000050c 	.word	0x0000050c

00002250 <gpio_nrfx_manage_callback>:
}

static int gpio_nrfx_manage_callback(const struct device *port,
				     struct gpio_callback *callback,
				     bool set)
{
    2250:	b510      	push	{r4, lr}
	return port->data;
    2252:	6903      	ldr	r3, [r0, #16]
 */
static inline int gpio_manage_callback(sys_slist_t *callbacks,
					struct gpio_callback *callback,
					bool set)
{
	__ASSERT(callback, "No callback!");
    2254:	2900      	cmp	r1, #0
    2256:	d10d      	bne.n	2274 <gpio_nrfx_manage_callback+0x24>
    2258:	4c23      	ldr	r4, [pc, #140]	; (22e8 <gpio_nrfx_manage_callback+0x98>)
    225a:	4924      	ldr	r1, [pc, #144]	; (22ec <gpio_nrfx_manage_callback+0x9c>)
    225c:	232a      	movs	r3, #42	; 0x2a
    225e:	0022      	movs	r2, r4
    2260:	4823      	ldr	r0, [pc, #140]	; (22f0 <gpio_nrfx_manage_callback+0xa0>)
    2262:	f003 fb41 	bl	58e8 <assert_print>
    2266:	4823      	ldr	r0, [pc, #140]	; (22f4 <gpio_nrfx_manage_callback+0xa4>)
    2268:	f003 fb3e 	bl	58e8 <assert_print>
    226c:	212a      	movs	r1, #42	; 0x2a
	__ASSERT(callback->handler, "No callback handler!");
    226e:	0020      	movs	r0, r4
    2270:	f003 fb36 	bl	58e0 <assert_post_action>
    2274:	6848      	ldr	r0, [r1, #4]
    2276:	2800      	cmp	r0, #0
    2278:	d10b      	bne.n	2292 <gpio_nrfx_manage_callback+0x42>
    227a:	4c1b      	ldr	r4, [pc, #108]	; (22e8 <gpio_nrfx_manage_callback+0x98>)
    227c:	491e      	ldr	r1, [pc, #120]	; (22f8 <gpio_nrfx_manage_callback+0xa8>)
    227e:	232b      	movs	r3, #43	; 0x2b
    2280:	0022      	movs	r2, r4
    2282:	481b      	ldr	r0, [pc, #108]	; (22f0 <gpio_nrfx_manage_callback+0xa0>)
    2284:	f003 fb30 	bl	58e8 <assert_print>
    2288:	481c      	ldr	r0, [pc, #112]	; (22fc <gpio_nrfx_manage_callback+0xac>)
    228a:	f003 fb2d 	bl	58e8 <assert_print>
    228e:	212b      	movs	r1, #43	; 0x2b
    2290:	e7ed      	b.n	226e <gpio_nrfx_manage_callback+0x1e>
	return list->head;
    2292:	6858      	ldr	r0, [r3, #4]

	if (!sys_slist_is_empty(callbacks)) {
    2294:	2800      	cmp	r0, #0
    2296:	d021      	beq.n	22dc <gpio_nrfx_manage_callback+0x8c>
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    2298:	4288      	cmp	r0, r1
    229a:	d11b      	bne.n	22d4 <gpio_nrfx_manage_callback+0x84>
	return node->next;
    229c:	6808      	ldr	r0, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
    229e:	689c      	ldr	r4, [r3, #8]
	list->head = node;
    22a0:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
    22a2:	42a1      	cmp	r1, r4
    22a4:	d100      	bne.n	22a8 <gpio_nrfx_manage_callback+0x58>
	list->tail = node;
    22a6:	6098      	str	r0, [r3, #8]
	parent->next = child;
    22a8:	2000      	movs	r0, #0
    22aa:	6008      	str	r0, [r1, #0]
		}
	} else if (!set) {
		return -EINVAL;
	}

	if (set) {
    22ac:	4282      	cmp	r2, r0
    22ae:	d006      	beq.n	22be <gpio_nrfx_manage_callback+0x6e>
	return list->head;
    22b0:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
    22b2:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
    22b4:	689a      	ldr	r2, [r3, #8]
	list->head = node;
    22b6:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
    22b8:	2a00      	cmp	r2, #0
    22ba:	d100      	bne.n	22be <gpio_nrfx_manage_callback+0x6e>
	list->tail = node;
    22bc:	6099      	str	r1, [r3, #8]
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
    22be:	2000      	movs	r0, #0
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    22c0:	e010      	b.n	22e4 <gpio_nrfx_manage_callback+0x94>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    22c2:	4281      	cmp	r1, r0
    22c4:	d106      	bne.n	22d4 <gpio_nrfx_manage_callback+0x84>
	return node->next;
    22c6:	6808      	ldr	r0, [r1, #0]
	parent->next = child;
    22c8:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
    22ca:	6898      	ldr	r0, [r3, #8]
    22cc:	4281      	cmp	r1, r0
    22ce:	d1eb      	bne.n	22a8 <gpio_nrfx_manage_callback+0x58>
	list->tail = node;
    22d0:	609c      	str	r4, [r3, #8]
}
    22d2:	e7e9      	b.n	22a8 <gpio_nrfx_manage_callback+0x58>
	return node->next;
    22d4:	0004      	movs	r4, r0
    22d6:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    22d8:	2800      	cmp	r0, #0
    22da:	d1f2      	bne.n	22c2 <gpio_nrfx_manage_callback+0x72>
			if (!set) {
    22dc:	2a00      	cmp	r2, #0
    22de:	d1e7      	bne.n	22b0 <gpio_nrfx_manage_callback+0x60>
				return -EINVAL;
    22e0:	2016      	movs	r0, #22
    22e2:	4240      	negs	r0, r0
				     callback, set);
}
    22e4:	bd10      	pop	{r4, pc}
    22e6:	46c0      	nop			; (mov r8, r8)
    22e8:	0000698c 	.word	0x0000698c
    22ec:	000069c8 	.word	0x000069c8
    22f0:	00006347 	.word	0x00006347
    22f4:	000069d1 	.word	0x000069d1
    22f8:	000069e0 	.word	0x000069e0
    22fc:	000069f2 	.word	0x000069f2

00002300 <gpio_nrfx_pin_interrupt_configure>:
{
    2300:	b5f0      	push	{r4, r5, r6, r7, lr}
    2302:	001e      	movs	r6, r3
	return port->config;
    2304:	6843      	ldr	r3, [r0, #4]
{
    2306:	b087      	sub	sp, #28
	return port->config;
    2308:	9300      	str	r3, [sp, #0]
{
    230a:	9101      	str	r1, [sp, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    230c:	7b1c      	ldrb	r4, [r3, #12]
    230e:	231f      	movs	r3, #31
    2310:	0164      	lsls	r4, r4, #5
    2312:	400b      	ands	r3, r1
    2314:	431c      	orrs	r4, r3
	if (mode == GPIO_INT_MODE_DISABLED) {
    2316:	2380      	movs	r3, #128	; 0x80
{
    2318:	0017      	movs	r7, r2
	if (mode == GPIO_INT_MODE_DISABLED) {
    231a:	039b      	lsls	r3, r3, #14
    231c:	429a      	cmp	r2, r3
    231e:	d105      	bne.n	232c <gpio_nrfx_pin_interrupt_configure+0x2c>
		nrfx_gpiote_trigger_disable(abs_pin);
    2320:	0020      	movs	r0, r4
    2322:	f001 f8d9 	bl	34d8 <nrfx_gpiote_trigger_disable>
		return 0;
    2326:	2000      	movs	r0, #0
}
    2328:	b007      	add	sp, #28
    232a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	nrfx_gpiote_trigger_config_t trigger_config = {
    232c:	ad04      	add	r5, sp, #16
    232e:	2208      	movs	r2, #8
    2330:	2100      	movs	r1, #0
    2332:	0028      	movs	r0, r5
    2334:	f003 fb40 	bl	59b8 <memset>
	if (mode == GPIO_INT_MODE_LEVEL) {
    2338:	2380      	movs	r3, #128	; 0x80
    233a:	03db      	lsls	r3, r3, #15
    233c:	429f      	cmp	r7, r3
    233e:	d115      	bne.n	236c <gpio_nrfx_pin_interrupt_configure+0x6c>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
    2340:	2380      	movs	r3, #128	; 0x80
    2342:	049b      	lsls	r3, r3, #18
    2344:	429e      	cmp	r6, r3
    2346:	d10f      	bne.n	2368 <gpio_nrfx_pin_interrupt_configure+0x68>
	nrfx_gpiote_trigger_config_t trigger_config = {
    2348:	2304      	movs	r3, #4
    234a:	702b      	strb	r3, [r5, #0]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    234c:	2300      	movs	r3, #0
    234e:	002a      	movs	r2, r5
    2350:	0019      	movs	r1, r3
    2352:	0020      	movs	r0, r4
    2354:	f000 fe7e 	bl	3054 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    2358:	4b2d      	ldr	r3, [pc, #180]	; (2410 <gpio_nrfx_pin_interrupt_configure+0x110>)
    235a:	4298      	cmp	r0, r3
    235c:	d155      	bne.n	240a <gpio_nrfx_pin_interrupt_configure+0x10a>
	nrfx_gpiote_trigger_enable(abs_pin, true);
    235e:	2101      	movs	r1, #1
    2360:	0020      	movs	r0, r4
    2362:	f001 f84d 	bl	3400 <nrfx_gpiote_trigger_enable>
	return 0;
    2366:	e7de      	b.n	2326 <gpio_nrfx_pin_interrupt_configure+0x26>
	nrfx_gpiote_trigger_config_t trigger_config = {
    2368:	2305      	movs	r3, #5
    236a:	e7ee      	b.n	234a <gpio_nrfx_pin_interrupt_configure+0x4a>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
    236c:	22c0      	movs	r2, #192	; 0xc0
    236e:	2303      	movs	r3, #3
    2370:	04d2      	lsls	r2, r2, #19
    2372:	4296      	cmp	r6, r2
    2374:	d005      	beq.n	2382 <gpio_nrfx_pin_interrupt_configure+0x82>
    2376:	23fe      	movs	r3, #254	; 0xfe
    2378:	061b      	lsls	r3, r3, #24
    237a:	18f3      	adds	r3, r6, r3
    237c:	425a      	negs	r2, r3
    237e:	4153      	adcs	r3, r2
    2380:	3301      	adds	r3, #1
	nrfx_gpiote_trigger_config_t trigger_config = {
    2382:	702b      	strb	r3, [r5, #0]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
    2384:	9b00      	ldr	r3, [sp, #0]
    2386:	9a01      	ldr	r2, [sp, #4]
    2388:	689b      	ldr	r3, [r3, #8]
    238a:	40d3      	lsrs	r3, r2
    238c:	2201      	movs	r2, #1
    238e:	4213      	tst	r3, r2
    2390:	d1dc      	bne.n	234c <gpio_nrfx_pin_interrupt_configure+0x4c>
    2392:	23a0      	movs	r3, #160	; 0xa0
    2394:	045b      	lsls	r3, r3, #17
    2396:	429f      	cmp	r7, r3
    2398:	d1d8      	bne.n	234c <gpio_nrfx_pin_interrupt_configure+0x4c>
}
#endif

NRF_STATIC_INLINE bool nrf_gpio_pin_present_check(uint32_t pin_number)
{
    uint32_t port = pin_number >> 5;
    239a:	0963      	lsrs	r3, r4, #5
    uint32_t mask = 0;

    switch (port)
    239c:	d10c      	bne.n	23b8 <gpio_nrfx_pin_interrupt_configure+0xb8>
#endif // defined(NRF52820_XXAA) && defined(DEVELOP_IN_NRF52833)
#endif

    pin_number &= 0x1F;

    return (mask & (1UL << pin_number)) ? true : false;
    239e:	3b01      	subs	r3, #1
    23a0:	40e3      	lsrs	r3, r4
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
    23a2:	4213      	tst	r3, r2
    23a4:	d113      	bne.n	23ce <gpio_nrfx_pin_interrupt_configure+0xce>
    23a6:	4c1b      	ldr	r4, [pc, #108]	; (2414 <gpio_nrfx_pin_interrupt_configure+0x114>)
    23a8:	491b      	ldr	r1, [pc, #108]	; (2418 <gpio_nrfx_pin_interrupt_configure+0x118>)
    23aa:	0022      	movs	r2, r4
    23ac:	481b      	ldr	r0, [pc, #108]	; (241c <gpio_nrfx_pin_interrupt_configure+0x11c>)
    23ae:	4b1c      	ldr	r3, [pc, #112]	; (2420 <gpio_nrfx_pin_interrupt_configure+0x120>)
    23b0:	f003 fa9a 	bl	58e8 <assert_print>
    23b4:	491a      	ldr	r1, [pc, #104]	; (2420 <gpio_nrfx_pin_interrupt_configure+0x120>)
    23b6:	e007      	b.n	23c8 <gpio_nrfx_pin_interrupt_configure+0xc8>
            NRFX_ASSERT(0);
    23b8:	4c16      	ldr	r4, [pc, #88]	; (2414 <gpio_nrfx_pin_interrupt_configure+0x114>)
    23ba:	491a      	ldr	r1, [pc, #104]	; (2424 <gpio_nrfx_pin_interrupt_configure+0x124>)
    23bc:	0022      	movs	r2, r4
    23be:	4817      	ldr	r0, [pc, #92]	; (241c <gpio_nrfx_pin_interrupt_configure+0x11c>)
    23c0:	4b19      	ldr	r3, [pc, #100]	; (2428 <gpio_nrfx_pin_interrupt_configure+0x128>)
    23c2:	f003 fa91 	bl	58e8 <assert_print>
    23c6:	4918      	ldr	r1, [pc, #96]	; (2428 <gpio_nrfx_pin_interrupt_configure+0x128>)
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
    23c8:	0020      	movs	r0, r4
    23ca:	f003 fa89 	bl	58e0 <assert_post_action>
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = NRF_PIN_NUMBER_TO_PIN(pin_number);
    23ce:	231f      	movs	r3, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    23d0:	21a0      	movs	r1, #160	; 0xa0
    *p_pin = NRF_PIN_NUMBER_TO_PIN(pin_number);
    23d2:	4023      	ands	r3, r4
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    23d4:	33c1      	adds	r3, #193	; 0xc1
    23d6:	33ff      	adds	r3, #255	; 0xff
    23d8:	009b      	lsls	r3, r3, #2
    23da:	05c9      	lsls	r1, r1, #23
    23dc:	585b      	ldr	r3, [r3, r1]
	    (mode == GPIO_INT_MODE_EDGE) &&
    23de:	4213      	tst	r3, r2
    23e0:	d1b4      	bne.n	234c <gpio_nrfx_pin_interrupt_configure+0x4c>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
    23e2:	ab02      	add	r3, sp, #8
    23e4:	1dde      	adds	r6, r3, #7
    23e6:	0031      	movs	r1, r6
    23e8:	0020      	movs	r0, r4
    23ea:	f000 ff83 	bl	32f4 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
    23ee:	4b0f      	ldr	r3, [pc, #60]	; (242c <gpio_nrfx_pin_interrupt_configure+0x12c>)
    23f0:	4298      	cmp	r0, r3
    23f2:	d001      	beq.n	23f8 <gpio_nrfx_pin_interrupt_configure+0xf8>
		trigger_config.p_in_channel = &ch;
    23f4:	606e      	str	r6, [r5, #4]
    23f6:	e7a9      	b.n	234c <gpio_nrfx_pin_interrupt_configure+0x4c>
			err = nrfx_gpiote_channel_alloc(&ch);
    23f8:	0030      	movs	r0, r6
    23fa:	f000 fff7 	bl	33ec <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
    23fe:	4b04      	ldr	r3, [pc, #16]	; (2410 <gpio_nrfx_pin_interrupt_configure+0x110>)
    2400:	4298      	cmp	r0, r3
    2402:	d0f7      	beq.n	23f4 <gpio_nrfx_pin_interrupt_configure+0xf4>
				return -ENOMEM;
    2404:	200c      	movs	r0, #12
		return -EINVAL;
    2406:	4240      	negs	r0, r0
    2408:	e78e      	b.n	2328 <gpio_nrfx_pin_interrupt_configure+0x28>
    240a:	2016      	movs	r0, #22
    240c:	e7fb      	b.n	2406 <gpio_nrfx_pin_interrupt_configure+0x106>
    240e:	46c0      	nop			; (mov r8, r8)
    2410:	0bad0000 	.word	0x0bad0000
    2414:	00006a09 	.word	0x00006a09
    2418:	00006a3c 	.word	0x00006a3c
    241c:	00006347 	.word	0x00006347
    2420:	0000032f 	.word	0x0000032f
    2424:	00006f16 	.word	0x00006f16
    2428:	00000516 	.word	0x00000516
    242c:	0bad0004 	.word	0x0bad0004

00002430 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
    2430:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
    2432:	f000 ffc9 	bl	33c8 <nrfx_gpiote_is_init>
    2436:	1e04      	subs	r4, r0, #0
    2438:	d10d      	bne.n	2456 <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
    243a:	f000 ff87 	bl	334c <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
    243e:	4b08      	ldr	r3, [pc, #32]	; (2460 <gpio_nrfx_init+0x30>)
    2440:	4298      	cmp	r0, r3
    2442:	d10a      	bne.n	245a <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
    2444:	0021      	movs	r1, r4
    2446:	4807      	ldr	r0, [pc, #28]	; (2464 <gpio_nrfx_init+0x34>)
    2448:	f000 ff4e 	bl	32e8 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    244c:	0022      	movs	r2, r4
    244e:	2101      	movs	r1, #1
    2450:	2006      	movs	r0, #6
    2452:	f7fe ffe1 	bl	1418 <z_arm_irq_priority_set>
		return 0;
    2456:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
    2458:	bd10      	pop	{r4, pc}
		return -EIO;
    245a:	2005      	movs	r0, #5
    245c:	4240      	negs	r0, r0
    245e:	e7fb      	b.n	2458 <gpio_nrfx_init+0x28>
    2460:	0bad0000 	.word	0x0bad0000
    2464:	00002469 	.word	0x00002469

00002468 <nrfx_gpio_handler>:
{
    2468:	b570      	push	{r4, r5, r6, lr}

    return NRF_PIN_NUMBER_TO_PORT(pin_number);
    246a:	0943      	lsrs	r3, r0, #5
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    246c:	d108      	bne.n	2480 <nrfx_gpio_handler+0x18>
	return list->head;
    246e:	4b14      	ldr	r3, [pc, #80]	; (24c0 <nrfx_gpio_handler+0x58>)
    2470:	6859      	ldr	r1, [r3, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    2472:	2900      	cmp	r1, #0
    2474:	d004      	beq.n	2480 <nrfx_gpio_handler+0x18>
	gpio_fire_callbacks(list, port, BIT(pin));
    2476:	2501      	movs	r5, #1
    2478:	4085      	lsls	r5, r0
	return node->next;
    247a:	680c      	ldr	r4, [r1, #0]
    247c:	2900      	cmp	r1, #0
    247e:	d100      	bne.n	2482 <nrfx_gpio_handler+0x1a>
}
    2480:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->pin_mask & pins) {
    2482:	688b      	ldr	r3, [r1, #8]
    2484:	001a      	movs	r2, r3
    2486:	402a      	ands	r2, r5
    2488:	422b      	tst	r3, r5
    248a:	d012      	beq.n	24b2 <nrfx_gpio_handler+0x4a>
			__ASSERT(cb->handler, "No callback handler!");
    248c:	684b      	ldr	r3, [r1, #4]
    248e:	2b00      	cmp	r3, #0
    2490:	d10d      	bne.n	24ae <nrfx_gpio_handler+0x46>
    2492:	4c0c      	ldr	r4, [pc, #48]	; (24c4 <nrfx_gpio_handler+0x5c>)
    2494:	490c      	ldr	r1, [pc, #48]	; (24c8 <nrfx_gpio_handler+0x60>)
    2496:	0022      	movs	r2, r4
    2498:	480c      	ldr	r0, [pc, #48]	; (24cc <nrfx_gpio_handler+0x64>)
    249a:	334d      	adds	r3, #77	; 0x4d
    249c:	f003 fa24 	bl	58e8 <assert_print>
    24a0:	480b      	ldr	r0, [pc, #44]	; (24d0 <nrfx_gpio_handler+0x68>)
    24a2:	f003 fa21 	bl	58e8 <assert_print>
    24a6:	214d      	movs	r1, #77	; 0x4d
    24a8:	0020      	movs	r0, r4
    24aa:	f003 fa19 	bl	58e0 <assert_post_action>
			cb->handler(port, cb, cb->pin_mask & pins);
    24ae:	4809      	ldr	r0, [pc, #36]	; (24d4 <nrfx_gpio_handler+0x6c>)
    24b0:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    24b2:	1e23      	subs	r3, r4, #0
    24b4:	d000      	beq.n	24b8 <nrfx_gpio_handler+0x50>
    24b6:	6823      	ldr	r3, [r4, #0]
    24b8:	0021      	movs	r1, r4
    24ba:	001c      	movs	r4, r3
    24bc:	e7de      	b.n	247c <nrfx_gpio_handler+0x14>
    24be:	46c0      	nop			; (mov r8, r8)
    24c0:	20000318 	.word	0x20000318
    24c4:	0000698c 	.word	0x0000698c
    24c8:	00006a5f 	.word	0x00006a5f
    24cc:	00006347 	.word	0x00006347
    24d0:	000069f2 	.word	0x000069f2
    24d4:	00005d64 	.word	0x00005d64

000024d8 <gpio_nrfx_pin_configure>:
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    24d8:	231f      	movs	r3, #31
{
    24da:	b5f0      	push	{r4, r5, r6, r7, lr}
	return port->config;
    24dc:	6847      	ldr	r7, [r0, #4]
{
    24de:	b087      	sub	sp, #28
    24e0:	9101      	str	r1, [sp, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    24e2:	7b3d      	ldrb	r5, [r7, #12]
    24e4:	400b      	ands	r3, r1
    24e6:	016d      	lsls	r5, r5, #5
    24e8:	431d      	orrs	r5, r3
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
    24ea:	ab02      	add	r3, sp, #8
    24ec:	1cd9      	adds	r1, r3, #3
    24ee:	0028      	movs	r0, r5
{
    24f0:	0014      	movs	r4, r2
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
    24f2:	f000 feff 	bl	32f4 <nrfx_gpiote_channel_get>
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
    24f6:	23c0      	movs	r3, #192	; 0xc0
    24f8:	029b      	lsls	r3, r3, #10
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
    24fa:	0006      	movs	r6, r0
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
    24fc:	421c      	tst	r4, r3
    24fe:	d116      	bne.n	252e <gpio_nrfx_pin_configure+0x56>
		(void)nrfx_gpiote_pin_uninit(abs_pin);
    2500:	0028      	movs	r0, r5
    2502:	f001 f811 	bl	3528 <nrfx_gpiote_pin_uninit>
		if (free_ch) {
    2506:	4b4a      	ldr	r3, [pc, #296]	; (2630 <gpio_nrfx_pin_configure+0x158>)
    2508:	429e      	cmp	r6, r3
    250a:	d162      	bne.n	25d2 <gpio_nrfx_pin_configure+0xfa>
			err = nrfx_gpiote_channel_free(ch);
    250c:	ab02      	add	r3, sp, #8
    250e:	78d8      	ldrb	r0, [r3, #3]
    2510:	f000 ff62 	bl	33d8 <nrfx_gpiote_channel_free>
			__ASSERT_NO_MSG(err == NRFX_SUCCESS);
    2514:	42b0      	cmp	r0, r6
    2516:	d05c      	beq.n	25d2 <gpio_nrfx_pin_configure+0xfa>
    2518:	4c46      	ldr	r4, [pc, #280]	; (2634 <gpio_nrfx_pin_configure+0x15c>)
    251a:	4947      	ldr	r1, [pc, #284]	; (2638 <gpio_nrfx_pin_configure+0x160>)
    251c:	236a      	movs	r3, #106	; 0x6a
    251e:	0022      	movs	r2, r4
    2520:	4846      	ldr	r0, [pc, #280]	; (263c <gpio_nrfx_pin_configure+0x164>)
    2522:	f003 f9e1 	bl	58e8 <assert_print>
    2526:	216a      	movs	r1, #106	; 0x6a
		__ASSERT_NO_MSG(err == NRFX_SUCCESS);
    2528:	0020      	movs	r0, r4
    252a:	f003 f9d9 	bl	58e0 <assert_post_action>
	nrfx_gpiote_trigger_config_t trigger_config = {
    252e:	2208      	movs	r2, #8
    2530:	2100      	movs	r1, #0
    2532:	a804      	add	r0, sp, #16
    2534:	f003 fa40 	bl	59b8 <memset>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    2538:	2300      	movs	r3, #0
    253a:	0028      	movs	r0, r5
    253c:	0019      	movs	r1, r3
    253e:	aa04      	add	r2, sp, #16
    2540:	f000 fd88 	bl	3054 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    2544:	4b3a      	ldr	r3, [pc, #232]	; (2630 <gpio_nrfx_pin_configure+0x158>)
    2546:	4298      	cmp	r0, r3
    2548:	d003      	beq.n	2552 <gpio_nrfx_pin_configure+0x7a>
		return NRF_GPIO_PIN_PULLUP;
    254a:	2016      	movs	r0, #22
    254c:	4240      	negs	r0, r0
}
    254e:	b007      	add	sp, #28
    2550:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (free_ch) {
    2552:	4286      	cmp	r6, r0
    2554:	d10e      	bne.n	2574 <gpio_nrfx_pin_configure+0x9c>
		err = nrfx_gpiote_channel_free(ch);
    2556:	ab02      	add	r3, sp, #8
    2558:	78d8      	ldrb	r0, [r3, #3]
    255a:	f000 ff3d 	bl	33d8 <nrfx_gpiote_channel_free>
		__ASSERT_NO_MSG(err == NRFX_SUCCESS);
    255e:	42b0      	cmp	r0, r6
    2560:	d008      	beq.n	2574 <gpio_nrfx_pin_configure+0x9c>
    2562:	4c34      	ldr	r4, [pc, #208]	; (2634 <gpio_nrfx_pin_configure+0x15c>)
    2564:	4934      	ldr	r1, [pc, #208]	; (2638 <gpio_nrfx_pin_configure+0x160>)
    2566:	237c      	movs	r3, #124	; 0x7c
    2568:	0022      	movs	r2, r4
    256a:	4834      	ldr	r0, [pc, #208]	; (263c <gpio_nrfx_pin_configure+0x164>)
    256c:	f003 f9bc 	bl	58e8 <assert_print>
    2570:	217c      	movs	r1, #124	; 0x7c
    2572:	e7d9      	b.n	2528 <gpio_nrfx_pin_configure+0x50>
	if (flags & GPIO_OUTPUT) {
    2574:	03a3      	lsls	r3, r4, #14
    2576:	d54e      	bpl.n	2616 <gpio_nrfx_pin_configure+0x13e>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
    2578:	2283      	movs	r2, #131	; 0x83
    257a:	4b31      	ldr	r3, [pc, #196]	; (2640 <gpio_nrfx_pin_configure+0x168>)
    257c:	0052      	lsls	r2, r2, #1
    257e:	4023      	ands	r3, r4
    2580:	4293      	cmp	r3, r2
    2582:	d03a      	beq.n	25fa <gpio_nrfx_pin_configure+0x122>
    2584:	d82d      	bhi.n	25e2 <gpio_nrfx_pin_configure+0x10a>
    2586:	2b06      	cmp	r3, #6
    2588:	d039      	beq.n	25fe <gpio_nrfx_pin_configure+0x126>
    258a:	d824      	bhi.n	25d6 <gpio_nrfx_pin_configure+0xfe>
    258c:	2b00      	cmp	r3, #0
    258e:	d036      	beq.n	25fe <gpio_nrfx_pin_configure+0x126>
		*drive = NRF_GPIO_PIN_D0S1;
    2590:	3a03      	subs	r2, #3
    2592:	3aff      	subs	r2, #255	; 0xff
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
    2594:	2b02      	cmp	r3, #2
    2596:	d1d8      	bne.n	254a <gpio_nrfx_pin_configure+0x72>
		nrfx_gpiote_output_config_t output_config = {
    2598:	a903      	add	r1, sp, #12
    259a:	700a      	strb	r2, [r1, #0]
				NRF_GPIO_PIN_INPUT_CONNECT :
    259c:	2201      	movs	r2, #1
    259e:	0010      	movs	r0, r2
    25a0:	0c23      	lsrs	r3, r4, #16
    25a2:	4398      	bics	r0, r3
		nrfx_gpiote_output_config_t output_config = {
    25a4:	7048      	strb	r0, [r1, #1]
		return NRF_GPIO_PIN_PULLUP;
    25a6:	2303      	movs	r3, #3
	if (flags & GPIO_PULL_UP) {
    25a8:	06e0      	lsls	r0, r4, #27
    25aa:	d401      	bmi.n	25b0 <gpio_nrfx_pin_configure+0xd8>
	} else if (flags & GPIO_PULL_DOWN) {
    25ac:	0963      	lsrs	r3, r4, #5
    25ae:	4013      	ands	r3, r2
		nrfx_gpiote_output_config_t output_config = {
    25b0:	708b      	strb	r3, [r1, #2]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
    25b2:	0323      	lsls	r3, r4, #12
    25b4:	d527      	bpl.n	2606 <gpio_nrfx_pin_configure+0x12e>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
    25b6:	2301      	movs	r3, #1
    25b8:	9a01      	ldr	r2, [sp, #4]
    25ba:	6878      	ldr	r0, [r7, #4]
    25bc:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
    25be:	22a1      	movs	r2, #161	; 0xa1
    25c0:	00d2      	lsls	r2, r2, #3
    p_reg->OUTCLR = clr_mask;
    25c2:	5083      	str	r3, [r0, r2]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
    25c4:	2200      	movs	r2, #0
    25c6:	0028      	movs	r0, r5
    25c8:	f000 fe12 	bl	31f0 <nrfx_gpiote_output_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    25cc:	4b18      	ldr	r3, [pc, #96]	; (2630 <gpio_nrfx_pin_configure+0x158>)
    25ce:	4298      	cmp	r0, r3
    25d0:	d1bb      	bne.n	254a <gpio_nrfx_pin_configure+0x72>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    25d2:	2000      	movs	r0, #0
    25d4:	e7bb      	b.n	254e <gpio_nrfx_pin_configure+0x76>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
    25d6:	2180      	movs	r1, #128	; 0x80
		*drive = NRF_GPIO_PIN_H0S1;
    25d8:	2201      	movs	r2, #1
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
    25da:	0049      	lsls	r1, r1, #1
    25dc:	428b      	cmp	r3, r1
    25de:	d0db      	beq.n	2598 <gpio_nrfx_pin_configure+0xc0>
    25e0:	e7b3      	b.n	254a <gpio_nrfx_pin_configure+0x72>
    25e2:	4a18      	ldr	r2, [pc, #96]	; (2644 <gpio_nrfx_pin_configure+0x16c>)
    25e4:	4293      	cmp	r3, r2
    25e6:	d00c      	beq.n	2602 <gpio_nrfx_pin_configure+0x12a>
    25e8:	21c0      	movs	r1, #192	; 0xc0
    25ea:	2203      	movs	r2, #3
    25ec:	0089      	lsls	r1, r1, #2
    25ee:	428b      	cmp	r3, r1
    25f0:	d0d2      	beq.n	2598 <gpio_nrfx_pin_configure+0xc0>
    25f2:	3901      	subs	r1, #1
    25f4:	39ff      	subs	r1, #255	; 0xff
		*drive = NRF_GPIO_PIN_S0H1;
    25f6:	3a01      	subs	r2, #1
    25f8:	e7f0      	b.n	25dc <gpio_nrfx_pin_configure+0x104>
		*drive = NRF_GPIO_PIN_H0D1;
    25fa:	2207      	movs	r2, #7
    25fc:	e7cc      	b.n	2598 <gpio_nrfx_pin_configure+0xc0>
		*drive = NRF_GPIO_PIN_S0S1;
    25fe:	001a      	movs	r2, r3
    2600:	e7ca      	b.n	2598 <gpio_nrfx_pin_configure+0xc0>
		*drive = NRF_GPIO_PIN_D0H1;
    2602:	2205      	movs	r2, #5
    2604:	e7c8      	b.n	2598 <gpio_nrfx_pin_configure+0xc0>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
    2606:	0364      	lsls	r4, r4, #13
    2608:	d5dc      	bpl.n	25c4 <gpio_nrfx_pin_configure+0xec>
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
    260a:	2301      	movs	r3, #1
    260c:	9a01      	ldr	r2, [sp, #4]
    260e:	6878      	ldr	r0, [r7, #4]
    2610:	4093      	lsls	r3, r2
    2612:	4a0d      	ldr	r2, [pc, #52]	; (2648 <gpio_nrfx_pin_configure+0x170>)
    2614:	e7d5      	b.n	25c2 <gpio_nrfx_pin_configure+0xea>
		return NRF_GPIO_PIN_PULLUP;
    2616:	2303      	movs	r3, #3
	if (flags & GPIO_PULL_UP) {
    2618:	06e2      	lsls	r2, r4, #27
    261a:	d401      	bmi.n	2620 <gpio_nrfx_pin_configure+0x148>
	} else if (flags & GPIO_PULL_DOWN) {
    261c:	06a4      	lsls	r4, r4, #26
    261e:	0fe3      	lsrs	r3, r4, #31
	nrfx_gpiote_input_config_t input_config = {
    2620:	a903      	add	r1, sp, #12
    2622:	700b      	strb	r3, [r1, #0]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    2624:	2300      	movs	r3, #0
    2626:	0028      	movs	r0, r5
    2628:	001a      	movs	r2, r3
    262a:	f000 fd13 	bl	3054 <nrfx_gpiote_input_configure>
    262e:	e7cd      	b.n	25cc <gpio_nrfx_pin_configure+0xf4>
    2630:	0bad0000 	.word	0x0bad0000
    2634:	00006a6b 	.word	0x00006a6b
    2638:	00006a97 	.word	0x00006a97
    263c:	00006347 	.word	0x00006347
    2640:	00000306 	.word	0x00000306
    2644:	00000202 	.word	0x00000202
    2648:	0000050c 	.word	0x0000050c

0000264c <nrf_gpio_pin_port_decode>:
{
    264c:	b510      	push	{r4, lr}
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
    264e:	6802      	ldr	r2, [r0, #0]
    uint32_t port = pin_number >> 5;
    2650:	0953      	lsrs	r3, r2, #5
    switch (port)
    2652:	d10c      	bne.n	266e <nrf_gpio_pin_port_decode+0x22>
    return (mask & (1UL << pin_number)) ? true : false;
    2654:	3b01      	subs	r3, #1
    2656:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
    2658:	07db      	lsls	r3, r3, #31
    265a:	d413      	bmi.n	2684 <nrf_gpio_pin_port_decode+0x38>
    265c:	4c0b      	ldr	r4, [pc, #44]	; (268c <nrf_gpio_pin_port_decode+0x40>)
    265e:	490c      	ldr	r1, [pc, #48]	; (2690 <nrf_gpio_pin_port_decode+0x44>)
    2660:	0022      	movs	r2, r4
    2662:	480c      	ldr	r0, [pc, #48]	; (2694 <nrf_gpio_pin_port_decode+0x48>)
    2664:	4b0c      	ldr	r3, [pc, #48]	; (2698 <nrf_gpio_pin_port_decode+0x4c>)
    2666:	f003 f93f 	bl	58e8 <assert_print>
    266a:	490b      	ldr	r1, [pc, #44]	; (2698 <nrf_gpio_pin_port_decode+0x4c>)
    266c:	e007      	b.n	267e <nrf_gpio_pin_port_decode+0x32>
            NRFX_ASSERT(0);
    266e:	4c07      	ldr	r4, [pc, #28]	; (268c <nrf_gpio_pin_port_decode+0x40>)
    2670:	490a      	ldr	r1, [pc, #40]	; (269c <nrf_gpio_pin_port_decode+0x50>)
    2672:	0022      	movs	r2, r4
    2674:	4807      	ldr	r0, [pc, #28]	; (2694 <nrf_gpio_pin_port_decode+0x48>)
    2676:	4b0a      	ldr	r3, [pc, #40]	; (26a0 <nrf_gpio_pin_port_decode+0x54>)
    2678:	f003 f936 	bl	58e8 <assert_print>
    267c:	4908      	ldr	r1, [pc, #32]	; (26a0 <nrf_gpio_pin_port_decode+0x54>)
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
    267e:	0020      	movs	r0, r4
    2680:	f003 f92e 	bl	58e0 <assert_post_action>
}
    2684:	20a0      	movs	r0, #160	; 0xa0
    2686:	05c0      	lsls	r0, r0, #23
    2688:	bd10      	pop	{r4, pc}
    268a:	46c0      	nop			; (mov r8, r8)
    268c:	00006a09 	.word	0x00006a09
    2690:	00006a3c 	.word	0x00006a3c
    2694:	00006347 	.word	0x00006347
    2698:	0000032f 	.word	0x0000032f
    269c:	00006f16 	.word	0x00006f16
    26a0:	00000516 	.word	0x00000516

000026a4 <pinctrl_configure_pins>:
#define NRF_PSEL_QSPI(reg, line) ((NRF_QSPI_Type *)reg)->PSEL.line
#endif

int pinctrl_configure_pins(const pinctrl_soc_pin_t *pins, uint8_t pin_cnt,
			   uintptr_t reg)
{
    26a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    26a6:	0006      	movs	r6, r0
    26a8:	0089      	lsls	r1, r1, #2
    26aa:	b087      	sub	sp, #28
    26ac:	1843      	adds	r3, r0, r1
    26ae:	9200      	str	r2, [sp, #0]
    26b0:	9303      	str	r3, [sp, #12]
	for (uint8_t i = 0U; i < pin_cnt; i++) {
    26b2:	9b03      	ldr	r3, [sp, #12]
    26b4:	42b3      	cmp	r3, r6
    26b6:	d102      	bne.n	26be <pinctrl_configure_pins+0x1a>
			nrf_gpio_cfg(pin, dir, input, NRF_GET_PULL(pins[i]),
				     drive, NRF_GPIO_PIN_NOSENSE);
		}
	}

	return 0;
    26b8:	2000      	movs	r0, #0
}
    26ba:	b007      	add	sp, #28
    26bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uint32_t psel = NRF_GET_PIN(pins[i]);
    26be:	247f      	movs	r4, #127	; 0x7f
		nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
    26c0:	6833      	ldr	r3, [r6, #0]
    26c2:	9301      	str	r3, [sp, #4]
		uint32_t psel = NRF_GET_PIN(pins[i]);
    26c4:	401c      	ands	r4, r3
		if (psel == NRF_PIN_DISCONNECTED) {
    26c6:	2c7f      	cmp	r4, #127	; 0x7f
    26c8:	d100      	bne.n	26cc <pinctrl_configure_pins+0x28>
			psel = PSEL_DISCONNECTED;
    26ca:	3c80      	subs	r4, #128	; 0x80
		switch (NRF_GET_FUN(pins[i])) {
    26cc:	9b01      	ldr	r3, [sp, #4]
    26ce:	0c18      	lsrs	r0, r3, #16
    26d0:	2803      	cmp	r0, #3
    26d2:	d841      	bhi.n	2758 <pinctrl_configure_pins+0xb4>
    26d4:	f7fd fce8 	bl	a8 <__gnu_thumb1_case_uqi>
    26d8:	3d3a3202 	.word	0x3d3a3202
			NRF_PSEL_UART(reg, TXD) = psel;
    26dc:	4b20      	ldr	r3, [pc, #128]	; (2760 <pinctrl_configure_pins+0xbc>)
			NRF_PSEL_UART(reg, RTS) = psel;
    26de:	9a00      	ldr	r2, [sp, #0]
    26e0:	50d4      	str	r4, [r2, r3]
		if (psel != PSEL_DISCONNECTED) {
    26e2:	1c63      	adds	r3, r4, #1
    26e4:	d030      	beq.n	2748 <pinctrl_configure_pins+0xa4>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    26e6:	2701      	movs	r7, #1
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    26e8:	a805      	add	r0, sp, #20
    26ea:	9405      	str	r4, [sp, #20]
    26ec:	f7ff ffae 	bl	264c <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    26f0:	003a      	movs	r2, r7
    p_reg->OUTSET = set_mask;
    26f2:	23a1      	movs	r3, #161	; 0xa1
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    26f4:	40a2      	lsls	r2, r4
    p_reg->OUTSET = set_mask;
    26f6:	00db      	lsls	r3, r3, #3
    26f8:	50c2      	str	r2, [r0, r3]
			if (NRF_GET_LP(pins[i]) == NRF_LP_ENABLE) {
    26fa:	6835      	ldr	r5, [r6, #0]
    26fc:	9702      	str	r7, [sp, #8]
    26fe:	04ab      	lsls	r3, r5, #18
    2700:	d502      	bpl.n	2708 <pinctrl_configure_pins+0x64>
				input = NRF_GPIO_PIN_INPUT_DISCONNECT;
    2702:	2301      	movs	r3, #1
				dir = NRF_GPIO_PIN_DIR_INPUT;
    2704:	2700      	movs	r7, #0
				input = NRF_GPIO_PIN_INPUT_DISCONNECT;
    2706:	9302      	str	r3, [sp, #8]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    2708:	a805      	add	r0, sp, #20
    270a:	9405      	str	r4, [sp, #20]
    270c:	f7ff ff9e 	bl	264c <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number];
    2710:	21e0      	movs	r1, #224	; 0xe0
		nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
    2712:	9b01      	ldr	r3, [sp, #4]
			nrf_gpio_cfg(pin, dir, input, NRF_GET_PULL(pins[i]),
    2714:	05ed      	lsls	r5, r5, #23
		nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
    2716:	04db      	lsls	r3, r3, #19
    2718:	00a4      	lsls	r4, r4, #2
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)    |
    271a:	0fad      	lsrs	r5, r5, #30
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)  |
    271c:	0f1b      	lsrs	r3, r3, #28
    271e:	1900      	adds	r0, r0, r4
    uint32_t cnf = reg->PIN_CNF[pin_number];
    2720:	00c9      	lsls	r1, r1, #3
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)  |
    2722:	021b      	lsls	r3, r3, #8
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)    |
    2724:	00ad      	lsls	r5, r5, #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
    2726:	5842      	ldr	r2, [r0, r1]
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)      |
    2728:	431d      	orrs	r5, r3
    cnf &= ~to_update;
    272a:	4b0e      	ldr	r3, [pc, #56]	; (2764 <pinctrl_configure_pins+0xc0>)
    272c:	433d      	orrs	r5, r7
    272e:	401a      	ands	r2, r3
           ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)  |
    2730:	9b02      	ldr	r3, [sp, #8]
    2732:	4315      	orrs	r5, r2
    2734:	005a      	lsls	r2, r3, #1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)      |
    2736:	432a      	orrs	r2, r5
    reg->PIN_CNF[pin_number] = cnf;
    2738:	5042      	str	r2, [r0, r1]
    273a:	e005      	b.n	2748 <pinctrl_configure_pins+0xa4>
			NRF_PSEL_UART(reg, RXD) = psel;
    273c:	4b0a      	ldr	r3, [pc, #40]	; (2768 <pinctrl_configure_pins+0xc4>)
    273e:	9a00      	ldr	r2, [sp, #0]
			dir = NRF_GPIO_PIN_DIR_INPUT;
    2740:	2700      	movs	r7, #0
			NRF_PSEL_UART(reg, RXD) = psel;
    2742:	50d4      	str	r4, [r2, r3]
		if (psel != PSEL_DISCONNECTED) {
    2744:	1c63      	adds	r3, r4, #1
    2746:	d1d8      	bne.n	26fa <pinctrl_configure_pins+0x56>
	for (uint8_t i = 0U; i < pin_cnt; i++) {
    2748:	3604      	adds	r6, #4
    274a:	e7b2      	b.n	26b2 <pinctrl_configure_pins+0xe>
			NRF_PSEL_UART(reg, RTS) = psel;
    274c:	23a1      	movs	r3, #161	; 0xa1
    274e:	00db      	lsls	r3, r3, #3
    2750:	e7c5      	b.n	26de <pinctrl_configure_pins+0x3a>
			NRF_PSEL_UART(reg, CTS) = psel;
    2752:	23a2      	movs	r3, #162	; 0xa2
    2754:	00db      	lsls	r3, r3, #3
    2756:	e7f2      	b.n	273e <pinctrl_configure_pins+0x9a>
		switch (NRF_GET_FUN(pins[i])) {
    2758:	2086      	movs	r0, #134	; 0x86
    275a:	4240      	negs	r0, r0
    275c:	e7ad      	b.n	26ba <pinctrl_configure_pins+0x16>
    275e:	46c0      	nop			; (mov r8, r8)
    2760:	0000050c 	.word	0x0000050c
    2764:	fffcf8f0 	.word	0xfffcf8f0
    2768:	00000514 	.word	0x00000514

0000276c <uart_nrfx_poll_in>:
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE bool nrf_uart_event_check(NRF_UART_Type const * p_reg, nrf_uart_event_t event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    276c:	4b07      	ldr	r3, [pc, #28]	; (278c <uart_nrfx_poll_in+0x20>)
    276e:	681a      	ldr	r2, [r3, #0]
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */

static int uart_nrfx_poll_in(const struct device *dev, unsigned char *c)
{
	if (!nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY)) {
    2770:	2a00      	cmp	r2, #0
    2772:	d007      	beq.n	2784 <uart_nrfx_poll_in+0x18>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2774:	2000      	movs	r0, #0
    2776:	6018      	str	r0, [r3, #0]
    nrf_uart_hwfc_pins_set(p_reg, NRF_UART_PSEL_DISCONNECTED, NRF_UART_PSEL_DISCONNECTED);
}

NRF_STATIC_INLINE uint8_t nrf_uart_rxd_get(NRF_UART_Type const * p_reg)
{
    return (uint8_t)p_reg->RXD;
    2778:	23a3      	movs	r3, #163	; 0xa3
    277a:	4a05      	ldr	r2, [pc, #20]	; (2790 <uart_nrfx_poll_in+0x24>)
    277c:	00db      	lsls	r3, r3, #3
    277e:	58d3      	ldr	r3, [r2, r3]
    2780:	700b      	strb	r3, [r1, #0]

	/* got a character */
	*c = nrf_uart_rxd_get(uart0_addr);

	return 0;
}
    2782:	4770      	bx	lr
		return -1;
    2784:	2001      	movs	r0, #1
    2786:	4240      	negs	r0, r0
    2788:	e7fb      	b.n	2782 <uart_nrfx_poll_in+0x16>
    278a:	46c0      	nop			; (mov r8, r8)
    278c:	40002108 	.word	0x40002108
    2790:	40002000 	.word	0x40002000

00002794 <uart_nrfx_err_check>:
    uint32_t errsrc_mask = p_reg->ERRORSRC;
    2794:	2390      	movs	r3, #144	; 0x90
    2796:	4a02      	ldr	r2, [pc, #8]	; (27a0 <uart_nrfx_err_check+0xc>)
    2798:	00db      	lsls	r3, r3, #3
    279a:	58d0      	ldr	r0, [r2, r3]
    p_reg->ERRORSRC = errsrc_mask;
    279c:	50d0      	str	r0, [r2, r3]
/** Console I/O function */
static int uart_nrfx_err_check(const struct device *dev)
{
	/* register bitfields maps to the defines in uart.h */
	return nrf_uart_errorsrc_get_and_clear(uart0_addr);
}
    279e:	4770      	bx	lr
    27a0:	40002000 	.word	0x40002000

000027a4 <uart_nrfx_configure>:

static int uart_nrfx_configure(const struct device *dev,
			       const struct uart_config *cfg)
{
    27a4:	b530      	push	{r4, r5, lr}
		break;
	default:
		return -ENOTSUP;
	}
#else
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
    27a6:	794b      	ldrb	r3, [r1, #5]
    27a8:	2b01      	cmp	r3, #1
    27aa:	d139      	bne.n	2820 <uart_nrfx_configure+0x7c>
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    27ac:	798b      	ldrb	r3, [r1, #6]
    27ae:	2b03      	cmp	r3, #3
    27b0:	d136      	bne.n	2820 <uart_nrfx_configure+0x7c>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
    27b2:	79cb      	ldrb	r3, [r1, #7]
    27b4:	2b00      	cmp	r3, #0
    27b6:	d133      	bne.n	2820 <uart_nrfx_configure+0x7c>
	}

#if defined(UART_CONFIG_PARITYTYPE_Msk)
	uart_cfg.paritytype = NRF_UART_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
    27b8:	790c      	ldrb	r4, [r1, #4]
    27ba:	2c00      	cmp	r4, #0
    27bc:	d002      	beq.n	27c4 <uart_nrfx_configure+0x20>
    27be:	2c02      	cmp	r4, #2
    27c0:	d12e      	bne.n	2820 <uart_nrfx_configure+0x7c>
    27c2:	340c      	adds	r4, #12
	switch (baudrate) {
    27c4:	2296      	movs	r2, #150	; 0x96
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
    27c6:	680b      	ldr	r3, [r1, #0]
	switch (baudrate) {
    27c8:	0212      	lsls	r2, r2, #8
    27ca:	4293      	cmp	r3, r2
    27cc:	d100      	bne.n	27d0 <uart_nrfx_configure+0x2c>
    27ce:	e06a      	b.n	28a6 <uart_nrfx_configure+0x102>
    27d0:	d83c      	bhi.n	284c <uart_nrfx_configure+0xa8>
    27d2:	2296      	movs	r2, #150	; 0x96
    27d4:	0192      	lsls	r2, r2, #6
    27d6:	4293      	cmp	r3, r2
    27d8:	d100      	bne.n	27dc <uart_nrfx_configure+0x38>
    27da:	e066      	b.n	28aa <uart_nrfx_configure+0x106>
    27dc:	d823      	bhi.n	2826 <uart_nrfx_configure+0x82>
    27de:	2296      	movs	r2, #150	; 0x96
    27e0:	00d2      	lsls	r2, r2, #3
    27e2:	4293      	cmp	r3, r2
    27e4:	d063      	beq.n	28ae <uart_nrfx_configure+0x10a>
    27e6:	d813      	bhi.n	2810 <uart_nrfx_configure+0x6c>
    27e8:	2296      	movs	r2, #150	; 0x96
    27ea:	0052      	lsls	r2, r2, #1
    27ec:	4293      	cmp	r3, r2
    27ee:	d061      	beq.n	28b4 <uart_nrfx_configure+0x110>
    27f0:	2596      	movs	r5, #150	; 0x96
    27f2:	229c      	movs	r2, #156	; 0x9c
    27f4:	00ad      	lsls	r5, r5, #2
    27f6:	0292      	lsls	r2, r2, #10
    27f8:	42ab      	cmp	r3, r5
    27fa:	d111      	bne.n	2820 <uart_nrfx_configure+0x7c>
	struct uart_nrfx_data *data = dev->data;
    27fc:	6903      	ldr	r3, [r0, #16]
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uart_baudrate_set(NRF_UART_Type * p_reg, nrf_uart_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    27fe:	4d3a      	ldr	r5, [pc, #232]	; (28e8 <uart_nrfx_configure+0x144>)
    2800:	483a      	ldr	r0, [pc, #232]	; (28ec <uart_nrfx_configure+0x148>)
    2802:	5142      	str	r2, [r0, r5]
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    2804:	4a3a      	ldr	r2, [pc, #232]	; (28f0 <uart_nrfx_configure+0x14c>)
    2806:	5084      	str	r4, [r0, r2]
		return -ENOTSUP;
	}

	nrf_uart_configure(uart0_addr, &uart_cfg);

	data->uart_config = *cfg;
    2808:	c911      	ldmia	r1!, {r0, r4}
    280a:	c311      	stmia	r3!, {r0, r4}

	return 0;
    280c:	2000      	movs	r0, #0
}
    280e:	bd30      	pop	{r4, r5, pc}
	switch (baudrate) {
    2810:	2296      	movs	r2, #150	; 0x96
    2812:	0112      	lsls	r2, r2, #4
    2814:	4293      	cmp	r3, r2
    2816:	d050      	beq.n	28ba <uart_nrfx_configure+0x116>
    2818:	2296      	movs	r2, #150	; 0x96
    281a:	0152      	lsls	r2, r2, #5
    281c:	4293      	cmp	r3, r2
    281e:	d04f      	beq.n	28c0 <uart_nrfx_configure+0x11c>
    2820:	2086      	movs	r0, #134	; 0x86
    2822:	4240      	negs	r0, r0
    2824:	e7f3      	b.n	280e <uart_nrfx_configure+0x6a>
    2826:	22e1      	movs	r2, #225	; 0xe1
    2828:	01d2      	lsls	r2, r2, #7
    282a:	4293      	cmp	r3, r2
    282c:	d04a      	beq.n	28c4 <uart_nrfx_configure+0x120>
    282e:	d809      	bhi.n	2844 <uart_nrfx_configure+0xa0>
    2830:	22e1      	movs	r2, #225	; 0xe1
    2832:	0192      	lsls	r2, r2, #6
    2834:	4293      	cmp	r3, r2
    2836:	d047      	beq.n	28c8 <uart_nrfx_configure+0x124>
    2838:	2296      	movs	r2, #150	; 0x96
    283a:	01d2      	lsls	r2, r2, #7
    283c:	4293      	cmp	r3, r2
    283e:	d1ef      	bne.n	2820 <uart_nrfx_configure+0x7c>
		nrf_baudrate = NRF_UART_BAUDRATE_19200;
    2840:	4a2c      	ldr	r2, [pc, #176]	; (28f4 <uart_nrfx_configure+0x150>)
    2842:	e7db      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_31250;
    2844:	2280      	movs	r2, #128	; 0x80
	switch (baudrate) {
    2846:	4d2c      	ldr	r5, [pc, #176]	; (28f8 <uart_nrfx_configure+0x154>)
		nrf_baudrate = NRF_UART_BAUDRATE_31250;
    2848:	0412      	lsls	r2, r2, #16
    284a:	e7d5      	b.n	27f8 <uart_nrfx_configure+0x54>
	switch (baudrate) {
    284c:	22e1      	movs	r2, #225	; 0xe1
    284e:	0292      	lsls	r2, r2, #10
    2850:	4293      	cmp	r3, r2
    2852:	d03c      	beq.n	28ce <uart_nrfx_configure+0x12a>
    2854:	d813      	bhi.n	287e <uart_nrfx_configure+0xda>
    2856:	2296      	movs	r2, #150	; 0x96
    2858:	0252      	lsls	r2, r2, #9
    285a:	4293      	cmp	r3, r2
    285c:	d039      	beq.n	28d2 <uart_nrfx_configure+0x12e>
    285e:	d808      	bhi.n	2872 <uart_nrfx_configure+0xce>
    2860:	4a26      	ldr	r2, [pc, #152]	; (28fc <uart_nrfx_configure+0x158>)
    2862:	4293      	cmp	r3, r2
    2864:	d037      	beq.n	28d6 <uart_nrfx_configure+0x132>
    2866:	22e1      	movs	r2, #225	; 0xe1
    2868:	0212      	lsls	r2, r2, #8
    286a:	4293      	cmp	r3, r2
    286c:	d1d8      	bne.n	2820 <uart_nrfx_configure+0x7c>
		nrf_baudrate = NRF_UART_BAUDRATE_57600;
    286e:	4a24      	ldr	r2, [pc, #144]	; (2900 <uart_nrfx_configure+0x15c>)
    2870:	e7c4      	b.n	27fc <uart_nrfx_configure+0x58>
	switch (baudrate) {
    2872:	22e1      	movs	r2, #225	; 0xe1
    2874:	0252      	lsls	r2, r2, #9
    2876:	4293      	cmp	r3, r2
    2878:	d1d2      	bne.n	2820 <uart_nrfx_configure+0x7c>
		nrf_baudrate = NRF_UART_BAUDRATE_115200;
    287a:	4a22      	ldr	r2, [pc, #136]	; (2904 <uart_nrfx_configure+0x160>)
    287c:	e7be      	b.n	27fc <uart_nrfx_configure+0x58>
	switch (baudrate) {
    287e:	22e1      	movs	r2, #225	; 0xe1
    2880:	0312      	lsls	r2, r2, #12
    2882:	4293      	cmp	r3, r2
    2884:	d02a      	beq.n	28dc <uart_nrfx_configure+0x138>
    2886:	d808      	bhi.n	289a <uart_nrfx_configure+0xf6>
    2888:	4a1f      	ldr	r2, [pc, #124]	; (2908 <uart_nrfx_configure+0x164>)
    288a:	4293      	cmp	r3, r2
    288c:	d028      	beq.n	28e0 <uart_nrfx_configure+0x13c>
    288e:	22e1      	movs	r2, #225	; 0xe1
    2890:	02d2      	lsls	r2, r2, #11
    2892:	4293      	cmp	r3, r2
    2894:	d1c4      	bne.n	2820 <uart_nrfx_configure+0x7c>
		nrf_baudrate = NRF_UART_BAUDRATE_460800;
    2896:	4a1d      	ldr	r2, [pc, #116]	; (290c <uart_nrfx_configure+0x168>)
    2898:	e7b0      	b.n	27fc <uart_nrfx_configure+0x58>
	switch (baudrate) {
    289a:	4a1d      	ldr	r2, [pc, #116]	; (2910 <uart_nrfx_configure+0x16c>)
    289c:	4293      	cmp	r3, r2
    289e:	d1bf      	bne.n	2820 <uart_nrfx_configure+0x7c>
		nrf_baudrate = NRF_UART_BAUDRATE_1000000;
    28a0:	2280      	movs	r2, #128	; 0x80
    28a2:	0552      	lsls	r2, r2, #21
    28a4:	e7aa      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_38400;
    28a6:	4a1b      	ldr	r2, [pc, #108]	; (2914 <uart_nrfx_configure+0x170>)
    28a8:	e7a8      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_9600;
    28aa:	4a1b      	ldr	r2, [pc, #108]	; (2918 <uart_nrfx_configure+0x174>)
    28ac:	e7a6      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_1200;
    28ae:	229e      	movs	r2, #158	; 0x9e
    28b0:	02d2      	lsls	r2, r2, #11
    28b2:	e7a3      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = 0x00014000;
    28b4:	22a0      	movs	r2, #160	; 0xa0
    28b6:	0252      	lsls	r2, r2, #9
    28b8:	e7a0      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_2400;
    28ba:	229d      	movs	r2, #157	; 0x9d
    28bc:	0312      	lsls	r2, r2, #12
    28be:	e79d      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_4800;
    28c0:	4a16      	ldr	r2, [pc, #88]	; (291c <uart_nrfx_configure+0x178>)
    28c2:	e79b      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_28800;
    28c4:	4a16      	ldr	r2, [pc, #88]	; (2920 <uart_nrfx_configure+0x17c>)
    28c6:	e799      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_14400;
    28c8:	22ec      	movs	r2, #236	; 0xec
    28ca:	0392      	lsls	r2, r2, #14
    28cc:	e796      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_230400;
    28ce:	4a15      	ldr	r2, [pc, #84]	; (2924 <uart_nrfx_configure+0x180>)
    28d0:	e794      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_76800;
    28d2:	4a15      	ldr	r2, [pc, #84]	; (2928 <uart_nrfx_configure+0x184>)
    28d4:	e792      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_56000;
    28d6:	22e5      	movs	r2, #229	; 0xe5
    28d8:	0412      	lsls	r2, r2, #16
    28da:	e78f      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_921600;
    28dc:	4a13      	ldr	r2, [pc, #76]	; (292c <uart_nrfx_configure+0x188>)
    28de:	e78d      	b.n	27fc <uart_nrfx_configure+0x58>
		nrf_baudrate = NRF_UART_BAUDRATE_250000;
    28e0:	2280      	movs	r2, #128	; 0x80
    28e2:	04d2      	lsls	r2, r2, #19
    28e4:	e78a      	b.n	27fc <uart_nrfx_configure+0x58>
    28e6:	46c0      	nop			; (mov r8, r8)
    28e8:	00000524 	.word	0x00000524
    28ec:	40002000 	.word	0x40002000
    28f0:	0000056c 	.word	0x0000056c
    28f4:	004ea000 	.word	0x004ea000
    28f8:	00007a12 	.word	0x00007a12
    28fc:	0000dac0 	.word	0x0000dac0
    2900:	00ebf000 	.word	0x00ebf000
    2904:	01d7e000 	.word	0x01d7e000
    2908:	0003d090 	.word	0x0003d090
    290c:	075f7000 	.word	0x075f7000
    2910:	000f4240 	.word	0x000f4240
    2914:	009d5000 	.word	0x009d5000
    2918:	00275000 	.word	0x00275000
    291c:	0013b000 	.word	0x0013b000
    2920:	0075f000 	.word	0x0075f000
    2924:	03afb000 	.word	0x03afb000
    2928:	013a9000 	.word	0x013a9000
    292c:	0ebed000 	.word	0x0ebed000

00002930 <uart_nrfx_poll_out>:
{
    2930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2932:	000e      	movs	r6, r1
	if (!k_is_in_isr()) {
    2934:	f003 f9b7 	bl	5ca6 <k_is_in_isr>
    2938:	2464      	movs	r4, #100	; 0x64
    293a:	4d17      	ldr	r5, [pc, #92]	; (2998 <uart_nrfx_poll_out+0x68>)
    293c:	2800      	cmp	r0, #0
    293e:	d00a      	beq.n	2956 <uart_nrfx_poll_out+0x26>
		*lock = 1;
    2940:	2301      	movs	r3, #1
    2942:	602b      	str	r3, [r5, #0]
    2944:	e00e      	b.n	2964 <uart_nrfx_poll_out+0x34>
			if (--safety_cnt == 0) {
    2946:	3c01      	subs	r4, #1
	return z_impl_k_sleep(timeout);
    2948:	2001      	movs	r0, #1
    294a:	2100      	movs	r1, #0
    294c:	b2e4      	uxtb	r4, r4
    294e:	f002 f9db 	bl	4d08 <z_impl_k_sleep>
    2952:	2c00      	cmp	r4, #0
    2954:	d006      	beq.n	2964 <uart_nrfx_poll_out+0x34>
	return z_impl_atomic_cas(target, old_value, new_value);
    2956:	2201      	movs	r2, #1
    2958:	2100      	movs	r1, #0
    295a:	0028      	movs	r0, r5
    295c:	f002 fe44 	bl	55e8 <z_impl_atomic_cas>
				  (atomic_val_t) 1) == false) {
    2960:	2800      	cmp	r0, #0
    2962:	d0f0      	beq.n	2946 <uart_nrfx_poll_out+0x16>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2964:	2300      	movs	r3, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2966:	2201      	movs	r2, #1
    p_reg->TXD = txd;
    2968:	24fa      	movs	r4, #250	; 0xfa
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    296a:	4f0c      	ldr	r7, [pc, #48]	; (299c <uart_nrfx_poll_out+0x6c>)
    p_reg->TXD = txd;
    296c:	00a4      	lsls	r4, r4, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    296e:	603b      	str	r3, [r7, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2970:	4b0b      	ldr	r3, [pc, #44]	; (29a0 <uart_nrfx_poll_out+0x70>)
    2972:	601a      	str	r2, [r3, #0]
    p_reg->TXD = txd;
    2974:	4a0b      	ldr	r2, [pc, #44]	; (29a4 <uart_nrfx_poll_out+0x74>)
    2976:	4b0c      	ldr	r3, [pc, #48]	; (29a8 <uart_nrfx_poll_out+0x78>)
    2978:	50d6      	str	r6, [r2, r3]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    297a:	683b      	ldr	r3, [r7, #0]
	NRFX_WAIT_FOR(event_txdrdy_check(), 1000, 1, res);
    297c:	2b00      	cmp	r3, #0
    297e:	d105      	bne.n	298c <uart_nrfx_poll_out+0x5c>
    2980:	2001      	movs	r0, #1
    2982:	3c01      	subs	r4, #1
    2984:	f003 f8f5 	bl	5b72 <nrfx_busy_wait>
    2988:	2c00      	cmp	r4, #0
    298a:	d1f6      	bne.n	297a <uart_nrfx_poll_out+0x4a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    298c:	2201      	movs	r2, #1
    298e:	4b07      	ldr	r3, [pc, #28]	; (29ac <uart_nrfx_poll_out+0x7c>)
    2990:	601a      	str	r2, [r3, #0]
	*lock = 0;
    2992:	2300      	movs	r3, #0
    2994:	602b      	str	r3, [r5, #0]
}
    2996:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2998:	20000324 	.word	0x20000324
    299c:	4000211c 	.word	0x4000211c
    29a0:	40002008 	.word	0x40002008
    29a4:	40002000 	.word	0x40002000
    29a8:	0000051c 	.word	0x0000051c
    29ac:	4000200c 	.word	0x4000200c

000029b0 <uart_nrfx_init>:
 * @param dev UART device struct
 *
 * @return 0 on success
 */
static int uart_nrfx_init(const struct device *dev)
{
    29b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    p_reg->ENABLE = UART_ENABLE_ENABLE_Disabled;
    29b2:	26a0      	movs	r6, #160	; 0xa0
    29b4:	2100      	movs	r1, #0
	const struct uart_nrfx_config *config = dev->config;
	struct uart_nrfx_data *data = dev->data;
    29b6:	6902      	ldr	r2, [r0, #16]
    29b8:	4d11      	ldr	r5, [pc, #68]	; (2a00 <uart_nrfx_init+0x50>)
	const struct uart_nrfx_config *config = dev->config;
    29ba:	6843      	ldr	r3, [r0, #4]
{
    29bc:	b085      	sub	sp, #20
    29be:	00f6      	lsls	r6, r6, #3
	struct uart_nrfx_data *data = dev->data;
    29c0:	9201      	str	r2, [sp, #4]
    29c2:	51a9      	str	r1, [r5, r6]
	int err;

	nrf_uart_disable(uart0_addr);

	err = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
    29c4:	681f      	ldr	r7, [r3, #0]
{
    29c6:	0004      	movs	r4, r0
				      uint8_t id)
{
	int ret;
	const struct pinctrl_state *state;

	ret = pinctrl_lookup_state(config, id, &state);
    29c8:	aa03      	add	r2, sp, #12
    29ca:	0038      	movs	r0, r7
    29cc:	f003 f8b3 	bl	5b36 <pinctrl_lookup_state>
	if (ret < 0) {
    29d0:	2800      	cmp	r0, #0
    29d2:	db13      	blt.n	29fc <uart_nrfx_init+0x4c>
		return ret;
	}

	return pinctrl_apply_state_direct(config, state);
    29d4:	9b03      	ldr	r3, [sp, #12]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
    29d6:	683a      	ldr	r2, [r7, #0]
    29d8:	7919      	ldrb	r1, [r3, #4]
    29da:	6818      	ldr	r0, [r3, #0]
    29dc:	f7ff fe62 	bl	26a4 <pinctrl_configure_pins>
	if (err < 0) {
    29e0:	2800      	cmp	r0, #0
    29e2:	db0b      	blt.n	29fc <uart_nrfx_init+0x4c>
		return err;
	}

	/* Set initial configuration */
	err = uart_nrfx_configure(dev, &data->uart_config);
    29e4:	0020      	movs	r0, r4
    29e6:	9901      	ldr	r1, [sp, #4]
    29e8:	f7ff fedc 	bl	27a4 <uart_nrfx_configure>
	if (err) {
    29ec:	2800      	cmp	r0, #0
    29ee:	d105      	bne.n	29fc <uart_nrfx_init+0x4c>
    p_reg->ENABLE = UART_ENABLE_ENABLE_Enabled;
    29f0:	2304      	movs	r3, #4
    29f2:	51ab      	str	r3, [r5, r6]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    29f4:	4b03      	ldr	r3, [pc, #12]	; (2a04 <uart_nrfx_init+0x54>)
    29f6:	6018      	str	r0, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    29f8:	2301      	movs	r3, #1
    29fa:	602b      	str	r3, [r5, #0]
#if HW_FLOW_CONTROL_AVAILABLE
	k_timer_init(&uart0_cb.tx_timeout_timer, tx_timeout, NULL);
#endif
#endif
	return 0;
}
    29fc:	b005      	add	sp, #20
    29fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2a00:	40002000 	.word	0x40002000
    2a04:	40002108 	.word	0x40002108

00002a08 <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_DEFAULT;
}

void SystemInit(void)
{
    2a08:	b510      	push	{r4, lr}
         || defined (NRF51802_XXAA) || defined (DEVELOP_IN_NRF51802)\
         || defined (NRF51822_XXAA) || defined (DEVELOP_IN_NRF51822)\
         || defined (NRF51822_XXAB) || defined (DEVELOP_IN_NRF51822)\
         || defined (NRF51822_XXAC) || defined (DEVELOP_IN_NRF51822)\
         || defined (NRF51824_XXAA) || defined (DEVELOP_IN_NRF51824)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    2a0a:	491f      	ldr	r1, [pc, #124]	; (2a88 <SystemInit+0x80>)
    2a0c:	680b      	ldr	r3, [r1, #0]
    2a0e:	b2db      	uxtb	r3, r3
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
        #endif
        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
            if (var1 == 0x01)
    2a10:	2b01      	cmp	r3, #1
    2a12:	d138      	bne.n	2a86 <SystemInit+0x7e>
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    2a14:	4a1d      	ldr	r2, [pc, #116]	; (2a8c <SystemInit+0x84>)
    2a16:	6813      	ldr	r3, [r2, #0]
    2a18:	061b      	lsls	r3, r3, #24
    2a1a:	0f1b      	lsrs	r3, r3, #28
            {
                switch(var2)
    2a1c:	2b0d      	cmp	r3, #13
    2a1e:	d80a      	bhi.n	2a36 <SystemInit+0x2e>
    /* Prepare the peripherals for use as indicated by the PAN 26 "System: Manual setup is required
       to enable the use of peripherals" found at Product Anomaly document for your device found at
       https://infocenter.nordicsemi.com/index.jsp The side effect of executing these instructions in the devices
       that do not need it is that the new peripherals in the second generation devices (LPCOMP for
       example) will not be available. */
    if (nrf51_errata_26())
    2a20:	481b      	ldr	r0, [pc, #108]	; (2a90 <SystemInit+0x88>)
    2a22:	5cc3      	ldrb	r3, [r0, r3]
    2a24:	2b00      	cmp	r3, #0
    2a26:	d006      	beq.n	2a36 <SystemInit+0x2e>
    {
        *(uint32_t volatile *)0x40000504 = 0xC007FFDF;
    2a28:	4b1a      	ldr	r3, [pc, #104]	; (2a94 <SystemInit+0x8c>)
    2a2a:	481b      	ldr	r0, [pc, #108]	; (2a98 <SystemInit+0x90>)
    2a2c:	6018      	str	r0, [r3, #0]
        *(uint32_t volatile *)0x40006C18 = 0x00008000;
    2a2e:	2080      	movs	r0, #128	; 0x80
    2a30:	4b1a      	ldr	r3, [pc, #104]	; (2a9c <SystemInit+0x94>)
    2a32:	0200      	lsls	r0, r0, #8
    2a34:	6018      	str	r0, [r3, #0]
         || defined (NRF51822_XXAA) || defined (DEVELOP_IN_NRF51822)\
         || defined (NRF51822_XXAB) || defined (DEVELOP_IN_NRF51822)\
         || defined (NRF51822_XXAC) || defined (DEVELOP_IN_NRF51822)\
         || defined (NRF51824_XXAA) || defined (DEVELOP_IN_NRF51824)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    2a36:	6813      	ldr	r3, [r2, #0]
    2a38:	061b      	lsls	r3, r3, #24
    2a3a:	0f1b      	lsrs	r3, r3, #28
        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
            if (var1 == 0x01)
            {
                switch(var2)
    2a3c:	2b0d      	cmp	r3, #13
    2a3e:	d80d      	bhi.n	2a5c <SystemInit+0x54>
    }

    /* Disable PROTENSET registers under debug, as indicated by PAN 59 "MPU: Reset value of DISABLEINDEBUG
       register is incorrect" found at Product Anomaly document for your device found at
       https://infocenter.nordicsemi.com/index.jsp There is no side effect of using these instruction if not needed. */
    if (nrf51_errata_59())
    2a40:	4817      	ldr	r0, [pc, #92]	; (2aa0 <SystemInit+0x98>)
    2a42:	5cc3      	ldrb	r3, [r0, r3]
    2a44:	2b00      	cmp	r3, #0
    2a46:	d009      	beq.n	2a5c <SystemInit+0x54>
    {
        NRF_MPU->DISABLEINDEBUG = MPU_DISABLEINDEBUG_DISABLEINDEBUG_Disabled << MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos;
    2a48:	2080      	movs	r0, #128	; 0x80
    2a4a:	23c1      	movs	r3, #193	; 0xc1
    2a4c:	2401      	movs	r4, #1
    2a4e:	00db      	lsls	r3, r3, #3
    2a50:	05c0      	lsls	r0, r0, #23
    2a52:	50c4      	str	r4, [r0, r3]
         || defined (NRF51802_XXAA) || defined (DEVELOP_IN_NRF51802)\
         || defined (NRF51822_XXAA) || defined (DEVELOP_IN_NRF51822)\
         || defined (NRF51822_XXAB) || defined (DEVELOP_IN_NRF51822)\
         || defined (NRF51822_XXAC) || defined (DEVELOP_IN_NRF51822)\
         || defined (NRF51824_XXAA) || defined (DEVELOP_IN_NRF51824)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    2a54:	680b      	ldr	r3, [r1, #0]
    2a56:	b2db      	uxtb	r3, r3
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
        #endif
        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
            if (var1 == 0x01)
    2a58:	42a3      	cmp	r3, r4
    2a5a:	d114      	bne.n	2a86 <SystemInit+0x7e>
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    2a5c:	6813      	ldr	r3, [r2, #0]
    2a5e:	061b      	lsls	r3, r3, #24
    2a60:	0f1b      	lsrs	r3, r3, #28
            {
                switch(var2)
    2a62:	2b0d      	cmp	r3, #13
    2a64:	d803      	bhi.n	2a6e <SystemInit+0x66>
    }

    /* Execute the following code to eliminate excessive current in sleep mode with RAM retention in nRF51802 devices,
       as indicated by PAN 76 "System: Excessive current in sleep mode with retention" found at Product Anomaly document
       for your device found at https://infocenter.nordicsemi.com/index.jsp */
    if (nrf51_errata_76()){
    2a66:	4a0f      	ldr	r2, [pc, #60]	; (2aa4 <SystemInit+0x9c>)
    2a68:	5cd3      	ldrb	r3, [r2, r3]
    2a6a:	2b00      	cmp	r3, #0
    2a6c:	d00b      	beq.n	2a86 <SystemInit+0x7e>
        if (*(uint32_t volatile *)0x4006EC00 != 1){
    2a6e:	4b0e      	ldr	r3, [pc, #56]	; (2aa8 <SystemInit+0xa0>)
    2a70:	681a      	ldr	r2, [r3, #0]
    2a72:	2a01      	cmp	r2, #1
    2a74:	d004      	beq.n	2a80 <SystemInit+0x78>
            *(uint32_t volatile *)0x4006EC00 = 0x9375;
    2a76:	4a0d      	ldr	r2, [pc, #52]	; (2aac <SystemInit+0xa4>)
    2a78:	601a      	str	r2, [r3, #0]
            while (*(uint32_t volatile *)0x4006EC00 != 1){
    2a7a:	681a      	ldr	r2, [r3, #0]
    2a7c:	2a01      	cmp	r2, #1
    2a7e:	d1fc      	bne.n	2a7a <SystemInit+0x72>
            }
        }
        *(uint32_t volatile *)0x4006EC14 = 0xC0;
    2a80:	22c0      	movs	r2, #192	; 0xc0
    2a82:	4b0b      	ldr	r3, [pc, #44]	; (2ab0 <SystemInit+0xa8>)
    2a84:	601a      	str	r2, [r3, #0]
    }
}
    2a86:	bd10      	pop	{r4, pc}
    2a88:	f0000fe0 	.word	0xf0000fe0
    2a8c:	f0000fe8 	.word	0xf0000fe8
    2a90:	00006ae3 	.word	0x00006ae3
    2a94:	40000504 	.word	0x40000504
    2a98:	c007ffdf 	.word	0xc007ffdf
    2a9c:	40006c18 	.word	0x40006c18
    2aa0:	00006ad5 	.word	0x00006ad5
    2aa4:	00006ac7 	.word	0x00006ac7
    2aa8:	4006ec00 	.word	0x4006ec00
    2aac:	00009375 	.word	0x00009375
    2ab0:	4006ec14 	.word	0x4006ec14

00002ab4 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
    2ab4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    2ab6:	0005      	movs	r5, r0
        if (prev_mask == 0)
        {
            return NRFX_ERROR_NO_MEM;
        }

        idx = 31 - NRF_CLZ(prev_mask);
    2ab8:	271f      	movs	r7, #31
{
    2aba:	9101      	str	r1, [sp, #4]
        prev_mask = *p_mask;
    2abc:	682e      	ldr	r6, [r5, #0]
        if (prev_mask == 0)
    2abe:	2e00      	cmp	r6, #0
    2ac0:	d012      	beq.n	2ae8 <nrfx_flag32_alloc+0x34>
        idx = 31 - NRF_CLZ(prev_mask);
    2ac2:	0030      	movs	r0, r6
    2ac4:	f7fd fba0 	bl	208 <__clzsi2>
    2ac8:	1a3c      	subs	r4, r7, r0
    2aca:	b2e4      	uxtb	r4, r4
        new_mask = prev_mask & ~NRFX_BIT(idx);
    2acc:	2301      	movs	r3, #1
    2ace:	0032      	movs	r2, r6
    2ad0:	40a3      	lsls	r3, r4
    2ad2:	0031      	movs	r1, r6
    2ad4:	0028      	movs	r0, r5
    2ad6:	439a      	bics	r2, r3
    2ad8:	f002 fd86 	bl	55e8 <z_impl_atomic_cas>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
    2adc:	2800      	cmp	r0, #0
    2ade:	d0ed      	beq.n	2abc <nrfx_flag32_alloc+0x8>

    *p_flag = idx;
    2ae0:	9b01      	ldr	r3, [sp, #4]

    return NRFX_SUCCESS;
    2ae2:	4802      	ldr	r0, [pc, #8]	; (2aec <nrfx_flag32_alloc+0x38>)
    *p_flag = idx;
    2ae4:	701c      	strb	r4, [r3, #0]
}
    2ae6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
            return NRFX_ERROR_NO_MEM;
    2ae8:	4801      	ldr	r0, [pc, #4]	; (2af0 <nrfx_flag32_alloc+0x3c>)
    2aea:	e7fc      	b.n	2ae6 <nrfx_flag32_alloc+0x32>
    2aec:	0bad0000 	.word	0x0bad0000
    2af0:	0bad0002 	.word	0x0bad0002

00002af4 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    2af4:	b570      	push	{r4, r5, r6, lr}
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
    2af6:	6803      	ldr	r3, [r0, #0]
    2af8:	2501      	movs	r5, #1
    2afa:	40cb      	lsrs	r3, r1
{
    2afc:	0004      	movs	r4, r0
    if ((NRFX_BIT(flag) & *p_mask))
    2afe:	422b      	tst	r3, r5
    2b00:	d10a      	bne.n	2b18 <nrfx_flag32_free+0x24>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
    2b02:	408d      	lsls	r5, r1
        prev_mask = *p_mask;
    2b04:	6821      	ldr	r1, [r4, #0]
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
    2b06:	000a      	movs	r2, r1
    2b08:	0020      	movs	r0, r4
    2b0a:	432a      	orrs	r2, r5
    2b0c:	f002 fd6c 	bl	55e8 <z_impl_atomic_cas>
    2b10:	2800      	cmp	r0, #0
    2b12:	d0f7      	beq.n	2b04 <nrfx_flag32_free+0x10>

    return NRFX_SUCCESS;
    2b14:	4801      	ldr	r0, [pc, #4]	; (2b1c <nrfx_flag32_free+0x28>)
}
    2b16:	bd70      	pop	{r4, r5, r6, pc}
        return NRFX_ERROR_INVALID_PARAM;
    2b18:	4801      	ldr	r0, [pc, #4]	; (2b20 <nrfx_flag32_free+0x2c>)
    2b1a:	e7fc      	b.n	2b16 <nrfx_flag32_free+0x22>
    2b1c:	0bad0000 	.word	0x0bad0000
    2b20:	0bad0004 	.word	0x0bad0004

00002b24 <clock_stop>:
    CoreDebug->DEMCR = core_debug;
}
#endif // NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_132)

static void clock_stop(nrf_clock_domain_t domain)
{
    2b24:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    2b26:	23c2      	movs	r3, #194	; 0xc2
    2b28:	2280      	movs	r2, #128	; 0x80
    2b2a:	0004      	movs	r4, r0
    2b2c:	05d2      	lsls	r2, r2, #23
    2b2e:	009b      	lsls	r3, r3, #2
    switch (domain)
    2b30:	2800      	cmp	r0, #0
    2b32:	d00c      	beq.n	2b4e <clock_stop+0x2a>
    2b34:	2801      	cmp	r0, #1
    2b36:	d025      	beq.n	2b84 <clock_stop+0x60>
            nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED);
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_HFCLKAUDIOSTOP);
            break;
#endif
        default:
            NRFX_ASSERT(0);
    2b38:	4c30      	ldr	r4, [pc, #192]	; (2bfc <clock_stop+0xd8>)
    2b3a:	4931      	ldr	r1, [pc, #196]	; (2c00 <clock_stop+0xdc>)
    2b3c:	23d8      	movs	r3, #216	; 0xd8
    2b3e:	0022      	movs	r2, r4
    2b40:	4830      	ldr	r0, [pc, #192]	; (2c04 <clock_stop+0xe0>)
    2b42:	f002 fed1 	bl	58e8 <assert_print>
    2b46:	21d8      	movs	r1, #216	; 0xd8
        case NRF_CLOCK_DOMAIN_HFCLKAUDIO:
            clock_running = p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_STATE_Msk;
            break;
#endif
        default:
            NRFX_ASSERT(0);
    2b48:	0020      	movs	r0, r4
    2b4a:	f002 fec9 	bl	58e0 <assert_post_action>
    p_reg->INTENCLR = mask;
    2b4e:	2102      	movs	r1, #2
    2b50:	50d1      	str	r1, [r2, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2b52:	2201      	movs	r2, #1
            return;
    }

    bool stopped;
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
    2b54:	0006      	movs	r6, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2b56:	4b2c      	ldr	r3, [pc, #176]	; (2c08 <clock_stop+0xe4>)
    2b58:	6018      	str	r0, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2b5a:	4b2c      	ldr	r3, [pc, #176]	; (2c0c <clock_stop+0xe8>)
    2b5c:	601a      	str	r2, [r3, #0]
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    2b5e:	2301      	movs	r3, #1
    2b60:	466a      	mov	r2, sp
            clock_running = p_reg->NRF_HFCLKSTAT & NRF_CLOCK_HFCLKSTAT_STATE_Msk;
    2b62:	2780      	movs	r7, #128	; 0x80
    2b64:	4d2a      	ldr	r5, [pc, #168]	; (2c10 <clock_stop+0xec>)
    2b66:	71d3      	strb	r3, [r2, #7]
    2b68:	05ff      	lsls	r7, r7, #23
    switch (domain)
    2b6a:	2c00      	cmp	r4, #0
    2b6c:	d02d      	beq.n	2bca <clock_stop+0xa6>
    2b6e:	2c01      	cmp	r4, #1
    2b70:	d019      	beq.n	2ba6 <clock_stop+0x82>
            NRFX_ASSERT(0);
    2b72:	4c28      	ldr	r4, [pc, #160]	; (2c14 <clock_stop+0xf0>)
    2b74:	4922      	ldr	r1, [pc, #136]	; (2c00 <clock_stop+0xdc>)
    2b76:	0022      	movs	r2, r4
    2b78:	4822      	ldr	r0, [pc, #136]	; (2c04 <clock_stop+0xe0>)
    2b7a:	4b27      	ldr	r3, [pc, #156]	; (2c18 <clock_stop+0xf4>)
    2b7c:	f002 feb4 	bl	58e8 <assert_print>
    2b80:	4925      	ldr	r1, [pc, #148]	; (2c18 <clock_stop+0xf4>)
    2b82:	e7e1      	b.n	2b48 <clock_stop+0x24>
    p_reg->INTENCLR = mask;
    2b84:	50d0      	str	r0, [r2, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2b86:	2200      	movs	r2, #0
    2b88:	4b24      	ldr	r3, [pc, #144]	; (2c1c <clock_stop+0xf8>)
    2b8a:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2b8c:	4b24      	ldr	r3, [pc, #144]	; (2c20 <clock_stop+0xfc>)
    2b8e:	6018      	str	r0, [r3, #0]
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
    2b90:	466b      	mov	r3, sp
    2b92:	1dde      	adds	r6, r3, #7
    2b94:	e7e3      	b.n	2b5e <clock_stop+0x3a>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
    2b96:	2b00      	cmp	r3, #0
    2b98:	d025      	beq.n	2be6 <clock_stop+0xc2>
    2b9a:	2001      	movs	r0, #1
    2b9c:	3d01      	subs	r5, #1
    2b9e:	f002 ffe8 	bl	5b72 <nrfx_busy_wait>
    2ba2:	2d00      	cmp	r5, #0
    2ba4:	d01f      	beq.n	2be6 <clock_stop+0xc2>
            clock_running = p_reg->NRF_HFCLKSTAT & NRF_CLOCK_HFCLKSTAT_STATE_Msk;
    2ba6:	2180      	movs	r1, #128	; 0x80
    2ba8:	4a1e      	ldr	r2, [pc, #120]	; (2c24 <clock_stop+0x100>)
    2baa:	0249      	lsls	r1, r1, #9
    2bac:	58bb      	ldr	r3, [r7, r2]
    2bae:	400b      	ands	r3, r1
            if (p_clk_src != NULL)
    2bb0:	2e00      	cmp	r6, #0
    2bb2:	d0f0      	beq.n	2b96 <clock_stop+0x72>
                    (nrf_clock_hfclk_t)((p_reg->NRF_HFCLKSTAT & NRF_CLOCK_HFCLKSTAT_SRC_Msk)
    2bb4:	58ba      	ldr	r2, [r7, r2]
    2bb6:	4022      	ands	r2, r4
    2bb8:	e012      	b.n	2be0 <clock_stop+0xbc>
    2bba:	2b00      	cmp	r3, #0
    2bbc:	d013      	beq.n	2be6 <clock_stop+0xc2>
    2bbe:	2001      	movs	r0, #1
    2bc0:	3d01      	subs	r5, #1
    2bc2:	f002 ffd6 	bl	5b72 <nrfx_busy_wait>
    2bc6:	2d00      	cmp	r5, #0
    2bc8:	d00d      	beq.n	2be6 <clock_stop+0xc2>
            clock_running = p_reg->NRF_LFCLKSTAT & NRF_CLOCK_LFCLKSTAT_STATE_Msk;
    2bca:	2283      	movs	r2, #131	; 0x83
    2bcc:	2180      	movs	r1, #128	; 0x80
    2bce:	00d2      	lsls	r2, r2, #3
    2bd0:	58bb      	ldr	r3, [r7, r2]
    2bd2:	0249      	lsls	r1, r1, #9
    2bd4:	400b      	ands	r3, r1
            if (p_clk_src != NULL)
    2bd6:	2e00      	cmp	r6, #0
    2bd8:	d0ef      	beq.n	2bba <clock_stop+0x96>
                    (nrf_clock_lfclk_t)((p_reg->NRF_LFCLKSTAT & NRF_CLOCK_LFCLKSTAT_SRC_Msk)
    2bda:	2103      	movs	r1, #3
    2bdc:	58ba      	ldr	r2, [r7, r2]
    2bde:	400a      	ands	r2, r1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
    2be0:	7032      	strb	r2, [r6, #0]
    2be2:	2b00      	cmp	r3, #0
    2be4:	d100      	bne.n	2be8 <clock_stop+0xc4>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
    2be6:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
    2be8:	466b      	mov	r3, sp
    2bea:	79d8      	ldrb	r0, [r3, #7]
    2bec:	2801      	cmp	r0, #1
    2bee:	d1fa      	bne.n	2be6 <clock_stop+0xc2>
    2bf0:	3d01      	subs	r5, #1
    2bf2:	f002 ffbe 	bl	5b72 <nrfx_busy_wait>
    2bf6:	2d00      	cmp	r5, #0
    2bf8:	d1b7      	bne.n	2b6a <clock_stop+0x46>
    2bfa:	e7f4      	b.n	2be6 <clock_stop+0xc2>
    2bfc:	00006af1 	.word	0x00006af1
    2c00:	00006f16 	.word	0x00006f16
    2c04:	00006347 	.word	0x00006347
    2c08:	40000104 	.word	0x40000104
    2c0c:	4000000c 	.word	0x4000000c
    2c10:	00002710 	.word	0x00002710
    2c14:	00006b2e 	.word	0x00006b2e
    2c18:	000003be 	.word	0x000003be
    2c1c:	40000100 	.word	0x40000100
    2c20:	40000004 	.word	0x40000004
    2c24:	0000040c 	.word	0x0000040c

00002c28 <nrfx_clock_init>:
    }
    return is_correct_clk;
}

nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    2c28:	b510      	push	{r4, lr}
    NRFX_ASSERT(event_handler);
    2c2a:	2800      	cmp	r0, #0
    2c2c:	d10c      	bne.n	2c48 <nrfx_clock_init+0x20>
    2c2e:	2316      	movs	r3, #22
    2c30:	4c0b      	ldr	r4, [pc, #44]	; (2c60 <nrfx_clock_init+0x38>)
    2c32:	490c      	ldr	r1, [pc, #48]	; (2c64 <nrfx_clock_init+0x3c>)
    2c34:	480c      	ldr	r0, [pc, #48]	; (2c68 <nrfx_clock_init+0x40>)
    2c36:	0022      	movs	r2, r4
    2c38:	33ff      	adds	r3, #255	; 0xff
    2c3a:	f002 fe55 	bl	58e8 <assert_print>
    2c3e:	2116      	movs	r1, #22
    2c40:	0020      	movs	r0, r4
    2c42:	31ff      	adds	r1, #255	; 0xff
    2c44:	f002 fe4c 	bl	58e0 <assert_post_action>

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
    2c48:	4b08      	ldr	r3, [pc, #32]	; (2c6c <nrfx_clock_init+0x44>)
    2c4a:	791a      	ldrb	r2, [r3, #4]
    2c4c:	2a00      	cmp	r2, #0
    2c4e:	d104      	bne.n	2c5a <nrfx_clock_init+0x32>
    else
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
    2c50:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
    2c52:	3201      	adds	r2, #1
    nrfx_err_t err_code = NRFX_SUCCESS;
    2c54:	4806      	ldr	r0, [pc, #24]	; (2c70 <nrfx_clock_init+0x48>)
        m_clock_cb.module_initialized = true;
    2c56:	711a      	strb	r2, [r3, #4]
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    2c58:	bd10      	pop	{r4, pc}
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
    2c5a:	4806      	ldr	r0, [pc, #24]	; (2c74 <nrfx_clock_init+0x4c>)
    return err_code;
    2c5c:	e7fc      	b.n	2c58 <nrfx_clock_init+0x30>
    2c5e:	46c0      	nop			; (mov r8, r8)
    2c60:	00006af1 	.word	0x00006af1
    2c64:	00006b62 	.word	0x00006b62
    2c68:	00006347 	.word	0x00006347
    2c6c:	20000328 	.word	0x20000328
    2c70:	0bad0000 	.word	0x0bad0000
    2c74:	0bad000c 	.word	0x0bad000c

00002c78 <nrfx_clock_enable>:

void nrfx_clock_enable(void)
{
    2c78:	b510      	push	{r4, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    2c7a:	4b0f      	ldr	r3, [pc, #60]	; (2cb8 <nrfx_clock_enable+0x40>)
    2c7c:	791b      	ldrb	r3, [r3, #4]
    2c7e:	2b00      	cmp	r3, #0
    2c80:	d10c      	bne.n	2c9c <nrfx_clock_enable+0x24>
    2c82:	4c0e      	ldr	r4, [pc, #56]	; (2cbc <nrfx_clock_enable+0x44>)
    2c84:	332f      	adds	r3, #47	; 0x2f
    2c86:	490e      	ldr	r1, [pc, #56]	; (2cc0 <nrfx_clock_enable+0x48>)
    2c88:	480e      	ldr	r0, [pc, #56]	; (2cc4 <nrfx_clock_enable+0x4c>)
    2c8a:	0022      	movs	r2, r4
    2c8c:	33ff      	adds	r3, #255	; 0xff
    2c8e:	f002 fe2b 	bl	58e8 <assert_print>
    2c92:	2197      	movs	r1, #151	; 0x97
    2c94:	0020      	movs	r0, r4
    2c96:	0049      	lsls	r1, r1, #1
    2c98:	f002 fe22 	bl	58e0 <assert_post_action>
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
    2c9c:	2000      	movs	r0, #0
    2c9e:	f7fe fbad 	bl	13fc <arch_irq_is_enabled>
    2ca2:	2800      	cmp	r0, #0
    2ca4:	d101      	bne.n	2caa <nrfx_clock_enable+0x32>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
    2ca6:	f7fe fb9d 	bl	13e4 <arch_irq_enable>
#pragma GCC diagnostic pop
#endif

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->NRF_LFCLKSRC = (uint32_t)(source);
    2caa:	2280      	movs	r2, #128	; 0x80
    2cac:	23a3      	movs	r3, #163	; 0xa3
    2cae:	2100      	movs	r1, #0
    2cb0:	05d2      	lsls	r2, r2, #23
    2cb2:	00db      	lsls	r3, r3, #3
    2cb4:	50d1      	str	r1, [r2, r3]
#if NRFX_CHECK(NRFX_POWER_ENABLED)
    nrfx_clock_irq_enabled = true;
#endif

    NRFX_LOG_INFO("Module enabled.");
}
    2cb6:	bd10      	pop	{r4, pc}
    2cb8:	20000328 	.word	0x20000328
    2cbc:	00006af1 	.word	0x00006af1
    2cc0:	00006b70 	.word	0x00006b70
    2cc4:	00006347 	.word	0x00006347

00002cc8 <nrfx_clock_start>:
    m_clock_cb.module_initialized = false;
    NRFX_LOG_INFO("Uninitialized.");
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    2cc8:	b510      	push	{r4, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    2cca:	4b2b      	ldr	r3, [pc, #172]	; (2d78 <nrfx_clock_start+0xb0>)
    2ccc:	791b      	ldrb	r3, [r3, #4]
    2cce:	2b00      	cmp	r3, #0
    2cd0:	d10c      	bne.n	2cec <nrfx_clock_start+0x24>
    2cd2:	4c2a      	ldr	r4, [pc, #168]	; (2d7c <nrfx_clock_start+0xb4>)
    2cd4:	3369      	adds	r3, #105	; 0x69
    2cd6:	492a      	ldr	r1, [pc, #168]	; (2d80 <nrfx_clock_start+0xb8>)
    2cd8:	0022      	movs	r2, r4
    2cda:	482a      	ldr	r0, [pc, #168]	; (2d84 <nrfx_clock_start+0xbc>)
    2cdc:	33ff      	adds	r3, #255	; 0xff
    2cde:	f002 fe03 	bl	58e8 <assert_print>
    2ce2:	21b4      	movs	r1, #180	; 0xb4
            nrf_clock_int_enable(NRF_CLOCK, NRF_CLOCK_INT_HFAUDIO_STARTED_MASK);
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_HFCLKAUDIOSTART);
            break;
#endif
        default:
            NRFX_ASSERT(0);
    2ce4:	0020      	movs	r0, r4
    2ce6:	0049      	lsls	r1, r1, #1
    2ce8:	f002 fdfa 	bl	58e0 <assert_post_action>
    switch (domain)
    2cec:	2380      	movs	r3, #128	; 0x80
    2cee:	05db      	lsls	r3, r3, #23
    2cf0:	2800      	cmp	r0, #0
    2cf2:	d00b      	beq.n	2d0c <nrfx_clock_start+0x44>
    2cf4:	2801      	cmp	r0, #1
    2cf6:	d036      	beq.n	2d66 <nrfx_clock_start+0x9e>
            NRFX_ASSERT(0);
    2cf8:	23d5      	movs	r3, #213	; 0xd5
    2cfa:	4c20      	ldr	r4, [pc, #128]	; (2d7c <nrfx_clock_start+0xb4>)
    2cfc:	4922      	ldr	r1, [pc, #136]	; (2d88 <nrfx_clock_start+0xc0>)
    2cfe:	0022      	movs	r2, r4
    2d00:	4820      	ldr	r0, [pc, #128]	; (2d84 <nrfx_clock_start+0xbc>)
    2d02:	005b      	lsls	r3, r3, #1
    2d04:	f002 fdf0 	bl	58e8 <assert_print>
    2d08:	21d5      	movs	r1, #213	; 0xd5
    2d0a:	e7eb      	b.n	2ce4 <nrfx_clock_start+0x1c>
            clock_running = p_reg->NRF_LFCLKSTAT & NRF_CLOCK_LFCLKSTAT_STATE_Msk;
    2d0c:	2283      	movs	r2, #131	; 0x83
    2d0e:	00d2      	lsls	r2, r2, #3
    2d10:	5899      	ldr	r1, [r3, r2]
                    (nrf_clock_lfclk_t)((p_reg->NRF_LFCLKSTAT & NRF_CLOCK_LFCLKSTAT_SRC_Msk)
    2d12:	589a      	ldr	r2, [r3, r2]
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc))
    2d14:	03c9      	lsls	r1, r1, #15
    2d16:	d519      	bpl.n	2d4c <nrfx_clock_start+0x84>
    2d18:	2303      	movs	r3, #3
    2d1a:	4013      	ands	r3, r2
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
    2d1c:	2b01      	cmp	r3, #1
    2d1e:	d005      	beq.n	2d2c <nrfx_clock_start+0x64>
    2d20:	2b00      	cmp	r3, #0
    2d22:	d002      	beq.n	2d2a <nrfx_clock_start+0x62>
        clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
    2d24:	2000      	movs	r0, #0
    2d26:	f7ff fefd 	bl	2b24 <clock_stop>
        *p_lfclksrc = clock_initial_lfclksrc_get();
    2d2a:	2300      	movs	r3, #0
    p_reg->NRF_LFCLKSRC = (uint32_t)(source);
    2d2c:	2280      	movs	r2, #128	; 0x80
    2d2e:	21a3      	movs	r1, #163	; 0xa3
    2d30:	05d2      	lsls	r2, r2, #23
    2d32:	00c9      	lsls	r1, r1, #3
    2d34:	5053      	str	r3, [r2, r1]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2d36:	2100      	movs	r1, #0
    2d38:	4b14      	ldr	r3, [pc, #80]	; (2d8c <nrfx_clock_start+0xc4>)
    2d3a:	6019      	str	r1, [r3, #0]
    p_reg->INTENSET = mask;
    2d3c:	23c1      	movs	r3, #193	; 0xc1
    2d3e:	3102      	adds	r1, #2
    2d40:	009b      	lsls	r3, r3, #2
    2d42:	50d1      	str	r1, [r2, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2d44:	2201      	movs	r2, #1
    2d46:	4b12      	ldr	r3, [pc, #72]	; (2d90 <nrfx_clock_start+0xc8>)
    2d48:	601a      	str	r2, [r3, #0]
}
    2d4a:	e00b      	b.n	2d64 <nrfx_clock_start+0x9c>
            return ((p_reg->NRF_LFCLKRUN & NRF_CLOCK_LFCLKRUN_STATUS_Msk)
    2d4c:	4a11      	ldr	r2, [pc, #68]	; (2d94 <nrfx_clock_start+0xcc>)
    2d4e:	589a      	ldr	r2, [r3, r2]
                else if (nrf_clock_start_task_check(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK))
    2d50:	07d2      	lsls	r2, r2, #31
    2d52:	d5ea      	bpl.n	2d2a <nrfx_clock_start+0x62>
}

#if NRF_CLOCK_HAS_LFCLKSRCCOPY
NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    2d54:	4a10      	ldr	r2, [pc, #64]	; (2d98 <nrfx_clock_start+0xd0>)
    2d56:	5899      	ldr	r1, [r3, r2]
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
    2d58:	2202      	movs	r2, #2
    2d5a:	4211      	tst	r1, r2
    2d5c:	d1e2      	bne.n	2d24 <nrfx_clock_start+0x5c>
    p_reg->INTENSET = mask;
    2d5e:	21c1      	movs	r1, #193	; 0xc1
    2d60:	0089      	lsls	r1, r1, #2
    2d62:	505a      	str	r2, [r3, r1]
            break;
    }
}
    2d64:	bd10      	pop	{r4, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2d66:	2100      	movs	r1, #0
    2d68:	4a0c      	ldr	r2, [pc, #48]	; (2d9c <nrfx_clock_start+0xd4>)
    2d6a:	6011      	str	r1, [r2, #0]
    p_reg->INTENSET = mask;
    2d6c:	22c1      	movs	r2, #193	; 0xc1
    2d6e:	0092      	lsls	r2, r2, #2
    2d70:	5098      	str	r0, [r3, r2]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2d72:	6018      	str	r0, [r3, #0]
}
    2d74:	e7f6      	b.n	2d64 <nrfx_clock_start+0x9c>
    2d76:	46c0      	nop			; (mov r8, r8)
    2d78:	20000328 	.word	0x20000328
    2d7c:	00006af1 	.word	0x00006af1
    2d80:	00006b70 	.word	0x00006b70
    2d84:	00006347 	.word	0x00006347
    2d88:	00006f16 	.word	0x00006f16
    2d8c:	40000104 	.word	0x40000104
    2d90:	40000008 	.word	0x40000008
    2d94:	00000414 	.word	0x00000414
    2d98:	0000041c 	.word	0x0000041c
    2d9c:	40000100 	.word	0x40000100

00002da0 <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
    2da0:	b510      	push	{r4, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    2da2:	4b0a      	ldr	r3, [pc, #40]	; (2dcc <nrfx_clock_stop+0x2c>)
    2da4:	791b      	ldrb	r3, [r3, #4]
    2da6:	2b00      	cmp	r3, #0
    2da8:	d10c      	bne.n	2dc4 <nrfx_clock_stop+0x24>
    2daa:	23b2      	movs	r3, #178	; 0xb2
    2dac:	4c08      	ldr	r4, [pc, #32]	; (2dd0 <nrfx_clock_stop+0x30>)
    2dae:	4909      	ldr	r1, [pc, #36]	; (2dd4 <nrfx_clock_stop+0x34>)
    2db0:	4809      	ldr	r0, [pc, #36]	; (2dd8 <nrfx_clock_stop+0x38>)
    2db2:	0022      	movs	r2, r4
    2db4:	33ff      	adds	r3, #255	; 0xff
    2db6:	f002 fd97 	bl	58e8 <assert_print>
    2dba:	21b2      	movs	r1, #178	; 0xb2
    2dbc:	0020      	movs	r0, r4
    2dbe:	31ff      	adds	r1, #255	; 0xff
    2dc0:	f002 fd8e 	bl	58e0 <assert_post_action>
    clock_stop(domain);
    2dc4:	f7ff feae 	bl	2b24 <clock_stop>
}
    2dc8:	bd10      	pop	{r4, pc}
    2dca:	46c0      	nop			; (mov r8, r8)
    2dcc:	20000328 	.word	0x20000328
    2dd0:	00006af1 	.word	0x00006af1
    2dd4:	00006b70 	.word	0x00006b70
    2dd8:	00006347 	.word	0x00006347

00002ddc <nrfx_power_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
    2ddc:	b510      	push	{r4, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    2dde:	4b16      	ldr	r3, [pc, #88]	; (2e38 <nrfx_power_clock_irq_handler+0x5c>)
    2de0:	681a      	ldr	r2, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
    2de2:	2a00      	cmp	r2, #0
    2de4:	d00a      	beq.n	2dfc <nrfx_power_clock_irq_handler+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2de6:	2000      	movs	r0, #0
    p_reg->INTENCLR = mask;
    2de8:	2280      	movs	r2, #128	; 0x80
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2dea:	6018      	str	r0, [r3, #0]
    p_reg->INTENCLR = mask;
    2dec:	23c2      	movs	r3, #194	; 0xc2
    2dee:	2101      	movs	r1, #1
    2df0:	009b      	lsls	r3, r3, #2
    2df2:	05d2      	lsls	r2, r2, #23
    2df4:	50d1      	str	r1, [r2, r3]
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
    2df6:	4b11      	ldr	r3, [pc, #68]	; (2e3c <nrfx_power_clock_irq_handler+0x60>)
    2df8:	681b      	ldr	r3, [r3, #0]
    2dfa:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    2dfc:	4b10      	ldr	r3, [pc, #64]	; (2e40 <nrfx_power_clock_irq_handler+0x64>)
    2dfe:	681a      	ldr	r2, [r3, #0]
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
    2e00:	2a00      	cmp	r2, #0
    2e02:	d00f      	beq.n	2e24 <nrfx_power_clock_irq_handler+0x48>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2e04:	2200      	movs	r2, #0
    2e06:	601a      	str	r2, [r3, #0]
            clock_running = p_reg->NRF_LFCLKSTAT & NRF_CLOCK_LFCLKSTAT_STATE_Msk;
    2e08:	2283      	movs	r2, #131	; 0x83
    2e0a:	3b05      	subs	r3, #5
    2e0c:	3bff      	subs	r3, #255	; 0xff
    2e0e:	00d2      	lsls	r2, r2, #3
    2e10:	5899      	ldr	r1, [r3, r2]
                    (nrf_clock_lfclk_t)((p_reg->NRF_LFCLKSTAT & NRF_CLOCK_LFCLKSTAT_SRC_Msk)
    2e12:	589a      	ldr	r2, [r3, r2]
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
    2e14:	0792      	lsls	r2, r2, #30
    2e16:	d106      	bne.n	2e26 <nrfx_power_clock_irq_handler+0x4a>
    p_reg->NRF_LFCLKSRC = (uint32_t)(source);
    2e18:	21a3      	movs	r1, #163	; 0xa3
    2e1a:	2201      	movs	r2, #1
    2e1c:	00c9      	lsls	r1, r1, #3
    2e1e:	505a      	str	r2, [r3, r1]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2e20:	4b08      	ldr	r3, [pc, #32]	; (2e44 <nrfx_power_clock_irq_handler+0x68>)
    2e22:	601a      	str	r2, [r3, #0]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
    2e24:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
    2e26:	22c2      	movs	r2, #194	; 0xc2
    2e28:	2102      	movs	r1, #2
    2e2a:	0092      	lsls	r2, r2, #2
    2e2c:	5099      	str	r1, [r3, r2]
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    2e2e:	4b03      	ldr	r3, [pc, #12]	; (2e3c <nrfx_power_clock_irq_handler+0x60>)
    2e30:	2001      	movs	r0, #1
    2e32:	681b      	ldr	r3, [r3, #0]
    2e34:	4798      	blx	r3
}
    2e36:	e7f5      	b.n	2e24 <nrfx_power_clock_irq_handler+0x48>
    2e38:	40000100 	.word	0x40000100
    2e3c:	20000328 	.word	0x20000328
    2e40:	40000104 	.word	0x40000104
    2e44:	40000008 	.word	0x40000008

00002e48 <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
    2e48:	4b03      	ldr	r3, [pc, #12]	; (2e58 <pin_in_use_by_te+0x10>)
    2e4a:	3008      	adds	r0, #8
    2e4c:	0040      	lsls	r0, r0, #1
    2e4e:	5ac0      	ldrh	r0, [r0, r3]
    2e50:	0680      	lsls	r0, r0, #26
    2e52:	0fc0      	lsrs	r0, r0, #31
}
    2e54:	4770      	bx	lr
    2e56:	46c0      	nop			; (mov r8, r8)
    2e58:	2000001c 	.word	0x2000001c

00002e5c <pin_is_output>:
 *
 * @return True if pin is output.
 */
static bool pin_is_output(uint32_t pin)
{
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    2e5c:	4b03      	ldr	r3, [pc, #12]	; (2e6c <pin_is_output+0x10>)
    2e5e:	3008      	adds	r0, #8
    2e60:	0040      	lsls	r0, r0, #1
    2e62:	5ac0      	ldrh	r0, [r0, r3]
    2e64:	0780      	lsls	r0, r0, #30
    2e66:	0fc0      	lsrs	r0, r0, #31
}
    2e68:	4770      	bx	lr
    2e6a:	46c0      	nop			; (mov r8, r8)
    2e6c:	2000001c 	.word	0x2000001c

00002e70 <call_handler>:
}

/* Return handler associated with given pin or null. */
static nrfx_gpiote_handler_config_t const * channel_handler_get(nrfx_gpiote_pin_t pin)
{
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    2e70:	0003      	movs	r3, r0
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrfy_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
    2e72:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    2e74:	3308      	adds	r3, #8
    2e76:	4d0b      	ldr	r5, [pc, #44]	; (2ea4 <call_handler+0x34>)
    2e78:	005b      	lsls	r3, r3, #1
    2e7a:	5b5b      	ldrh	r3, [r3, r5]
{
    2e7c:	0004      	movs	r4, r0
    2e7e:	000e      	movs	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    2e80:	05da      	lsls	r2, r3, #23
    2e82:	d506      	bpl.n	2e92 <call_handler+0x22>
    2e84:	04db      	lsls	r3, r3, #19
    2e86:	0f1b      	lsrs	r3, r3, #28
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
    2e88:	00db      	lsls	r3, r3, #3
    2e8a:	18ea      	adds	r2, r5, r3
    2e8c:	6852      	ldr	r2, [r2, #4]
    2e8e:	595b      	ldr	r3, [r3, r5]
    2e90:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
    2e92:	68ab      	ldr	r3, [r5, #8]
    2e94:	2b00      	cmp	r3, #0
    2e96:	d003      	beq.n	2ea0 <call_handler+0x30>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
    2e98:	0031      	movs	r1, r6
    2e9a:	0020      	movs	r0, r4
    2e9c:	68ea      	ldr	r2, [r5, #12]
    2e9e:	4798      	blx	r3
    }
}
    2ea0:	bd70      	pop	{r4, r5, r6, pc}
    2ea2:	46c0      	nop			; (mov r8, r8)
    2ea4:	2000001c 	.word	0x2000001c

00002ea8 <release_handler>:
{
    2ea8:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    2eaa:	2480      	movs	r4, #128	; 0x80
    2eac:	4a18      	ldr	r2, [pc, #96]	; (2f10 <release_handler+0x68>)
    2eae:	3008      	adds	r0, #8
    2eb0:	0040      	lsls	r0, r0, #1
    2eb2:	5a83      	ldrh	r3, [r0, r2]
    2eb4:	0064      	lsls	r4, r4, #1
    2eb6:	4223      	tst	r3, r4
    2eb8:	d01c      	beq.n	2ef4 <release_handler+0x4c>
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
    2eba:	4e16      	ldr	r6, [pc, #88]	; (2f14 <release_handler+0x6c>)
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    2ebc:	0a59      	lsrs	r1, r3, #9
    2ebe:	250f      	movs	r5, #15
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
    2ec0:	4033      	ands	r3, r6
    2ec2:	5283      	strh	r3, [r0, r2]
    2ec4:	0016      	movs	r6, r2
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
    2ec6:	2000      	movs	r0, #0
    2ec8:	4029      	ands	r1, r5
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
    2eca:	8a33      	ldrh	r3, [r6, #16]
    2ecc:	4223      	tst	r3, r4
    2ece:	d003      	beq.n	2ed8 <release_handler+0x30>
    2ed0:	0a5b      	lsrs	r3, r3, #9
    2ed2:	402b      	ands	r3, r5
    2ed4:	4299      	cmp	r1, r3
    2ed6:	d00d      	beq.n	2ef4 <release_handler+0x4c>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
    2ed8:	3001      	adds	r0, #1
    2eda:	3602      	adds	r6, #2
    2edc:	2820      	cmp	r0, #32
    2ede:	d1f4      	bne.n	2eca <release_handler+0x22>
        m_cb.handlers[handler_id].handler = NULL;
    2ee0:	2000      	movs	r0, #0
    2ee2:	00cb      	lsls	r3, r1, #3
    2ee4:	50d0      	str	r0, [r2, r3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
    2ee6:	b2c9      	uxtb	r1, r1
    2ee8:	480b      	ldr	r0, [pc, #44]	; (2f18 <release_handler+0x70>)
    2eea:	f7ff fe03 	bl	2af4 <nrfx_flag32_free>
        NRFX_ASSERT(err == NRFX_SUCCESS);
    2eee:	4b0b      	ldr	r3, [pc, #44]	; (2f1c <release_handler+0x74>)
    2ef0:	4298      	cmp	r0, r3
    2ef2:	d100      	bne.n	2ef6 <release_handler+0x4e>
}
    2ef4:	bd70      	pop	{r4, r5, r6, pc}
        NRFX_ASSERT(err == NRFX_SUCCESS);
    2ef6:	2332      	movs	r3, #50	; 0x32
    2ef8:	4c09      	ldr	r4, [pc, #36]	; (2f20 <release_handler+0x78>)
    2efa:	490a      	ldr	r1, [pc, #40]	; (2f24 <release_handler+0x7c>)
    2efc:	480a      	ldr	r0, [pc, #40]	; (2f28 <release_handler+0x80>)
    2efe:	0022      	movs	r2, r4
    2f00:	33ff      	adds	r3, #255	; 0xff
    2f02:	f002 fcf1 	bl	58e8 <assert_print>
    2f06:	2132      	movs	r1, #50	; 0x32
    2f08:	0020      	movs	r0, r4
    2f0a:	31ff      	adds	r1, #255	; 0xff
    2f0c:	f002 fce8 	bl	58e0 <assert_post_action>
    2f10:	2000001c 	.word	0x2000001c
    2f14:	ffffe0ff 	.word	0xffffe0ff
    2f18:	20000070 	.word	0x20000070
    2f1c:	0bad0000 	.word	0x0bad0000
    2f20:	00006bd8 	.word	0x00006bd8
    2f24:	00006a97 	.word	0x00006a97
    2f28:	00006347 	.word	0x00006347

00002f2c <nrf_gpio_pin_present_check>:
{
    2f2c:	0003      	movs	r3, r0
    2f2e:	b510      	push	{r4, lr}
    uint32_t port = pin_number >> 5;
    2f30:	0942      	lsrs	r2, r0, #5
    switch (port)
    2f32:	d00a      	beq.n	2f4a <nrf_gpio_pin_present_check+0x1e>
            NRFX_ASSERT(0);
    2f34:	4c08      	ldr	r4, [pc, #32]	; (2f58 <nrf_gpio_pin_present_check+0x2c>)
    2f36:	4909      	ldr	r1, [pc, #36]	; (2f5c <nrf_gpio_pin_present_check+0x30>)
    2f38:	4809      	ldr	r0, [pc, #36]	; (2f60 <nrf_gpio_pin_present_check+0x34>)
    2f3a:	0022      	movs	r2, r4
    2f3c:	4b09      	ldr	r3, [pc, #36]	; (2f64 <nrf_gpio_pin_present_check+0x38>)
    2f3e:	f002 fcd3 	bl	58e8 <assert_print>
    2f42:	0020      	movs	r0, r4
    2f44:	4907      	ldr	r1, [pc, #28]	; (2f64 <nrf_gpio_pin_present_check+0x38>)
    2f46:	f002 fccb 	bl	58e0 <assert_post_action>
    return (mask & (1UL << pin_number)) ? true : false;
    2f4a:	2001      	movs	r0, #1
    2f4c:	4240      	negs	r0, r0
    2f4e:	40d8      	lsrs	r0, r3
    2f50:	2301      	movs	r3, #1
    2f52:	4018      	ands	r0, r3
}
    2f54:	bd10      	pop	{r4, pc}
    2f56:	46c0      	nop			; (mov r8, r8)
    2f58:	00006a09 	.word	0x00006a09
    2f5c:	00006f16 	.word	0x00006f16
    2f60:	00006347 	.word	0x00006347
    2f64:	00000516 	.word	0x00000516

00002f68 <nrf_gpio_pin_port_decode>:
{
    2f68:	b570      	push	{r4, r5, r6, lr}
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
    2f6a:	6804      	ldr	r4, [r0, #0]
{
    2f6c:	0005      	movs	r5, r0
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
    2f6e:	0020      	movs	r0, r4
    2f70:	f7ff ffdc 	bl	2f2c <nrf_gpio_pin_present_check>
    2f74:	2800      	cmp	r0, #0
    2f76:	d10a      	bne.n	2f8e <nrf_gpio_pin_port_decode+0x26>
    2f78:	4c0e      	ldr	r4, [pc, #56]	; (2fb4 <nrf_gpio_pin_port_decode+0x4c>)
    2f7a:	490f      	ldr	r1, [pc, #60]	; (2fb8 <nrf_gpio_pin_port_decode+0x50>)
    2f7c:	0022      	movs	r2, r4
    2f7e:	480f      	ldr	r0, [pc, #60]	; (2fbc <nrf_gpio_pin_port_decode+0x54>)
    2f80:	4b0f      	ldr	r3, [pc, #60]	; (2fc0 <nrf_gpio_pin_port_decode+0x58>)
    2f82:	f002 fcb1 	bl	58e8 <assert_print>
    2f86:	490e      	ldr	r1, [pc, #56]	; (2fc0 <nrf_gpio_pin_port_decode+0x58>)
            NRFX_ASSERT(0);
    2f88:	0020      	movs	r0, r4
    2f8a:	f002 fca9 	bl	58e0 <assert_post_action>
    *p_pin = NRF_PIN_NUMBER_TO_PIN(pin_number);
    2f8e:	231f      	movs	r3, #31
    2f90:	4023      	ands	r3, r4
    2f92:	602b      	str	r3, [r5, #0]
    return NRF_PIN_NUMBER_TO_PORT(pin_number);
    2f94:	0964      	lsrs	r4, r4, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    2f96:	d00a      	beq.n	2fae <nrf_gpio_pin_port_decode+0x46>
            NRFX_ASSERT(0);
    2f98:	23ce      	movs	r3, #206	; 0xce
    2f9a:	4c06      	ldr	r4, [pc, #24]	; (2fb4 <nrf_gpio_pin_port_decode+0x4c>)
    2f9c:	4909      	ldr	r1, [pc, #36]	; (2fc4 <nrf_gpio_pin_port_decode+0x5c>)
    2f9e:	0022      	movs	r2, r4
    2fa0:	4806      	ldr	r0, [pc, #24]	; (2fbc <nrf_gpio_pin_port_decode+0x54>)
    2fa2:	009b      	lsls	r3, r3, #2
    2fa4:	f002 fca0 	bl	58e8 <assert_print>
    2fa8:	21ce      	movs	r1, #206	; 0xce
    2faa:	0089      	lsls	r1, r1, #2
    2fac:	e7ec      	b.n	2f88 <nrf_gpio_pin_port_decode+0x20>
}
    2fae:	20a0      	movs	r0, #160	; 0xa0
    2fb0:	05c0      	lsls	r0, r0, #23
    2fb2:	bd70      	pop	{r4, r5, r6, pc}
    2fb4:	00006a09 	.word	0x00006a09
    2fb8:	00006a3c 	.word	0x00006a3c
    2fbc:	00006347 	.word	0x00006347
    2fc0:	0000032f 	.word	0x0000032f
    2fc4:	00006f16 	.word	0x00006f16

00002fc8 <nrf_gpiote_in_event_get>:
    return (nrf_gpiote_task_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, TASKS_CLR[index]);
}
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    2fc8:	b510      	push	{r4, lr}
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    2fca:	2803      	cmp	r0, #3
    2fcc:	d90a      	bls.n	2fe4 <nrf_gpiote_in_event_get+0x1c>
    2fce:	4c07      	ldr	r4, [pc, #28]	; (2fec <nrf_gpiote_in_event_get+0x24>)
    2fd0:	4907      	ldr	r1, [pc, #28]	; (2ff0 <nrf_gpiote_in_event_get+0x28>)
    2fd2:	4808      	ldr	r0, [pc, #32]	; (2ff4 <nrf_gpiote_in_event_get+0x2c>)
    2fd4:	0022      	movs	r2, r4
    2fd6:	4b08      	ldr	r3, [pc, #32]	; (2ff8 <nrf_gpiote_in_event_get+0x30>)
    2fd8:	f002 fc86 	bl	58e8 <assert_print>
    2fdc:	0020      	movs	r0, r4
    2fde:	4906      	ldr	r1, [pc, #24]	; (2ff8 <nrf_gpiote_in_event_get+0x30>)
    2fe0:	f002 fc7e 	bl	58e0 <assert_post_action>
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
    2fe4:	0080      	lsls	r0, r0, #2
    2fe6:	3001      	adds	r0, #1
    2fe8:	30ff      	adds	r0, #255	; 0xff
}
    2fea:	bd10      	pop	{r4, pc}
    2fec:	00006b99 	.word	0x00006b99
    2ff0:	00006bce 	.word	0x00006bce
    2ff4:	00006347 	.word	0x00006347
    2ff8:	000002aa 	.word	0x000002aa

00002ffc <__nrfy_internal_gpiote_events_process.constprop.0>:
        return true;
    }
    return false;
}

NRFY_STATIC_INLINE uint32_t __nrfy_internal_gpiote_events_process(NRF_GPIOTE_Type * p_reg,
    2ffc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
                                                                  uint32_t          mask)
{
    uint32_t event_mask = 0;
    2ffe:	2400      	movs	r4, #0
NRFY_STATIC_INLINE uint32_t __nrfy_internal_gpiote_events_process(NRF_GPIOTE_Type * p_reg,
    3000:	0006      	movs	r6, r0

    nrf_barrier_r();
    for (uint8_t i = 0; i < GPIOTE_CH_NUM; i++)
    3002:	0025      	movs	r5, r4
    if ((mask & NRFY_EVENT_TO_INT_BITMASK(event)) && nrf_gpiote_event_check(p_reg, event))
    3004:	2701      	movs	r7, #1
    {
        (void)__nrfy_internal_gpiote_event_handle(p_reg,
    3006:	0028      	movs	r0, r5
    3008:	f7ff ffde 	bl	2fc8 <nrf_gpiote_in_event_get>
    if ((mask & NRFY_EVENT_TO_INT_BITMASK(event)) && nrf_gpiote_event_check(p_reg, event))
    300c:	003a      	movs	r2, r7
    300e:	1e43      	subs	r3, r0, #1
    3010:	3bff      	subs	r3, #255	; 0xff
    3012:	089b      	lsrs	r3, r3, #2
    3014:	409a      	lsls	r2, r3
    3016:	0013      	movs	r3, r2
    3018:	4232      	tst	r2, r6
    301a:	d007      	beq.n	302c <__nrfy_internal_gpiote_events_process.constprop.0+0x30>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    301c:	4a0b      	ldr	r2, [pc, #44]	; (304c <__nrfy_internal_gpiote_events_process.constprop.0+0x50>)
    301e:	1880      	adds	r0, r0, r2
    3020:	6802      	ldr	r2, [r0, #0]
    3022:	2a00      	cmp	r2, #0
    3024:	d002      	beq.n	302c <__nrfy_internal_gpiote_events_process.constprop.0+0x30>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    3026:	2200      	movs	r2, #0
            *p_evt_mask |= NRFY_EVENT_TO_INT_BITMASK(event);
    3028:	431c      	orrs	r4, r3
    302a:	6002      	str	r2, [r0, #0]
    for (uint8_t i = 0; i < GPIOTE_CH_NUM; i++)
    302c:	3501      	adds	r5, #1
    302e:	b2ed      	uxtb	r5, r5
    3030:	2d04      	cmp	r5, #4
    3032:	d1e8      	bne.n	3006 <__nrfy_internal_gpiote_events_process.constprop.0+0xa>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    3034:	4b06      	ldr	r3, [pc, #24]	; (3050 <__nrfy_internal_gpiote_events_process.constprop.0+0x54>)
    3036:	681a      	ldr	r2, [r3, #0]
    if ((mask & NRFY_EVENT_TO_INT_BITMASK(event)) && nrf_gpiote_event_check(p_reg, event))
    3038:	2a00      	cmp	r2, #0
    303a:	d004      	beq.n	3046 <__nrfy_internal_gpiote_events_process.constprop.0+0x4a>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    303c:	2200      	movs	r2, #0
    303e:	601a      	str	r2, [r3, #0]
            *p_evt_mask |= NRFY_EVENT_TO_INT_BITMASK(event);
    3040:	2380      	movs	r3, #128	; 0x80
    3042:	061b      	lsls	r3, r3, #24
    3044:	431c      	orrs	r4, r3
    }

    (void)__nrfy_internal_gpiote_event_handle(p_reg, mask, NRF_GPIOTE_EVENT_PORT, &event_mask);

    return event_mask;
}
    3046:	0020      	movs	r0, r4
    3048:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    304a:	46c0      	nop			; (mov r8, r8)
    304c:	40006000 	.word	0x40006000
    3050:	4000617c 	.word	0x4000617c

00003054 <nrfx_gpiote_input_configure>:
{
    3054:	b5f0      	push	{r4, r5, r6, r7, lr}
    3056:	b089      	sub	sp, #36	; 0x24
    3058:	0007      	movs	r7, r0
    305a:	000c      	movs	r4, r1
    305c:	0015      	movs	r5, r2
    305e:	9303      	str	r3, [sp, #12]
    if (p_input_config)
    3060:	2900      	cmp	r1, #0
    3062:	d01a      	beq.n	309a <nrfx_gpiote_input_configure+0x46>
        if (pin_is_task_output(pin))
    3064:	f002 fd89 	bl	5b7a <pin_is_task_output>
    3068:	2800      	cmp	r0, #0
    306a:	d121      	bne.n	30b0 <nrfx_gpiote_input_configure+0x5c>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
    306c:	210e      	movs	r1, #14
        nrf_gpio_pin_input_t input_connect = NRF_GPIO_PIN_INPUT_CONNECT;
    306e:	220f      	movs	r2, #15
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
    3070:	ab04      	add	r3, sp, #16
    3072:	18c9      	adds	r1, r1, r3
        nrf_gpio_pin_input_t input_connect = NRF_GPIO_PIN_INPUT_CONNECT;
    3074:	18d2      	adds	r2, r2, r3
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
    3076:	7008      	strb	r0, [r1, #0]
        nrf_gpio_pin_input_t input_connect = NRF_GPIO_PIN_INPUT_CONNECT;
    3078:	7010      	strb	r0, [r2, #0]
                                              const nrf_gpio_pin_input_t * p_input,
                                              const nrf_gpio_pin_pull_t *  p_pull,
                                              const nrf_gpio_pin_drive_t * p_drive,
                                              const nrf_gpio_pin_sense_t * p_sense)
{
    nrf_gpio_reconfigure(pin_number, p_dir, p_input, p_pull, p_drive, p_sense);
    307a:	0023      	movs	r3, r4
    307c:	9001      	str	r0, [sp, #4]
    307e:	9000      	str	r0, [sp, #0]
    3080:	0038      	movs	r0, r7
    3082:	f002 fd88 	bl	5b96 <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
    3086:	003a      	movs	r2, r7
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
    3088:	2102      	movs	r1, #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
    308a:	4b51      	ldr	r3, [pc, #324]	; (31d0 <nrfx_gpiote_input_configure+0x17c>)
    308c:	3208      	adds	r2, #8
    308e:	0052      	lsls	r2, r2, #1
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
    3090:	5ad0      	ldrh	r0, [r2, r3]
    3092:	4388      	bics	r0, r1
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
    3094:	3901      	subs	r1, #1
    3096:	4301      	orrs	r1, r0
    3098:	52d1      	strh	r1, [r2, r3]
    if (p_trigger_config)
    309a:	2d00      	cmp	r5, #0
    309c:	d03a      	beq.n	3114 <nrfx_gpiote_input_configure+0xc0>
        if (pin_is_output(pin))
    309e:	0038      	movs	r0, r7
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
    30a0:	782c      	ldrb	r4, [r5, #0]
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
    30a2:	686e      	ldr	r6, [r5, #4]
        if (pin_is_output(pin))
    30a4:	f7ff feda 	bl	2e5c <pin_is_output>
    30a8:	2800      	cmp	r0, #0
    30aa:	d003      	beq.n	30b4 <nrfx_gpiote_input_configure+0x60>
            if (use_evt)
    30ac:	2e00      	cmp	r6, #0
    30ae:	d057      	beq.n	3160 <nrfx_gpiote_input_configure+0x10c>
            return NRFX_ERROR_INVALID_PARAM;
    30b0:	4848      	ldr	r0, [pc, #288]	; (31d4 <nrfx_gpiote_input_configure+0x180>)
    30b2:	e033      	b.n	311c <nrfx_gpiote_input_configure+0xc8>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
    30b4:	4b46      	ldr	r3, [pc, #280]	; (31d0 <nrfx_gpiote_input_configure+0x17c>)
    30b6:	9304      	str	r3, [sp, #16]
    30b8:	003b      	movs	r3, r7
    30ba:	3308      	adds	r3, #8
    30bc:	005b      	lsls	r3, r3, #1
    30be:	469c      	mov	ip, r3
    30c0:	4662      	mov	r2, ip
    30c2:	9b04      	ldr	r3, [sp, #16]
    30c4:	5ad2      	ldrh	r2, [r2, r3]
    30c6:	4b44      	ldr	r3, [pc, #272]	; (31d8 <nrfx_gpiote_input_configure+0x184>)
    30c8:	401a      	ands	r2, r3
    30ca:	9205      	str	r2, [sp, #20]
    30cc:	4662      	mov	r2, ip
    30ce:	9b04      	ldr	r3, [sp, #16]
    30d0:	9905      	ldr	r1, [sp, #20]
    30d2:	52d1      	strh	r1, [r2, r3]
            if (use_evt)
    30d4:	2e00      	cmp	r6, #0
    30d6:	d043      	beq.n	3160 <nrfx_gpiote_input_configure+0x10c>
                if (!edge)
    30d8:	2c03      	cmp	r4, #3
    30da:	d8e9      	bhi.n	30b0 <nrfx_gpiote_input_configure+0x5c>
                uint8_t ch = *p_trigger_config->p_in_channel;
    30dc:	686b      	ldr	r3, [r5, #4]
    30de:	781b      	ldrb	r3, [r3, #0]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
    30e0:	2c00      	cmp	r4, #0
    30e2:	d11d      	bne.n	3120 <nrfx_gpiote_input_configure+0xcc>
    p_reg->CONFIG[idx] = 0;
    30e4:	3345      	adds	r3, #69	; 0x45
    30e6:	4a3d      	ldr	r2, [pc, #244]	; (31dc <nrfx_gpiote_input_configure+0x188>)
    30e8:	33ff      	adds	r3, #255	; 0xff
    30ea:	009b      	lsls	r3, r3, #2
    30ec:	509c      	str	r4, [r3, r2]
 */
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    30ee:	2107      	movs	r1, #7
    p_mask8[byte_idx] &= ~(1 << bit);
    30f0:	2001      	movs	r0, #1
    bit = BITMASK_RELBIT_GET(bit);
    30f2:	4039      	ands	r1, r7
    p_mask8[byte_idx] &= ~(1 << bit);
    30f4:	4088      	lsls	r0, r1
    30f6:	4a3a      	ldr	r2, [pc, #232]	; (31e0 <nrfx_gpiote_input_configure+0x18c>)
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    30f8:	08fb      	lsrs	r3, r7, #3
    p_mask8[byte_idx] &= ~(1 << bit);
    30fa:	5cd1      	ldrb	r1, [r2, r3]
    30fc:	4381      	bics	r1, r0
    30fe:	54d1      	strb	r1, [r2, r3]
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
    3100:	0039      	movs	r1, r7
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
    3102:	201c      	movs	r0, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
    3104:	4a32      	ldr	r2, [pc, #200]	; (31d0 <nrfx_gpiote_input_configure+0x17c>)
    3106:	3108      	adds	r1, #8
    3108:	0049      	lsls	r1, r1, #1
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
    310a:	5a8b      	ldrh	r3, [r1, r2]
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
    310c:	00a4      	lsls	r4, r4, #2
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
    310e:	4383      	bics	r3, r0
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
    3110:	4323      	orrs	r3, r4
    3112:	528b      	strh	r3, [r1, r2]
    if (p_handler_config)
    3114:	9b03      	ldr	r3, [sp, #12]
    3116:	2b00      	cmp	r3, #0
    3118:	d12f      	bne.n	317a <nrfx_gpiote_input_configure+0x126>
        err = NRFX_SUCCESS;
    311a:	4832      	ldr	r0, [pc, #200]	; (31e4 <nrfx_gpiote_input_configure+0x190>)
}
    311c:	b009      	add	sp, #36	; 0x24
    311e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    3120:	20a2      	movs	r0, #162	; 0xa2
    3122:	2503      	movs	r5, #3
    3124:	492d      	ldr	r1, [pc, #180]	; (31dc <nrfx_gpiote_input_configure+0x188>)
    3126:	009a      	lsls	r2, r3, #2
    3128:	1852      	adds	r2, r2, r1
    312a:	00c0      	lsls	r0, r0, #3
    312c:	5811      	ldr	r1, [r2, r0]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    312e:	023e      	lsls	r6, r7, #8
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    3130:	43a9      	bics	r1, r5
    3132:	5011      	str	r1, [r2, r0]
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    3134:	5811      	ldr	r1, [r2, r0]
    3136:	4d2c      	ldr	r5, [pc, #176]	; (31e8 <nrfx_gpiote_input_configure+0x194>)
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
    3138:	035b      	lsls	r3, r3, #13
    313a:	4029      	ands	r1, r5
    313c:	5011      	str	r1, [r2, r0]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    313e:	21f8      	movs	r1, #248	; 0xf8
    3140:	0149      	lsls	r1, r1, #5
    3142:	5815      	ldr	r5, [r2, r0]
    3144:	4031      	ands	r1, r6
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
    3146:	0426      	lsls	r6, r4, #16
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    3148:	4331      	orrs	r1, r6
    314a:	4329      	orrs	r1, r5
    314c:	5011      	str	r1, [r2, r0]
    314e:	9a05      	ldr	r2, [sp, #20]
    3150:	4661      	mov	r1, ip
    3152:	431a      	orrs	r2, r3
    3154:	0013      	movs	r3, r2
    3156:	2220      	movs	r2, #32
    3158:	4313      	orrs	r3, r2
    315a:	9a04      	ldr	r2, [sp, #16]
    315c:	528b      	strh	r3, [r1, r2]
    315e:	e7c6      	b.n	30ee <nrfx_gpiote_input_configure+0x9a>
    p_mask8[byte_idx] |= (1 << bit);
    3160:	4a1f      	ldr	r2, [pc, #124]	; (31e0 <nrfx_gpiote_input_configure+0x18c>)
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    3162:	08fb      	lsrs	r3, r7, #3
    p_mask8[byte_idx] |= (1 << bit);
    3164:	1899      	adds	r1, r3, r2
    3166:	5cd3      	ldrb	r3, [r2, r3]
        if (use_evt || trigger == NRFX_GPIOTE_TRIGGER_NONE)
    3168:	2c00      	cmp	r4, #0
    316a:	d0c0      	beq.n	30ee <nrfx_gpiote_input_configure+0x9a>
    bit = BITMASK_RELBIT_GET(bit);
    316c:	2007      	movs	r0, #7
    p_mask8[byte_idx] |= (1 << bit);
    316e:	2201      	movs	r2, #1
    bit = BITMASK_RELBIT_GET(bit);
    3170:	4038      	ands	r0, r7
    p_mask8[byte_idx] |= (1 << bit);
    3172:	4082      	lsls	r2, r0
    3174:	4313      	orrs	r3, r2
    3176:	700b      	strb	r3, [r1, #0]
}
    3178:	e7c2      	b.n	3100 <nrfx_gpiote_input_configure+0xac>
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
    317a:	9b03      	ldr	r3, [sp, #12]
    release_handler(pin);
    317c:	0038      	movs	r0, r7
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
    317e:	cb60      	ldmia	r3!, {r5, r6}
    release_handler(pin);
    3180:	f7ff fe92 	bl	2ea8 <release_handler>
    if (!handler)
    3184:	2d00      	cmp	r5, #0
    3186:	d0c8      	beq.n	311a <nrfx_gpiote_input_configure+0xc6>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
    3188:	4c11      	ldr	r4, [pc, #68]	; (31d0 <nrfx_gpiote_input_configure+0x17c>)
    318a:	6822      	ldr	r2, [r4, #0]
    318c:	6863      	ldr	r3, [r4, #4]
    318e:	4295      	cmp	r5, r2
    3190:	d101      	bne.n	3196 <nrfx_gpiote_input_configure+0x142>
    3192:	429e      	cmp	r6, r3
    3194:	d01a      	beq.n	31cc <nrfx_gpiote_input_configure+0x178>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
    3196:	230f      	movs	r3, #15
    3198:	aa04      	add	r2, sp, #16
    319a:	189b      	adds	r3, r3, r2
    319c:	0019      	movs	r1, r3
    319e:	4813      	ldr	r0, [pc, #76]	; (31ec <nrfx_gpiote_input_configure+0x198>)
    31a0:	f7ff fc88 	bl	2ab4 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
    31a4:	4b0f      	ldr	r3, [pc, #60]	; (31e4 <nrfx_gpiote_input_configure+0x190>)
    31a6:	4298      	cmp	r0, r3
    31a8:	d1b8      	bne.n	311c <nrfx_gpiote_input_configure+0xc8>
        handler_id = (int32_t)id;
    31aa:	ab04      	add	r3, sp, #16
    31ac:	7bda      	ldrb	r2, [r3, #15]
    m_cb.handlers[handler_id].handler = handler;
    31ae:	00d3      	lsls	r3, r2, #3
    31b0:	50e5      	str	r5, [r4, r3]
    m_cb.handlers[handler_id].p_context = p_context;
    31b2:	18e3      	adds	r3, r4, r3
    31b4:	605e      	str	r6, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
    31b6:	003b      	movs	r3, r7
    31b8:	3308      	adds	r3, #8
    31ba:	005b      	lsls	r3, r3, #1
    31bc:	5ae1      	ldrh	r1, [r4, r3]
    31be:	0252      	lsls	r2, r2, #9
    31c0:	4311      	orrs	r1, r2
    31c2:	2280      	movs	r2, #128	; 0x80
    31c4:	0052      	lsls	r2, r2, #1
    31c6:	430a      	orrs	r2, r1
    31c8:	52e2      	strh	r2, [r4, r3]
    return NRFX_SUCCESS;
    31ca:	e7a6      	b.n	311a <nrfx_gpiote_input_configure+0xc6>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
    31cc:	2200      	movs	r2, #0
    31ce:	e7ee      	b.n	31ae <nrfx_gpiote_input_configure+0x15a>
    31d0:	2000001c 	.word	0x2000001c
    31d4:	0bad0004 	.word	0x0bad0004
    31d8:	00001fdf 	.word	0x00001fdf
    31dc:	40006000 	.word	0x40006000
    31e0:	20000074 	.word	0x20000074
    31e4:	0bad0000 	.word	0x0bad0000
    31e8:	fffce0ff 	.word	0xfffce0ff
    31ec:	20000070 	.word	0x20000070

000031f0 <nrfx_gpiote_output_configure>:
{
    31f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    31f2:	b089      	sub	sp, #36	; 0x24
    31f4:	000c      	movs	r4, r1
    31f6:	0015      	movs	r5, r2
    31f8:	9003      	str	r0, [sp, #12]
    if (p_config)
    31fa:	2900      	cmp	r1, #0
    31fc:	d025      	beq.n	324a <nrfx_gpiote_output_configure+0x5a>
    return !pin_is_output(pin);
    31fe:	f7ff fe2d 	bl	2e5c <pin_is_output>
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
    3202:	2800      	cmp	r0, #0
    3204:	d104      	bne.n	3210 <nrfx_gpiote_output_configure+0x20>
    3206:	9803      	ldr	r0, [sp, #12]
    3208:	f7ff fe1e 	bl	2e48 <pin_in_use_by_te>
    320c:	2800      	cmp	r0, #0
    320e:	d15d      	bne.n	32cc <nrfx_gpiote_output_configure+0xdc>
    return PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]) != NRFX_GPIOTE_TRIGGER_NONE;
    3210:	9e03      	ldr	r6, [sp, #12]
    3212:	4f2f      	ldr	r7, [pc, #188]	; (32d0 <nrfx_gpiote_output_configure+0xe0>)
    3214:	3608      	adds	r6, #8
    3216:	0073      	lsls	r3, r6, #1
    3218:	5bdb      	ldrh	r3, [r3, r7]
    321a:	06db      	lsls	r3, r3, #27
    321c:	0f5b      	lsrs	r3, r3, #29
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
    321e:	d002      	beq.n	3226 <nrfx_gpiote_output_configure+0x36>
    3220:	7863      	ldrb	r3, [r4, #1]
    3222:	2b01      	cmp	r3, #1
    3224:	d052      	beq.n	32cc <nrfx_gpiote_output_configure+0xdc>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_OUTPUT;
    3226:	210f      	movs	r1, #15
    3228:	ab04      	add	r3, sp, #16
    322a:	18c9      	adds	r1, r1, r3
    322c:	2000      	movs	r0, #0
    322e:	2301      	movs	r3, #1
        nrfy_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
    3230:	1c62      	adds	r2, r4, #1
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_OUTPUT;
    3232:	700b      	strb	r3, [r1, #0]
        nrfy_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
    3234:	1ca3      	adds	r3, r4, #2
    3236:	9001      	str	r0, [sp, #4]
    3238:	9400      	str	r4, [sp, #0]
    323a:	9803      	ldr	r0, [sp, #12]
    323c:	f002 fcab 	bl	5b96 <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
    3240:	2303      	movs	r3, #3
    3242:	0076      	lsls	r6, r6, #1
    3244:	5bba      	ldrh	r2, [r7, r6]
    3246:	4313      	orrs	r3, r2
    3248:	53bb      	strh	r3, [r7, r6]
    if (p_task_config)
    324a:	2d00      	cmp	r5, #0
    324c:	d102      	bne.n	3254 <nrfx_gpiote_output_configure+0x64>
    return NRFX_SUCCESS;
    324e:	4821      	ldr	r0, [pc, #132]	; (32d4 <nrfx_gpiote_output_configure+0xe4>)
}
    3250:	b009      	add	sp, #36	; 0x24
    3252:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return !pin_is_output(pin);
    3254:	9803      	ldr	r0, [sp, #12]
    3256:	f7ff fe01 	bl	2e5c <pin_is_output>
        if (pin_is_input(pin))
    325a:	2800      	cmp	r0, #0
    325c:	d036      	beq.n	32cc <nrfx_gpiote_output_configure+0xdc>
        uint32_t ch = p_task_config->task_ch;
    325e:	782e      	ldrb	r6, [r5, #0]
    p_reg->CONFIG[idx] = 0;
    3260:	4b1d      	ldr	r3, [pc, #116]	; (32d8 <nrfx_gpiote_output_configure+0xe8>)
    3262:	24a2      	movs	r4, #162	; 0xa2
    3264:	00b1      	lsls	r1, r6, #2
    3266:	18c9      	adds	r1, r1, r3
    3268:	2300      	movs	r3, #0
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
    326a:	9803      	ldr	r0, [sp, #12]
    326c:	4f18      	ldr	r7, [pc, #96]	; (32d0 <nrfx_gpiote_output_configure+0xe0>)
    326e:	3008      	adds	r0, #8
    3270:	0040      	lsls	r0, r0, #1
    3272:	00e4      	lsls	r4, r4, #3
    3274:	5bc2      	ldrh	r2, [r0, r7]
    3276:	510b      	str	r3, [r1, r4]
    3278:	4b18      	ldr	r3, [pc, #96]	; (32dc <nrfx_gpiote_output_configure+0xec>)
    327a:	401a      	ands	r2, r3
    327c:	53c2      	strh	r2, [r0, r7]
    327e:	4694      	mov	ip, r2
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
    3280:	786a      	ldrb	r2, [r5, #1]
    3282:	2a00      	cmp	r2, #0
    3284:	d0e3      	beq.n	324e <nrfx_gpiote_output_configure+0x5e>
                                       p_task_config->init_val);
    3286:	78ab      	ldrb	r3, [r5, #2]
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
    3288:	4d15      	ldr	r5, [pc, #84]	; (32e0 <nrfx_gpiote_output_configure+0xf0>)
    328a:	9304      	str	r3, [sp, #16]
    328c:	590b      	ldr	r3, [r1, r4]
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
    328e:	0412      	lsls	r2, r2, #16
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
    3290:	402b      	ands	r3, r5
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    3292:	25f8      	movs	r5, #248	; 0xf8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
    3294:	510b      	str	r3, [r1, r4]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    3296:	590b      	ldr	r3, [r1, r4]
    3298:	016d      	lsls	r5, r5, #5
    329a:	9305      	str	r3, [sp, #20]
    329c:	9b03      	ldr	r3, [sp, #12]
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
    329e:	0376      	lsls	r6, r6, #13
    32a0:	021b      	lsls	r3, r3, #8
    32a2:	402b      	ands	r3, r5
    32a4:	9d05      	ldr	r5, [sp, #20]
    32a6:	432b      	orrs	r3, r5
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
    32a8:	25c0      	movs	r5, #192	; 0xc0
    32aa:	02ad      	lsls	r5, r5, #10
    32ac:	402a      	ands	r2, r5
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
    32ae:	2580      	movs	r5, #128	; 0x80
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    32b0:	431a      	orrs	r2, r3
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
    32b2:	9b04      	ldr	r3, [sp, #16]
    32b4:	036d      	lsls	r5, r5, #13
    32b6:	051b      	lsls	r3, r3, #20
    32b8:	402b      	ands	r3, r5
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    32ba:	431a      	orrs	r2, r3
    32bc:	4663      	mov	r3, ip
    32be:	4333      	orrs	r3, r6
    32c0:	001e      	movs	r6, r3
    32c2:	2320      	movs	r3, #32
    32c4:	4333      	orrs	r3, r6
    32c6:	510a      	str	r2, [r1, r4]
    32c8:	53c3      	strh	r3, [r0, r7]
    32ca:	e7c0      	b.n	324e <nrfx_gpiote_output_configure+0x5e>
{
    32cc:	4805      	ldr	r0, [pc, #20]	; (32e4 <nrfx_gpiote_output_configure+0xf4>)
    32ce:	e7bf      	b.n	3250 <nrfx_gpiote_output_configure+0x60>
    32d0:	2000001c 	.word	0x2000001c
    32d4:	0bad0000 	.word	0x0bad0000
    32d8:	40006000 	.word	0x40006000
    32dc:	00001fdf 	.word	0x00001fdf
    32e0:	ffece0ff 	.word	0xffece0ff
    32e4:	0bad0004 	.word	0x0bad0004

000032e8 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
    32e8:	4b01      	ldr	r3, [pc, #4]	; (32f0 <nrfx_gpiote_global_callback_set+0x8>)
    32ea:	6098      	str	r0, [r3, #8]
    m_cb.global_handler.p_context = p_context;
    32ec:	60d9      	str	r1, [r3, #12]
}
    32ee:	4770      	bx	lr
    32f0:	2000001c 	.word	0x2000001c

000032f4 <nrfx_gpiote_channel_get>:
{
    32f4:	b570      	push	{r4, r5, r6, lr}
    32f6:	0004      	movs	r4, r0
    32f8:	1e0d      	subs	r5, r1, #0
    NRFX_ASSERT(p_channel);
    32fa:	d10c      	bne.n	3316 <nrfx_gpiote_channel_get+0x22>
    32fc:	238d      	movs	r3, #141	; 0x8d
    32fe:	4c0d      	ldr	r4, [pc, #52]	; (3334 <nrfx_gpiote_channel_get+0x40>)
    3300:	490d      	ldr	r1, [pc, #52]	; (3338 <nrfx_gpiote_channel_get+0x44>)
    3302:	480e      	ldr	r0, [pc, #56]	; (333c <nrfx_gpiote_channel_get+0x48>)
    3304:	0022      	movs	r2, r4
    3306:	009b      	lsls	r3, r3, #2
    3308:	f002 faee 	bl	58e8 <assert_print>
    330c:	218d      	movs	r1, #141	; 0x8d
    330e:	0020      	movs	r0, r4
    3310:	0089      	lsls	r1, r1, #2
    3312:	f002 fae5 	bl	58e0 <assert_post_action>
    if (pin_in_use_by_te(pin))
    3316:	f7ff fd97 	bl	2e48 <pin_in_use_by_te>
    331a:	2800      	cmp	r0, #0
    331c:	d007      	beq.n	332e <nrfx_gpiote_channel_get+0x3a>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    331e:	4b08      	ldr	r3, [pc, #32]	; (3340 <nrfx_gpiote_channel_get+0x4c>)
    3320:	3408      	adds	r4, #8
    3322:	0064      	lsls	r4, r4, #1
    3324:	5ae3      	ldrh	r3, [r4, r3]
        return NRFX_SUCCESS;
    3326:	4807      	ldr	r0, [pc, #28]	; (3344 <nrfx_gpiote_channel_get+0x50>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    3328:	0b5b      	lsrs	r3, r3, #13
    332a:	702b      	strb	r3, [r5, #0]
}
    332c:	bd70      	pop	{r4, r5, r6, pc}
        return NRFX_ERROR_INVALID_PARAM;
    332e:	4806      	ldr	r0, [pc, #24]	; (3348 <nrfx_gpiote_channel_get+0x54>)
    3330:	e7fc      	b.n	332c <nrfx_gpiote_channel_get+0x38>
    3332:	46c0      	nop			; (mov r8, r8)
    3334:	00006bd8 	.word	0x00006bd8
    3338:	00006c16 	.word	0x00006c16
    333c:	00006347 	.word	0x00006347
    3340:	2000001c 	.word	0x2000001c
    3344:	0bad0000 	.word	0x0bad0000
    3348:	0bad0004 	.word	0x0bad0004

0000334c <nrfx_gpiote_init>:
{
    334c:	b570      	push	{r4, r5, r6, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
    334e:	4b17      	ldr	r3, [pc, #92]	; (33ac <nrfx_gpiote_init+0x60>)
    3350:	4d17      	ldr	r5, [pc, #92]	; (33b0 <nrfx_gpiote_init+0x64>)
    3352:	781c      	ldrb	r4, [r3, #0]
    3354:	2c00      	cmp	r4, #0
    3356:	d127      	bne.n	33a8 <nrfx_gpiote_init+0x5c>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
    3358:	2240      	movs	r2, #64	; 0x40
    335a:	0021      	movs	r1, r4
    335c:	4815      	ldr	r0, [pc, #84]	; (33b4 <nrfx_gpiote_init+0x68>)
    335e:	f002 fb2b 	bl	59b8 <memset>
        __nrfy_internal_gpiote_event_enabled_clear(p_reg, mask, nrf_gpiote_in_event_get(i));
    3362:	0020      	movs	r0, r4
    3364:	f7ff fe30 	bl	2fc8 <nrf_gpiote_in_event_get>
    if (mask & NRFY_EVENT_TO_INT_BITMASK(event))
    3368:	1e43      	subs	r3, r0, #1
    336a:	3bff      	subs	r3, #255	; 0xff
    336c:	089b      	lsrs	r3, r3, #2
    336e:	2b1f      	cmp	r3, #31
    3370:	d103      	bne.n	337a <nrfx_gpiote_init+0x2e>
    return ((uint32_t)p_reg + event);
    3372:	4b11      	ldr	r3, [pc, #68]	; (33b8 <nrfx_gpiote_init+0x6c>)
    3374:	18c0      	adds	r0, r0, r3
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    3376:	2300      	movs	r3, #0
    3378:	6003      	str	r3, [r0, #0]
    for (uint8_t i = 0; i < GPIOTE_CH_NUM; i++)
    337a:	3401      	adds	r4, #1
    337c:	b2e4      	uxtb	r4, r4
    337e:	2c04      	cmp	r4, #4
    3380:	d1ef      	bne.n	3362 <nrfx_gpiote_init+0x16>
    3382:	2200      	movs	r2, #0
    3384:	4b0d      	ldr	r3, [pc, #52]	; (33bc <nrfx_gpiote_init+0x70>)
    NRFX_IRQ_ENABLE(irqn);
    3386:	2006      	movs	r0, #6
    3388:	601a      	str	r2, [r3, #0]
    338a:	f7fe f82b 	bl	13e4 <arch_irq_enable>
    p_reg->NRFX_CONCAT_2(INTENSET, NRF_GPIOTE_IRQ_GROUP) = mask;
    338e:	23c1      	movs	r3, #193	; 0xc1
    3390:	2180      	movs	r1, #128	; 0x80
    3392:	4a09      	ldr	r2, [pc, #36]	; (33b8 <nrfx_gpiote_init+0x6c>)
    3394:	009b      	lsls	r3, r3, #2
    3396:	0609      	lsls	r1, r1, #24
    3398:	50d1      	str	r1, [r2, r3]
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
    339a:	002a      	movs	r2, r5
    339c:	2301      	movs	r3, #1
    339e:	325c      	adds	r2, #92	; 0x5c
    return err_code;
    33a0:	4807      	ldr	r0, [pc, #28]	; (33c0 <nrfx_gpiote_init+0x74>)
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
    33a2:	7013      	strb	r3, [r2, #0]
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
    33a4:	656b      	str	r3, [r5, #84]	; 0x54
}
    33a6:	bd70      	pop	{r4, r5, r6, pc}
        return err_code;
    33a8:	4806      	ldr	r0, [pc, #24]	; (33c4 <nrfx_gpiote_init+0x78>)
    33aa:	e7fc      	b.n	33a6 <nrfx_gpiote_init+0x5a>
    33ac:	20000078 	.word	0x20000078
    33b0:	2000001c 	.word	0x2000001c
    33b4:	2000002c 	.word	0x2000002c
    33b8:	40006000 	.word	0x40006000
    33bc:	4000617c 	.word	0x4000617c
    33c0:	0bad0000 	.word	0x0bad0000
    33c4:	0bad0005 	.word	0x0bad0005

000033c8 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
    33c8:	4b02      	ldr	r3, [pc, #8]	; (33d4 <nrfx_gpiote_is_init+0xc>)
    33ca:	7818      	ldrb	r0, [r3, #0]
    33cc:	1e43      	subs	r3, r0, #1
    33ce:	4198      	sbcs	r0, r3
    33d0:	b2c0      	uxtb	r0, r0
}
    33d2:	4770      	bx	lr
    33d4:	20000078 	.word	0x20000078

000033d8 <nrfx_gpiote_channel_free>:
{
    33d8:	b510      	push	{r4, lr}
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
    33da:	4b03      	ldr	r3, [pc, #12]	; (33e8 <nrfx_gpiote_channel_free+0x10>)
{
    33dc:	0001      	movs	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
    33de:	0018      	movs	r0, r3
    33e0:	f7ff fb88 	bl	2af4 <nrfx_flag32_free>
}
    33e4:	bd10      	pop	{r4, pc}
    33e6:	46c0      	nop			; (mov r8, r8)
    33e8:	2000006c 	.word	0x2000006c

000033ec <nrfx_gpiote_channel_alloc>:
{
    33ec:	b510      	push	{r4, lr}
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
    33ee:	4b03      	ldr	r3, [pc, #12]	; (33fc <nrfx_gpiote_channel_alloc+0x10>)
{
    33f0:	0001      	movs	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
    33f2:	0018      	movs	r0, r3
    33f4:	f7ff fb5e 	bl	2ab4 <nrfx_flag32_alloc>
}
    33f8:	bd10      	pop	{r4, pc}
    33fa:	46c0      	nop			; (mov r8, r8)
    33fc:	2000006c 	.word	0x2000006c

00003400 <nrfx_gpiote_trigger_enable>:
    return PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]) != NRFX_GPIOTE_TRIGGER_NONE;
    3400:	0002      	movs	r2, r0
{
    3402:	b5f0      	push	{r4, r5, r6, r7, lr}
    return PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]) != NRFX_GPIOTE_TRIGGER_NONE;
    3404:	4b2d      	ldr	r3, [pc, #180]	; (34bc <nrfx_gpiote_trigger_enable+0xbc>)
    3406:	3208      	adds	r2, #8
    3408:	0052      	lsls	r2, r2, #1
    340a:	5ad5      	ldrh	r5, [r2, r3]
{
    340c:	b085      	sub	sp, #20
    return PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]) != NRFX_GPIOTE_TRIGGER_NONE;
    340e:	06ee      	lsls	r6, r5, #27
{
    3410:	0004      	movs	r4, r0
    3412:	9101      	str	r1, [sp, #4]
    return PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]) != NRFX_GPIOTE_TRIGGER_NONE;
    3414:	0f76      	lsrs	r6, r6, #29
    NRFX_ASSERT(pin_has_trigger(pin));
    3416:	d10a      	bne.n	342e <nrfx_gpiote_trigger_enable+0x2e>
    3418:	4c29      	ldr	r4, [pc, #164]	; (34c0 <nrfx_gpiote_trigger_enable+0xc0>)
    341a:	492a      	ldr	r1, [pc, #168]	; (34c4 <nrfx_gpiote_trigger_enable+0xc4>)
    341c:	0022      	movs	r2, r4
    341e:	482a      	ldr	r0, [pc, #168]	; (34c8 <nrfx_gpiote_trigger_enable+0xc8>)
    3420:	4b2a      	ldr	r3, [pc, #168]	; (34cc <nrfx_gpiote_trigger_enable+0xcc>)
    3422:	f002 fa61 	bl	58e8 <assert_print>
    3426:	4929      	ldr	r1, [pc, #164]	; (34cc <nrfx_gpiote_trigger_enable+0xcc>)
        NRFX_ASSERT(int_enable);
    3428:	0020      	movs	r0, r4
    342a:	f002 fa59 	bl	58e0 <assert_post_action>
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    342e:	f7ff fd0b 	bl	2e48 <pin_in_use_by_te>
    3432:	2800      	cmp	r0, #0
    3434:	d01d      	beq.n	3472 <nrfx_gpiote_trigger_enable+0x72>
    return !pin_is_output(pin);
    3436:	0020      	movs	r0, r4
    3438:	f7ff fd10 	bl	2e5c <pin_is_output>
    343c:	1e07      	subs	r7, r0, #0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    343e:	d118      	bne.n	3472 <nrfx_gpiote_trigger_enable+0x72>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    3440:	0b6d      	lsrs	r5, r5, #13
        nrfy_gpiote_event_clear(NRF_GPIOTE, nrf_gpiote_in_event_get(ch));
    3442:	b2e8      	uxtb	r0, r5
    3444:	f7ff fdc0 	bl	2fc8 <nrf_gpiote_in_event_get>
    return ((uint32_t)p_reg + event);
    3448:	4b21      	ldr	r3, [pc, #132]	; (34d0 <nrfx_gpiote_trigger_enable+0xd0>)
    344a:	00aa      	lsls	r2, r5, #2
    344c:	18c0      	adds	r0, r0, r3
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    344e:	6007      	str	r7, [r0, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    3450:	20a2      	movs	r0, #162	; 0xa2
    3452:	18d2      	adds	r2, r2, r3
    3454:	2301      	movs	r3, #1
    3456:	00c0      	lsls	r0, r0, #3
    3458:	5811      	ldr	r1, [r2, r0]
    345a:	4319      	orrs	r1, r3
    345c:	5011      	str	r1, [r2, r0]
        if (int_enable)
    345e:	9a01      	ldr	r2, [sp, #4]
    3460:	2a00      	cmp	r2, #0
    3462:	d004      	beq.n	346e <nrfx_gpiote_trigger_enable+0x6e>
    p_reg->NRFX_CONCAT_2(INTENSET, NRF_GPIOTE_IRQ_GROUP) = mask;
    3464:	22c1      	movs	r2, #193	; 0xc1
            nrfy_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
    3466:	40ab      	lsls	r3, r5
    3468:	4919      	ldr	r1, [pc, #100]	; (34d0 <nrfx_gpiote_trigger_enable+0xd0>)
    346a:	0092      	lsls	r2, r2, #2
    346c:	508b      	str	r3, [r1, r2]
}
    346e:	b005      	add	sp, #20
    3470:	bdf0      	pop	{r4, r5, r6, r7, pc}
        NRFX_ASSERT(int_enable);
    3472:	9b01      	ldr	r3, [sp, #4]
    3474:	2b00      	cmp	r3, #0
    3476:	d10a      	bne.n	348e <nrfx_gpiote_trigger_enable+0x8e>
    3478:	23cb      	movs	r3, #203	; 0xcb
    347a:	4c11      	ldr	r4, [pc, #68]	; (34c0 <nrfx_gpiote_trigger_enable+0xc0>)
    347c:	4915      	ldr	r1, [pc, #84]	; (34d4 <nrfx_gpiote_trigger_enable+0xd4>)
    347e:	0022      	movs	r2, r4
    3480:	4811      	ldr	r0, [pc, #68]	; (34c8 <nrfx_gpiote_trigger_enable+0xc8>)
    3482:	009b      	lsls	r3, r3, #2
    3484:	f002 fa30 	bl	58e8 <assert_print>
    3488:	21cb      	movs	r1, #203	; 0xcb
    348a:	0089      	lsls	r1, r1, #2
    348c:	e7cc      	b.n	3428 <nrfx_gpiote_trigger_enable+0x28>
        sense = NRF_GPIO_PIN_SENSE_LOW;
    348e:	2103      	movs	r1, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
    3490:	2e04      	cmp	r6, #4
    3492:	d00e      	beq.n	34b2 <nrfx_gpiote_trigger_enable+0xb2>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
    3494:	3901      	subs	r1, #1
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
    3496:	2e05      	cmp	r6, #5
    3498:	d00b      	beq.n	34b2 <nrfx_gpiote_trigger_enable+0xb2>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    349a:	a803      	add	r0, sp, #12
    349c:	9403      	str	r4, [sp, #12]
    349e:	f7ff fd63 	bl	2f68 <nrf_gpio_pin_port_decode>
    return p_reg->IN;
    34a2:	23a2      	movs	r3, #162	; 0xa2
    34a4:	00db      	lsls	r3, r3, #3
    34a6:	58c1      	ldr	r1, [r0, r3]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
    34a8:	9b03      	ldr	r3, [sp, #12]
    34aa:	40d9      	lsrs	r1, r3
    34ac:	2301      	movs	r3, #1
    34ae:	4019      	ands	r1, r3
NRFY_STATIC_INLINE uint32_t nrfy_gpio_pin_read(uint32_t pin_number)
{
    nrf_barrier_r();
    uint32_t pin = nrf_gpio_pin_read(pin_number);
    nrf_barrier_r();
    return pin;
    34b0:	3102      	adds	r1, #2
    nrf_gpio_cfg_sense_set(pin_number, sense_config);
    34b2:	0020      	movs	r0, r4
    34b4:	f002 fbbd 	bl	5c32 <nrf_gpio_cfg_sense_set>
}
    34b8:	e7d9      	b.n	346e <nrfx_gpiote_trigger_enable+0x6e>
    34ba:	46c0      	nop			; (mov r8, r8)
    34bc:	2000001c 	.word	0x2000001c
    34c0:	00006bd8 	.word	0x00006bd8
    34c4:	00006c20 	.word	0x00006c20
    34c8:	00006347 	.word	0x00006347
    34cc:	0000031d 	.word	0x0000031d
    34d0:	40006000 	.word	0x40006000
    34d4:	00006c35 	.word	0x00006c35

000034d8 <nrfx_gpiote_trigger_disable>:
{
    34d8:	b510      	push	{r4, lr}
    34da:	0004      	movs	r4, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    34dc:	f7ff fcb4 	bl	2e48 <pin_in_use_by_te>
    34e0:	2800      	cmp	r0, #0
    34e2:	d018      	beq.n	3516 <nrfx_gpiote_trigger_disable+0x3e>
    return !pin_is_output(pin);
    34e4:	0020      	movs	r0, r4
    34e6:	f7ff fcb9 	bl	2e5c <pin_is_output>
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    34ea:	2800      	cmp	r0, #0
    34ec:	d113      	bne.n	3516 <nrfx_gpiote_trigger_disable+0x3e>
        nrfy_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
    34ee:	2201      	movs	r2, #1
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    34f0:	4b0b      	ldr	r3, [pc, #44]	; (3520 <nrfx_gpiote_trigger_disable+0x48>)
    34f2:	3408      	adds	r4, #8
    34f4:	0064      	lsls	r4, r4, #1
    34f6:	5ae3      	ldrh	r3, [r4, r3]
    p_reg->NRFX_CONCAT_2(INTENCLR, NRF_GPIOTE_IRQ_GROUP) = mask;
    34f8:	21c2      	movs	r1, #194	; 0xc2
    34fa:	0b5b      	lsrs	r3, r3, #13
        nrfy_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
    34fc:	409a      	lsls	r2, r3
    34fe:	4809      	ldr	r0, [pc, #36]	; (3524 <nrfx_gpiote_trigger_disable+0x4c>)
    3500:	0089      	lsls	r1, r1, #2
    3502:	5042      	str	r2, [r0, r1]
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    3504:	21a2      	movs	r1, #162	; 0xa2
    3506:	009b      	lsls	r3, r3, #2
    3508:	181b      	adds	r3, r3, r0
    350a:	2003      	movs	r0, #3
    350c:	00c9      	lsls	r1, r1, #3
    350e:	585a      	ldr	r2, [r3, r1]
    3510:	4382      	bics	r2, r0
    3512:	505a      	str	r2, [r3, r1]
}
    3514:	bd10      	pop	{r4, pc}
    3516:	2100      	movs	r1, #0
    3518:	0020      	movs	r0, r4
    351a:	f002 fb8a 	bl	5c32 <nrf_gpio_cfg_sense_set>
    351e:	e7f9      	b.n	3514 <nrfx_gpiote_trigger_disable+0x3c>
    3520:	2000001c 	.word	0x2000001c
    3524:	40006000 	.word	0x40006000

00003528 <nrfx_gpiote_pin_uninit>:
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
    3528:	0003      	movs	r3, r0
{
    352a:	b5f0      	push	{r4, r5, r6, r7, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
    352c:	2501      	movs	r5, #1
    352e:	3308      	adds	r3, #8
    3530:	4e1d      	ldr	r6, [pc, #116]	; (35a8 <nrfx_gpiote_pin_uninit+0x80>)
{
    3532:	b085      	sub	sp, #20
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
    3534:	005f      	lsls	r7, r3, #1
    3536:	9301      	str	r3, [sp, #4]
    3538:	5bbb      	ldrh	r3, [r7, r6]
{
    353a:	0004      	movs	r4, r0
    if (!pin_in_use(pin))
    353c:	422b      	tst	r3, r5
    353e:	d030      	beq.n	35a2 <nrfx_gpiote_pin_uninit+0x7a>
    nrfx_gpiote_trigger_disable(pin);
    3540:	f7ff ffca 	bl	34d8 <nrfx_gpiote_trigger_disable>
    if (pin_in_use_by_te(pin))
    3544:	0020      	movs	r0, r4
    3546:	f7ff fc7f 	bl	2e48 <pin_in_use_by_te>
    354a:	2800      	cmp	r0, #0
    354c:	d020      	beq.n	3590 <nrfx_gpiote_pin_uninit+0x68>
    p_reg->CONFIG[idx] = 0;
    354e:	2100      	movs	r1, #0
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    3550:	5bbb      	ldrh	r3, [r7, r6]
    3552:	4a16      	ldr	r2, [pc, #88]	; (35ac <nrfx_gpiote_pin_uninit+0x84>)
        nrfy_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
    3554:	0b5b      	lsrs	r3, r3, #13
    3556:	3345      	adds	r3, #69	; 0x45
    3558:	33ff      	adds	r3, #255	; 0xff
    355a:	009b      	lsls	r3, r3, #2
    355c:	5099      	str	r1, [r3, r2]
    release_handler(pin);
    355e:	0020      	movs	r0, r4
    3560:	f7ff fca2 	bl	2ea8 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
    3564:	2200      	movs	r2, #0
    3566:	9b01      	ldr	r3, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    3568:	a803      	add	r0, sp, #12
    356a:	005b      	lsls	r3, r3, #1
    356c:	52f2      	strh	r2, [r6, r3]
    nrf_gpio_cfg(
    356e:	9403      	str	r4, [sp, #12]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    3570:	f7ff fcfa 	bl	2f68 <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number];
    3574:	21e0      	movs	r1, #224	; 0xe0
    3576:	9b03      	ldr	r3, [sp, #12]
    3578:	00c9      	lsls	r1, r1, #3
    357a:	009b      	lsls	r3, r3, #2
    357c:	18c0      	adds	r0, r0, r3
    357e:	5842      	ldr	r2, [r0, r1]
    cnf &= ~to_update;
    3580:	4b0b      	ldr	r3, [pc, #44]	; (35b0 <nrfx_gpiote_pin_uninit+0x88>)
    3582:	401a      	ands	r2, r3
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)      |
    3584:	2302      	movs	r3, #2
    3586:	4313      	orrs	r3, r2
    reg->PIN_CNF[pin_number] = cnf;
    3588:	5043      	str	r3, [r0, r1]
    nrf_gpio_cfg(
    358a:	480a      	ldr	r0, [pc, #40]	; (35b4 <nrfx_gpiote_pin_uninit+0x8c>)
}
    358c:	b005      	add	sp, #20
    358e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bit = BITMASK_RELBIT_GET(bit);
    3590:	2107      	movs	r1, #7
    3592:	4021      	ands	r1, r4
    p_mask8[byte_idx] &= ~(1 << bit);
    3594:	408d      	lsls	r5, r1
    3596:	4a08      	ldr	r2, [pc, #32]	; (35b8 <nrfx_gpiote_pin_uninit+0x90>)
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    3598:	08e3      	lsrs	r3, r4, #3
    p_mask8[byte_idx] &= ~(1 << bit);
    359a:	5cd1      	ldrb	r1, [r2, r3]
    359c:	43a9      	bics	r1, r5
    359e:	54d1      	strb	r1, [r2, r3]
}
    35a0:	e7dd      	b.n	355e <nrfx_gpiote_pin_uninit+0x36>
        return NRFX_ERROR_INVALID_PARAM;
    35a2:	4806      	ldr	r0, [pc, #24]	; (35bc <nrfx_gpiote_pin_uninit+0x94>)
    35a4:	e7f2      	b.n	358c <nrfx_gpiote_pin_uninit+0x64>
    35a6:	46c0      	nop			; (mov r8, r8)
    35a8:	2000001c 	.word	0x2000001c
    35ac:	40006000 	.word	0x40006000
    35b0:	fffcf8f0 	.word	0xfffcf8f0
    35b4:	0bad0000 	.word	0x0bad0000
    35b8:	20000074 	.word	0x20000074
    35bc:	0bad0004 	.word	0x0bad0004

000035c0 <nrfx_gpiote_irq_handler>:
    return p_reg->NRFX_CONCAT_2(INTENSET, NRF_GPIOTE_IRQ_GROUP) & mask;
    35c0:	23c1      	movs	r3, #193	; 0xc1
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
    35c2:	b5f0      	push	{r4, r5, r6, r7, lr}
    35c4:	4a61      	ldr	r2, [pc, #388]	; (374c <nrfx_gpiote_irq_handler+0x18c>)
    35c6:	009b      	lsls	r3, r3, #2
    35c8:	58d3      	ldr	r3, [r2, r3]
    /* Collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    uint32_t enabled_in_events = nrf_gpiote_int_enable_check(NRF_GPIOTE, NRF_GPIOTE_INT_IN_MASK);
    uint32_t evt_mask = nrfy_gpiote_events_process(NRF_GPIOTE,
    35ca:	2080      	movs	r0, #128	; 0x80
    35cc:	220f      	movs	r2, #15
    35ce:	0600      	lsls	r0, r0, #24
    35d0:	4013      	ands	r3, r2
{
    35d2:	b087      	sub	sp, #28
    uint32_t evt_mask = nrfy_gpiote_events_process(NRF_GPIOTE,
    35d4:	4318      	orrs	r0, r3
    uint32_t evt_mask = __nrfy_internal_gpiote_events_process(p_reg, mask);
    35d6:	f7ff fd11 	bl	2ffc <__nrfy_internal_gpiote_events_process.constprop.0>
    35da:	9000      	str	r0, [sp, #0]
                                                   enabled_in_events |
                                                   (uint32_t)NRF_GPIOTE_INT_PORT_MASK);

    /* Handle PORT event. */
    if (evt_mask & (uint32_t)NRF_GPIOTE_INT_PORT_MASK)
    35dc:	2800      	cmp	r0, #0
    35de:	da21      	bge.n	3624 <nrfx_gpiote_irq_handler+0x64>
NRFY_STATIC_INLINE void nrfy_gpio_ports_read(uint32_t   start_port,
                                             uint32_t   length,
                                             uint32_t * p_masks)
{
    nrf_barrier_r();
    nrf_gpio_ports_read(start_port, length, p_masks);
    35e0:	a804      	add	r0, sp, #16
    35e2:	f002 fb40 	bl	5c66 <nrf_gpio_ports_read.constprop.0>
        pins_to_check[port_idx] = m_cb.port_pins[port_idx];
    35e6:	4b5a      	ldr	r3, [pc, #360]	; (3750 <nrfx_gpiote_irq_handler+0x190>)
    35e8:	6d9d      	ldr	r5, [r3, #88]	; 0x58
            while (pins_to_check[i])
    35ea:	2d00      	cmp	r5, #0
    35ec:	d123      	bne.n	3636 <nrfx_gpiote_irq_handler+0x76>
            pins_to_check[port_idx] = m_cb.port_pins[port_idx];
    35ee:	4b58      	ldr	r3, [pc, #352]	; (3750 <nrfx_gpiote_irq_handler+0x190>)
    35f0:	9302      	str	r3, [sp, #8]
    35f2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
            uint32_t pin_mask = pins_to_check[i];
    35f4:	001d      	movs	r5, r3
            pins_to_check[port_idx] = m_cb.port_pins[port_idx];
    35f6:	9301      	str	r3, [sp, #4]
        uint32_t input_diff = input[port_idx] ^ new_input[port_idx];
    35f8:	9e04      	ldr	r6, [sp, #16]
            while (pin_mask)
    35fa:	2d00      	cmp	r5, #0
    35fc:	d000      	beq.n	3600 <nrfx_gpiote_irq_handler+0x40>
    35fe:	e06d      	b.n	36dc <nrfx_gpiote_irq_handler+0x11c>
    3600:	2080      	movs	r0, #128	; 0x80
    3602:	0600      	lsls	r0, r0, #24
    3604:	f7ff fcfa 	bl	2ffc <__nrfy_internal_gpiote_events_process.constprop.0>
    3608:	a805      	add	r0, sp, #20
    360a:	f002 fb2c 	bl	5c66 <nrf_gpio_ports_read.constprop.0>
        uint32_t input_diff = input[port_idx] ^ new_input[port_idx];
    360e:	9b05      	ldr	r3, [sp, #20]
    3610:	001d      	movs	r5, r3
        input[port_idx] = new_input[port_idx];
    3612:	9304      	str	r3, [sp, #16]
        uint32_t input_diff = input[port_idx] ^ new_input[port_idx];
    3614:	4075      	eors	r5, r6
        if (input_diff)
    3616:	42b3      	cmp	r3, r6
    3618:	d000      	beq.n	361c <nrfx_gpiote_irq_handler+0x5c>
    361a:	e080      	b.n	371e <nrfx_gpiote_irq_handler+0x15e>
    {
        port_event_handle();
        evt_mask &= ~(uint32_t)NRF_GPIOTE_INT_PORT_MASK;
    361c:	9b00      	ldr	r3, [sp, #0]
    361e:	005b      	lsls	r3, r3, #1
    3620:	085b      	lsrs	r3, r3, #1
    3622:	9300      	str	r3, [sp, #0]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    3624:	24a2      	movs	r4, #162	; 0xa2
        mask &= ~NRFX_BIT(ch);
    3626:	2501      	movs	r5, #1
    3628:	00e4      	lsls	r4, r4, #3
    while (mask)
    362a:	9b00      	ldr	r3, [sp, #0]
    362c:	2b00      	cmp	r3, #0
    362e:	d000      	beq.n	3632 <nrfx_gpiote_irq_handler+0x72>
    3630:	e078      	b.n	3724 <nrfx_gpiote_irq_handler+0x164>
    }

    /* Process pin events. */
    gpiote_evt_handle(evt_mask);
}
    3632:	b007      	add	sp, #28
    3634:	bdf0      	pop	{r4, r5, r6, r7, pc}
                rel_pin = NRF_CTZ(pins_to_check[i]);
    3636:	0028      	movs	r0, r5
    3638:	f7fc fe04 	bl	244 <__ctzsi2>
                pins_to_check[i] &= ~NRFX_BIT(rel_pin);
    363c:	2301      	movs	r3, #1
                trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    363e:	0002      	movs	r2, r0
                pins_to_check[i] &= ~NRFX_BIT(rel_pin);
    3640:	4083      	lsls	r3, r0
                trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    3642:	2707      	movs	r7, #7
                rel_pin = NRF_CTZ(pins_to_check[i]);
    3644:	0004      	movs	r4, r0
                pins_to_check[i] &= ~NRFX_BIT(rel_pin);
    3646:	439d      	bics	r5, r3
                trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    3648:	3208      	adds	r2, #8
    364a:	4b41      	ldr	r3, [pc, #260]	; (3750 <nrfx_gpiote_irq_handler+0x190>)
    364c:	0052      	lsls	r2, r2, #1
    364e:	5ad3      	ldrh	r3, [r2, r3]
    3650:	089b      	lsrs	r3, r3, #2
    3652:	401f      	ands	r7, r3
    3654:	9301      	str	r3, [sp, #4]
    3656:	b2fb      	uxtb	r3, r7
    3658:	9302      	str	r3, [sp, #8]
    nrf_gpio_pin_sense_t pin_sense = nrf_gpio_pin_sense_get(pin_number);
    365a:	f002 faf7 	bl	5c4c <nrf_gpio_pin_sense_get>
    return ((1U << bit) & p_mask8[byte_idx]) != 0U;
    365e:	aa04      	add	r2, sp, #16
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    3660:	08e3      	lsrs	r3, r4, #3
    return ((1U << bit) & p_mask8[byte_idx]) != 0U;
    3662:	5cd3      	ldrb	r3, [r2, r3]
    bit = BITMASK_RELBIT_GET(bit);
    3664:	2207      	movs	r2, #7
    3666:	4022      	ands	r2, r4
    return ((1U << bit) & p_mask8[byte_idx]) != 0U;
    3668:	40d3      	lsrs	r3, r2
                if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
    366a:	2201      	movs	r2, #1
    366c:	0006      	movs	r6, r0
    366e:	4213      	tst	r3, r2
    3670:	d10f      	bne.n	3692 <nrfx_gpiote_irq_handler+0xd2>
                    (!pin_state && (sense == NRF_GPIO_PIN_SENSE_LOW)) )
    3672:	2803      	cmp	r0, #3
    3674:	d1b9      	bne.n	35ea <nrfx_gpiote_irq_handler+0x2a>
    if (is_level(trigger))
    3676:	9b01      	ldr	r3, [sp, #4]
    3678:	075b      	lsls	r3, r3, #29
    367a:	d40f      	bmi.n	369c <nrfx_gpiote_irq_handler+0xdc>
    nrf_gpio_cfg_sense_set(pin_number, sense_config);
    367c:	2102      	movs	r1, #2
    367e:	0020      	movs	r0, r4
    3680:	f002 fad7 	bl	5c32 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
    3684:	2f03      	cmp	r7, #3
    3686:	d125      	bne.n	36d4 <nrfx_gpiote_irq_handler+0x114>
            call_handler(pin, trigger);
    3688:	0020      	movs	r0, r4
    368a:	9902      	ldr	r1, [sp, #8]
    368c:	f7ff fbf0 	bl	2e70 <call_handler>
    3690:	e7ab      	b.n	35ea <nrfx_gpiote_irq_handler+0x2a>
                if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
    3692:	2802      	cmp	r0, #2
    3694:	d1a9      	bne.n	35ea <nrfx_gpiote_irq_handler+0x2a>
    if (is_level(trigger))
    3696:	9b01      	ldr	r3, [sp, #4]
    3698:	075b      	lsls	r3, r3, #29
    369a:	d511      	bpl.n	36c0 <nrfx_gpiote_irq_handler+0x100>
        call_handler(pin, trigger);
    369c:	0020      	movs	r0, r4
    369e:	9902      	ldr	r1, [sp, #8]
    36a0:	f7ff fbe6 	bl	2e70 <call_handler>
    nrf_gpio_pin_sense_t pin_sense = nrf_gpio_pin_sense_get(pin_number);
    36a4:	0020      	movs	r0, r4
    36a6:	f002 fad1 	bl	5c4c <nrf_gpio_pin_sense_get>
        if (nrfy_gpio_pin_sense_get(pin) == sense)
    36aa:	4286      	cmp	r6, r0
    36ac:	d19d      	bne.n	35ea <nrfx_gpiote_irq_handler+0x2a>
    nrf_gpio_cfg_sense_set(pin_number, sense_config);
    36ae:	0020      	movs	r0, r4
    36b0:	2100      	movs	r1, #0
    36b2:	f002 fabe 	bl	5c32 <nrf_gpio_cfg_sense_set>
    36b6:	0031      	movs	r1, r6
    36b8:	0020      	movs	r0, r4
    36ba:	f002 faba 	bl	5c32 <nrf_gpio_cfg_sense_set>
}
    36be:	e794      	b.n	35ea <nrfx_gpiote_irq_handler+0x2a>
    nrf_gpio_cfg_sense_set(pin_number, sense_config);
    36c0:	2103      	movs	r1, #3
    36c2:	0020      	movs	r0, r4
    36c4:	f002 fab5 	bl	5c32 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
    36c8:	9b02      	ldr	r3, [sp, #8]
    36ca:	43b3      	bics	r3, r6
    36cc:	2b01      	cmp	r3, #1
    36ce:	d000      	beq.n	36d2 <nrfx_gpiote_irq_handler+0x112>
    36d0:	e78b      	b.n	35ea <nrfx_gpiote_irq_handler+0x2a>
    36d2:	e7d9      	b.n	3688 <nrfx_gpiote_irq_handler+0xc8>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
    36d4:	2f02      	cmp	r7, #2
    36d6:	d000      	beq.n	36da <nrfx_gpiote_irq_handler+0x11a>
    36d8:	e787      	b.n	35ea <nrfx_gpiote_irq_handler+0x2a>
    36da:	e7d5      	b.n	3688 <nrfx_gpiote_irq_handler+0xc8>
                rel_pin = NRF_CTZ(pin_mask);
    36dc:	0028      	movs	r0, r5
    36de:	f7fc fdb1 	bl	244 <__ctzsi2>
                pin_mask &= ~NRFX_BIT(rel_pin);
    36e2:	2701      	movs	r7, #1
    36e4:	4087      	lsls	r7, r0
    36e6:	43fb      	mvns	r3, r7
                rel_pin = NRF_CTZ(pin_mask);
    36e8:	0004      	movs	r4, r0
                pin_mask &= ~NRFX_BIT(rel_pin);
    36ea:	9303      	str	r3, [sp, #12]
    36ec:	43bd      	bics	r5, r7
    nrf_gpio_pin_sense_t pin_sense = nrf_gpio_pin_sense_get(pin_number);
    36ee:	f002 faad 	bl	5c4c <nrf_gpio_pin_sense_get>
                if (nrfy_gpio_pin_sense_get(pin) != NRF_GPIO_PIN_NOSENSE)
    36f2:	2800      	cmp	r0, #0
    36f4:	d100      	bne.n	36f8 <nrfx_gpiote_irq_handler+0x138>
    36f6:	e77f      	b.n	35f8 <nrfx_gpiote_irq_handler+0x38>
                    trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    36f8:	2207      	movs	r2, #7
    36fa:	9b02      	ldr	r3, [sp, #8]
    36fc:	3408      	adds	r4, #8
    36fe:	0064      	lsls	r4, r4, #1
    3700:	5b1b      	ldrh	r3, [r3, r4]
    3702:	089b      	lsrs	r3, r3, #2
    3704:	4013      	ands	r3, r2
                    if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
    3706:	2b05      	cmp	r3, #5
    3708:	d103      	bne.n	3712 <nrfx_gpiote_irq_handler+0x152>
                        input[i] &= ~NRFX_BIT(rel_pin);
    370a:	9b03      	ldr	r3, [sp, #12]
    370c:	401e      	ands	r6, r3
    370e:	9604      	str	r6, [sp, #16]
    3710:	e772      	b.n	35f8 <nrfx_gpiote_irq_handler+0x38>
                    else if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
    3712:	2b04      	cmp	r3, #4
    3714:	d000      	beq.n	3718 <nrfx_gpiote_irq_handler+0x158>
    3716:	e76f      	b.n	35f8 <nrfx_gpiote_irq_handler+0x38>
                        input[i] |= NRFX_BIT(rel_pin);
    3718:	4337      	orrs	r7, r6
    371a:	9704      	str	r7, [sp, #16]
    371c:	e76c      	b.n	35f8 <nrfx_gpiote_irq_handler+0x38>
            pins_to_check[port_idx] &= input_diff;
    371e:	9b01      	ldr	r3, [sp, #4]
    3720:	401d      	ands	r5, r3
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
    3722:	e762      	b.n	35ea <nrfx_gpiote_irq_handler+0x2a>
        uint32_t ch = NRF_CTZ(mask);
    3724:	9800      	ldr	r0, [sp, #0]
    3726:	f7fc fd8d 	bl	244 <__ctzsi2>
        mask &= ~NRFX_BIT(ch);
    372a:	002b      	movs	r3, r5
    372c:	4083      	lsls	r3, r0
    372e:	9a00      	ldr	r2, [sp, #0]
    3730:	0080      	lsls	r0, r0, #2
    3732:	439a      	bics	r2, r3
    3734:	4b05      	ldr	r3, [pc, #20]	; (374c <nrfx_gpiote_irq_handler+0x18c>)
    3736:	9200      	str	r2, [sp, #0]
    3738:	18c3      	adds	r3, r0, r3
    373a:	5918      	ldr	r0, [r3, r4]
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
    373c:	5919      	ldr	r1, [r3, r4]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    373e:	04c0      	lsls	r0, r0, #19
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
    3740:	0389      	lsls	r1, r1, #14
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    3742:	0f89      	lsrs	r1, r1, #30
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    3744:	0ec0      	lsrs	r0, r0, #27
    3746:	f7ff fb93 	bl	2e70 <call_handler>
    374a:	e76e      	b.n	362a <nrfx_gpiote_irq_handler+0x6a>
    374c:	40006000 	.word	0x40006000
    3750:	2000001c 	.word	0x2000001c

00003754 <z_device_state_init>:
 *
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
    3754:	b510      	push	{r4, lr}
	STRUCT_SECTION_FOREACH(device, dev) {
    3756:	4b0b      	ldr	r3, [pc, #44]	; (3784 <z_device_state_init+0x30>)
    3758:	4a0b      	ldr	r2, [pc, #44]	; (3788 <z_device_state_init+0x34>)
    375a:	4293      	cmp	r3, r2
    375c:	d90f      	bls.n	377e <z_device_state_init+0x2a>
    375e:	4c0b      	ldr	r4, [pc, #44]	; (378c <z_device_state_init+0x38>)
    3760:	490b      	ldr	r1, [pc, #44]	; (3790 <z_device_state_init+0x3c>)
    3762:	2317      	movs	r3, #23
    3764:	0022      	movs	r2, r4
    3766:	480b      	ldr	r0, [pc, #44]	; (3794 <z_device_state_init+0x40>)
    3768:	f002 f8be 	bl	58e8 <assert_print>
    376c:	480a      	ldr	r0, [pc, #40]	; (3798 <z_device_state_init+0x44>)
    376e:	f002 f8bb 	bl	58e8 <assert_print>
    3772:	2117      	movs	r1, #23
    3774:	0020      	movs	r0, r4
    3776:	f002 f8b3 	bl	58e0 <assert_post_action>
    377a:	3318      	adds	r3, #24
    377c:	e7ed      	b.n	375a <z_device_state_init+0x6>
    377e:	4293      	cmp	r3, r2
    3780:	d3fb      	bcc.n	377a <z_device_state_init+0x26>
		z_object_init(dev);
	}
}
    3782:	bd10      	pop	{r4, pc}
    3784:	00005d4c 	.word	0x00005d4c
    3788:	00005d94 	.word	0x00005d94
    378c:	00006c4c 	.word	0x00006c4c
    3790:	00006c6f 	.word	0x00006c6f
    3794:	00006347 	.word	0x00006347
    3798:	00006c87 	.word	0x00006c87

0000379c <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    379c:	b510      	push	{r4, lr}
    379e:	0004      	movs	r4, r0
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
    37a0:	2145      	movs	r1, #69	; 0x45
    37a2:	4803      	ldr	r0, [pc, #12]	; (37b0 <k_sys_fatal_error_handler+0x14>)
    37a4:	f002 f8ac 	bl	5900 <z_log_minimal_printk>
	arch_system_halt(reason);
    37a8:	0020      	movs	r0, r4
    37aa:	f002 fa70 	bl	5c8e <arch_system_halt>
    37ae:	46c0      	nop			; (mov r8, r8)
    37b0:	00006ca6 	.word	0x00006ca6

000037b4 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    37b4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    37b6:	0004      	movs	r4, r0
    37b8:	000d      	movs	r5, r1
	__asm__ volatile("mrs %0, PRIMASK;"
    37ba:	f3ef 8710 	mrs	r7, PRIMASK
    37be:	b672      	cpsid	i
	return z_impl_z_current_get();
    37c0:	f001 fad8 	bl	4d74 <z_impl_z_current_get>
    37c4:	4b20      	ldr	r3, [pc, #128]	; (3848 <z_fatal_error+0x94>)
    37c6:	0006      	movs	r6, r0
	switch (reason) {
    37c8:	2c04      	cmp	r4, #4
    37ca:	d802      	bhi.n	37d2 <z_fatal_error+0x1e>
    37cc:	4b1f      	ldr	r3, [pc, #124]	; (384c <z_fatal_error+0x98>)
    37ce:	00a2      	lsls	r2, r4, #2
    37d0:	58d3      	ldr	r3, [r2, r3]
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    37d2:	2200      	movs	r2, #0
    37d4:	2145      	movs	r1, #69	; 0x45
    37d6:	9200      	str	r2, [sp, #0]
    37d8:	481d      	ldr	r0, [pc, #116]	; (3850 <z_fatal_error+0x9c>)
    37da:	0022      	movs	r2, r4
    37dc:	f002 f890 	bl	5900 <z_log_minimal_printk>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
    37e0:	2d00      	cmp	r5, #0
    37e2:	d006      	beq.n	37f2 <z_fatal_error+0x3e>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
    37e4:	69eb      	ldr	r3, [r5, #28]
    37e6:	05db      	lsls	r3, r3, #23
    37e8:	d003      	beq.n	37f2 <z_fatal_error+0x3e>
		LOG_ERR("Fault during interrupt handling\n");
    37ea:	2145      	movs	r1, #69	; 0x45
    37ec:	4819      	ldr	r0, [pc, #100]	; (3854 <z_fatal_error+0xa0>)
    37ee:	f002 f887 	bl	5900 <z_log_minimal_printk>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
    37f2:	2e00      	cmp	r6, #0
    37f4:	d007      	beq.n	3806 <z_fatal_error+0x52>
    37f6:	0030      	movs	r0, r6
    37f8:	f002 fa5b 	bl	5cb2 <k_thread_name_get>
    37fc:	1e03      	subs	r3, r0, #0
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
    37fe:	d002      	beq.n	3806 <z_fatal_error+0x52>
    3800:	7802      	ldrb	r2, [r0, #0]
    3802:	2a00      	cmp	r2, #0
    3804:	d100      	bne.n	3808 <z_fatal_error+0x54>
		thread_name = "unknown";
    3806:	4b14      	ldr	r3, [pc, #80]	; (3858 <z_fatal_error+0xa4>)
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
    3808:	2145      	movs	r1, #69	; 0x45
    380a:	4814      	ldr	r0, [pc, #80]	; (385c <z_fatal_error+0xa8>)
    380c:	0032      	movs	r2, r6
    380e:	f002 f877 	bl	5900 <z_log_minimal_printk>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
    3812:	0029      	movs	r1, r5
    3814:	0020      	movs	r0, r4
    3816:	f7ff ffc1 	bl	379c <k_sys_fatal_error_handler>
		}
#endif /* CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	} else {
		/* Test mode */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
		if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
    381a:	2d00      	cmp	r5, #0
    381c:	d008      	beq.n	3830 <z_fatal_error+0x7c>
    381e:	69eb      	ldr	r3, [r5, #28]
    3820:	05db      	lsls	r3, r3, #23
    3822:	d005      	beq.n	3830 <z_fatal_error+0x7c>
	if (key != 0U) {
    3824:	2f00      	cmp	r7, #0
    3826:	d102      	bne.n	382e <z_fatal_error+0x7a>
	__asm__ volatile(
    3828:	b662      	cpsie	i
    382a:	f3bf 8f6f 	isb	sy
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    382e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
			if (reason == K_ERR_SPURIOUS_IRQ) {
    3830:	2c01      	cmp	r4, #1
    3832:	d0f7      	beq.n	3824 <z_fatal_error+0x70>
	if (key != 0U) {
    3834:	2f00      	cmp	r7, #0
    3836:	d102      	bne.n	383e <z_fatal_error+0x8a>
	__asm__ volatile(
    3838:	b662      	cpsie	i
    383a:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
    383e:	0030      	movs	r0, r6
    3840:	f7fd ffa0 	bl	1784 <z_impl_k_thread_abort>
}
    3844:	e7f3      	b.n	382e <z_fatal_error+0x7a>
    3846:	46c0      	nop			; (mov r8, r8)
    3848:	00006cba 	.word	0x00006cba
    384c:	00005fc4 	.word	0x00005fc4
    3850:	00006cd0 	.word	0x00006cd0
    3854:	00006cfd 	.word	0x00006cfd
    3858:	00006cc8 	.word	0x00006cc8
    385c:	00006d23 	.word	0x00006d23

00003860 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
static void z_sys_init_run_level(enum init_level level)
{
    3860:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
					}
					dev->state->init_res = rc;
				}
			}

			dev->state->initialized = true;
    3862:	2701      	movs	r7, #1
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    3864:	4e12      	ldr	r6, [pc, #72]	; (38b0 <z_sys_init_run_level+0x50>)
    3866:	0083      	lsls	r3, r0, #2
    3868:	3001      	adds	r0, #1
    386a:	599c      	ldr	r4, [r3, r6]
    386c:	0083      	lsls	r3, r0, #2
    386e:	9301      	str	r3, [sp, #4]
    3870:	9b01      	ldr	r3, [sp, #4]
    3872:	58f3      	ldr	r3, [r6, r3]
    3874:	42a3      	cmp	r3, r4
    3876:	d800      	bhi.n	387a <z_sys_init_run_level+0x1a>
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
    3878:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
		const struct device *dev = entry->dev;
    387a:	6865      	ldr	r5, [r4, #4]
			if (entry->init_fn.dev != NULL) {
    387c:	6823      	ldr	r3, [r4, #0]
		if (dev != NULL) {
    387e:	2d00      	cmp	r5, #0
    3880:	d013      	beq.n	38aa <z_sys_init_run_level+0x4a>
			if (entry->init_fn.dev != NULL) {
    3882:	2b00      	cmp	r3, #0
    3884:	d00b      	beq.n	389e <z_sys_init_run_level+0x3e>
				rc = entry->init_fn.dev(dev);
    3886:	0028      	movs	r0, r5
    3888:	4798      	blx	r3
				if (rc != 0) {
    388a:	2800      	cmp	r0, #0
    388c:	d007      	beq.n	389e <z_sys_init_run_level+0x3e>
					if (rc < 0) {
    388e:	17c2      	asrs	r2, r0, #31
    3890:	1880      	adds	r0, r0, r2
					dev->state->init_res = rc;
    3892:	68eb      	ldr	r3, [r5, #12]
					if (rc < 0) {
    3894:	4050      	eors	r0, r2
					if (rc > UINT8_MAX) {
    3896:	28ff      	cmp	r0, #255	; 0xff
    3898:	dd00      	ble.n	389c <z_sys_init_run_level+0x3c>
    389a:	20ff      	movs	r0, #255	; 0xff
					dev->state->init_res = rc;
    389c:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
    389e:	68ea      	ldr	r2, [r5, #12]
    38a0:	7853      	ldrb	r3, [r2, #1]
    38a2:	433b      	orrs	r3, r7
    38a4:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    38a6:	3408      	adds	r4, #8
    38a8:	e7e2      	b.n	3870 <z_sys_init_run_level+0x10>
			(void)entry->init_fn.sys();
    38aa:	4798      	blx	r3
    38ac:	e7fb      	b.n	38a6 <z_sys_init_run_level+0x46>
    38ae:	46c0      	nop			; (mov r8, r8)
    38b0:	00005fd8 	.word	0x00005fd8

000038b4 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    38b4:	b510      	push	{r4, lr}
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
    38b6:	2401      	movs	r4, #1
    38b8:	4b09      	ldr	r3, [pc, #36]	; (38e0 <bg_thread_main+0x2c>)

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
    38ba:	2003      	movs	r0, #3
	z_sys_post_kernel = true;
    38bc:	701c      	strb	r4, [r3, #0]
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
    38be:	f7ff ffcf 	bl	3860 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
    38c2:	f001 ff73 	bl	57ac <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
    38c6:	2004      	movs	r0, #4
    38c8:	f7ff ffca 	bl	3860 <z_sys_init_run_level>

	z_init_static_threads();
    38cc:	f000 f964 	bl	3b98 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
    38d0:	f7fe fa1c 	bl	1d0c <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    38d4:	4a03      	ldr	r2, [pc, #12]	; (38e4 <bg_thread_main+0x30>)
    38d6:	7b13      	ldrb	r3, [r2, #12]
    38d8:	43a3      	bics	r3, r4
    38da:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    38dc:	bd10      	pop	{r4, pc}
    38de:	46c0      	nop			; (mov r8, r8)
    38e0:	20000378 	.word	0x20000378
    38e4:	200001b0 	.word	0x200001b0

000038e8 <z_bss_zero>:
{
    38e8:	b510      	push	{r4, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
    38ea:	4a03      	ldr	r2, [pc, #12]	; (38f8 <z_bss_zero+0x10>)
    38ec:	4803      	ldr	r0, [pc, #12]	; (38fc <z_bss_zero+0x14>)
    38ee:	2100      	movs	r1, #0
    38f0:	1a12      	subs	r2, r2, r0
    38f2:	f002 f9d0 	bl	5c96 <z_early_memset>
}
    38f6:	bd10      	pop	{r4, pc}
    38f8:	2000037c 	.word	0x2000037c
    38fc:	20000090 	.word	0x20000090

00003900 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
    3900:	b570      	push	{r4, r5, r6, lr}
	struct k_thread *thread = &z_idle_threads[i];
    3902:	2690      	movs	r6, #144	; 0x90
{
    3904:	0004      	movs	r4, r0
	struct k_thread *thread = &z_idle_threads[i];
    3906:	4346      	muls	r6, r0
	k_thread_stack_t *stack = z_idle_stacks[i];
    3908:	0201      	lsls	r1, r0, #8
    390a:	4813      	ldr	r0, [pc, #76]	; (3958 <z_init_cpu+0x58>)
{
    390c:	b086      	sub	sp, #24
	k_thread_stack_t *stack = z_idle_stacks[i];
    390e:	1809      	adds	r1, r1, r0
	z_setup_new_thread(thread, stack,
    3910:	4812      	ldr	r0, [pc, #72]	; (395c <z_init_cpu+0x5c>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    3912:	2514      	movs	r5, #20
	z_setup_new_thread(thread, stack,
    3914:	9005      	str	r0, [sp, #20]
    3916:	2001      	movs	r0, #1
    3918:	9004      	str	r0, [sp, #16]
    391a:	300e      	adds	r0, #14
    391c:	9003      	str	r0, [sp, #12]
    391e:	2000      	movs	r0, #0
    3920:	2280      	movs	r2, #128	; 0x80
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    3922:	4365      	muls	r5, r4
	struct k_thread *thread = &z_idle_threads[i];
    3924:	4b0e      	ldr	r3, [pc, #56]	; (3960 <z_init_cpu+0x60>)
	z_setup_new_thread(thread, stack,
    3926:	9002      	str	r0, [sp, #8]
    3928:	9001      	str	r0, [sp, #4]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    392a:	480e      	ldr	r0, [pc, #56]	; (3964 <z_init_cpu+0x64>)
	struct k_thread *thread = &z_idle_threads[i];
    392c:	18f6      	adds	r6, r6, r3
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    392e:	182d      	adds	r5, r5, r0
	z_setup_new_thread(thread, stack,
    3930:	4b0d      	ldr	r3, [pc, #52]	; (3968 <z_init_cpu+0x68>)
    3932:	0030      	movs	r0, r6
    3934:	9500      	str	r5, [sp, #0]
    3936:	0052      	lsls	r2, r2, #1
    3938:	f000 f882 	bl	3a40 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    393c:	2204      	movs	r2, #4
    393e:	7b73      	ldrb	r3, [r6, #13]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
    3940:	742c      	strb	r4, [r5, #16]
    3942:	4393      	bics	r3, r2
    3944:	7373      	strb	r3, [r6, #13]
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
    3946:	3401      	adds	r4, #1
    3948:	4b08      	ldr	r3, [pc, #32]	; (396c <z_init_cpu+0x6c>)
    394a:	02e4      	lsls	r4, r4, #11
    394c:	18e4      	adds	r4, r4, r3
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
    394e:	60ee      	str	r6, [r5, #12]
	_kernel.cpus[id].irq_stack =
    3950:	606c      	str	r4, [r5, #4]
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
    3952:	b006      	add	sp, #24
    3954:	bd70      	pop	{r4, r5, r6, pc}
    3956:	46c0      	nop			; (mov r8, r8)
    3958:	20000f80 	.word	0x20000f80
    395c:	00006d8a 	.word	0x00006d8a
    3960:	20000120 	.word	0x20000120
    3964:	20000330 	.word	0x20000330
    3968:	00003cdd 	.word	0x00003cdd
    396c:	20000780 	.word	0x20000780

00003970 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
    3970:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
    3972:	2000      	movs	r0, #0
{
    3974:	b0ab      	sub	sp, #172	; 0xac
	z_sys_init_run_level(INIT_LEVEL_EARLY);
    3976:	f7ff ff73 	bl	3860 <z_sys_init_run_level>
 * pointer) register, and switched to automatically when taking an exception.
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
    397a:	4b21      	ldr	r3, [pc, #132]	; (3a00 <z_cstart+0x90>)
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    397c:	f383 8808 	msr	MSP, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    3980:	4920      	ldr	r1, [pc, #128]	; (3a04 <z_cstart+0x94>)
    3982:	4b21      	ldr	r3, [pc, #132]	; (3a08 <z_cstart+0x98>)
    3984:	6a0a      	ldr	r2, [r1, #32]
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif
#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
	k_thread_system_pool_assign(dummy_thread);
#else
	dummy_thread->resource_pool = NULL;
    3986:	2500      	movs	r5, #0
    3988:	401a      	ands	r2, r3
    398a:	23c0      	movs	r3, #192	; 0xc0
    398c:	041b      	lsls	r3, r3, #16
    398e:	4313      	orrs	r3, r2
    3990:	620b      	str	r3, [r1, #32]

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    3992:	f001 ffde 	bl	5952 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    3996:	f7fd fceb 	bl	1370 <z_arm_cpu_idle_init>
	dummy_thread->base.user_options = K_ESSENTIAL;
    399a:	2202      	movs	r2, #2

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
    399c:	4e1b      	ldr	r6, [pc, #108]	; (3a0c <z_cstart+0x9c>)
	dummy_thread->base.user_options = K_ESSENTIAL;
    399e:	ab06      	add	r3, sp, #24
    39a0:	32ff      	adds	r2, #255	; 0xff
    39a2:	819a      	strh	r2, [r3, #12]
	_current_cpu->current = dummy_thread;
    39a4:	60b3      	str	r3, [r6, #8]
	dummy_thread->resource_pool = NULL;
    39a6:	9527      	str	r5, [sp, #156]	; 0x9c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    39a8:	f7ff fed4 	bl	3754 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
    39ac:	2001      	movs	r0, #1
    39ae:	f7ff ff57 	bl	3860 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
    39b2:	2002      	movs	r0, #2
    39b4:	f7ff ff54 	bl	3860 <z_sys_init_run_level>
	z_sched_init();
    39b8:	f001 f852 	bl	4a60 <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
    39bc:	4c14      	ldr	r4, [pc, #80]	; (3a10 <z_cstart+0xa0>)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    39be:	4b15      	ldr	r3, [pc, #84]	; (3a14 <z_cstart+0xa4>)
	_kernel.ready_q.cache = &z_main_thread;
    39c0:	61b4      	str	r4, [r6, #24]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    39c2:	2280      	movs	r2, #128	; 0x80
    39c4:	9305      	str	r3, [sp, #20]
    39c6:	2301      	movs	r3, #1
    39c8:	4e13      	ldr	r6, [pc, #76]	; (3a18 <z_cstart+0xa8>)
    39ca:	4914      	ldr	r1, [pc, #80]	; (3a1c <z_cstart+0xac>)
    39cc:	9304      	str	r3, [sp, #16]
    39ce:	00d2      	lsls	r2, r2, #3
    39d0:	0033      	movs	r3, r6
    39d2:	0020      	movs	r0, r4
    39d4:	9503      	str	r5, [sp, #12]
    39d6:	9502      	str	r5, [sp, #8]
    39d8:	9501      	str	r5, [sp, #4]
    39da:	9500      	str	r5, [sp, #0]
    39dc:	f000 f830 	bl	3a40 <z_setup_new_thread>
    39e0:	2204      	movs	r2, #4
    39e2:	0007      	movs	r7, r0
    39e4:	7b63      	ldrb	r3, [r4, #13]
	z_ready_thread(&z_main_thread);
    39e6:	0020      	movs	r0, r4
    39e8:	4393      	bics	r3, r2
    39ea:	7363      	strb	r3, [r4, #13]
    39ec:	f000 fb7e 	bl	40ec <z_ready_thread>
	z_init_cpu(0);
    39f0:	0028      	movs	r0, r5
    39f2:	f7ff ff85 	bl	3900 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    39f6:	0032      	movs	r2, r6
    39f8:	0039      	movs	r1, r7
    39fa:	0020      	movs	r0, r4
    39fc:	f7fd fdcc 	bl	1598 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    3a00:	20000f80 	.word	0x20000f80
    3a04:	e000ed00 	.word	0xe000ed00
    3a08:	ff00ffff 	.word	0xff00ffff
    3a0c:	20000330 	.word	0x20000330
    3a10:	200001b0 	.word	0x200001b0
    3a14:	00006d8f 	.word	0x00006d8f
    3a18:	000038b5 	.word	0x000038b5
    3a1c:	20001080 	.word	0x20001080

00003a20 <z_impl_k_thread_name_set>:
	k_spin_unlock(&z_thread_monitor_lock, key);
}
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
    3a20:	b510      	push	{r4, lr}
    3a22:	1e04      	subs	r4, r0, #0
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
    3a24:	d101      	bne.n	3a2a <z_impl_k_thread_name_set+0xa>
		thread = _current;
    3a26:	4b05      	ldr	r3, [pc, #20]	; (3a3c <z_impl_k_thread_name_set+0x1c>)
    3a28:	689c      	ldr	r4, [r3, #8]
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN - 1);
    3a2a:	0020      	movs	r0, r4
    3a2c:	221f      	movs	r2, #31
    3a2e:	3060      	adds	r0, #96	; 0x60
    3a30:	f001 ff90 	bl	5954 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    3a34:	2000      	movs	r0, #0
    3a36:	347f      	adds	r4, #127	; 0x7f
    3a38:	7020      	strb	r0, [r4, #0]

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
    3a3a:	bd10      	pop	{r4, pc}
    3a3c:	20000330 	.word	0x20000330

00003a40 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    3a40:	b5f0      	push	{r4, r5, r6, r7, lr}
    3a42:	b085      	sub	sp, #20
    3a44:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    3a46:	0004      	movs	r4, r0
    3a48:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
	char *stack_ptr;

	Z_ASSERT_VALID_PRIO(prio, entry);
    3a4a:	2d0f      	cmp	r5, #15
    3a4c:	d135      	bne.n	3aba <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x22>
    3a4e:	4827      	ldr	r0, [pc, #156]	; (3aec <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x54>)
    3a50:	4283      	cmp	r3, r0
    3a52:	d136      	bne.n	3ac2 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x2a>
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    3a54:	0020      	movs	r0, r4
    3a56:	3058      	adds	r0, #88	; 0x58
 * @param list the doubly-linked list
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    3a58:	65a0      	str	r0, [r4, #88]	; 0x58
	list->tail = (sys_dnode_t *)list;
    3a5a:	65e0      	str	r0, [r4, #92]	; 0x5c
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
    3a5c:	980e      	ldr	r0, [sp, #56]	; 0x38
	thread_base->pended_on = NULL;
    3a5e:	2600      	movs	r6, #0
	thread_base->user_options = (uint8_t)options;
    3a60:	7320      	strb	r0, [r4, #12]
	thread_base->thread_state = (uint8_t)initial_state;
    3a62:	2004      	movs	r0, #4
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    3a64:	3207      	adds	r2, #7
	thread_base->thread_state = (uint8_t)initial_state;
    3a66:	7360      	strb	r0, [r4, #13]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    3a68:	3003      	adds	r0, #3
    3a6a:	4382      	bics	r2, r0

	thread_base->prio = priority;
    3a6c:	73a5      	strb	r5, [r4, #14]
	stack_ptr = (char *)stack + stack_obj_size;
    3a6e:	188d      	adds	r5, r1, r2
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    3a70:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	thread_base->pended_on = NULL;
    3a72:	60a6      	str	r6, [r4, #8]

	thread_base->sched_locked = 0U;
    3a74:	73e6      	strb	r6, [r4, #15]
 * @param node the node
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
    3a76:	61a6      	str	r6, [r4, #24]
	node->prev = NULL;
    3a78:	61e6      	str	r6, [r4, #28]
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    3a7a:	9202      	str	r2, [sp, #8]
    3a7c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    3a7e:	0020      	movs	r0, r4
    3a80:	9201      	str	r2, [sp, #4]
    3a82:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    3a84:	9200      	str	r2, [sp, #0]
    3a86:	002a      	movs	r2, r5
    3a88:	f7fd fd6e 	bl	1568 <arch_new_thread>
	new_thread->init_data = NULL;
    3a8c:	0020      	movs	r0, r4
    3a8e:	6566      	str	r6, [r4, #84]	; 0x54
	if (name != NULL) {
    3a90:	3060      	adds	r0, #96	; 0x60
    3a92:	42b7      	cmp	r7, r6
    3a94:	d027      	beq.n	3ae6 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x4e>
		strncpy(new_thread->name, name,
    3a96:	221f      	movs	r2, #31
    3a98:	0039      	movs	r1, r7
    3a9a:	f001 ff5b 	bl	5954 <strncpy>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    3a9e:	0023      	movs	r3, r4
    3aa0:	337f      	adds	r3, #127	; 0x7f
    3aa2:	701e      	strb	r6, [r3, #0]
	if (!_current) {
    3aa4:	4b12      	ldr	r3, [pc, #72]	; (3af0 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x58>)
    3aa6:	689b      	ldr	r3, [r3, #8]
    3aa8:	2b00      	cmp	r3, #0
    3aaa:	d001      	beq.n	3ab0 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x18>
	new_thread->resource_pool = _current->resource_pool;
    3aac:	3308      	adds	r3, #8
    3aae:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
}
    3ab0:	0028      	movs	r0, r5
    3ab2:	3408      	adds	r4, #8
    3ab4:	67e3      	str	r3, [r4, #124]	; 0x7c
    3ab6:	b005      	add	sp, #20
    3ab8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	Z_ASSERT_VALID_PRIO(prio, entry);
    3aba:	0028      	movs	r0, r5
    3abc:	3010      	adds	r0, #16
    3abe:	281e      	cmp	r0, #30
    3ac0:	d9c8      	bls.n	3a54 <z_setup_new_thread+0x14>
    3ac2:	4c0c      	ldr	r4, [pc, #48]	; (3af4 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x5c>)
    3ac4:	490c      	ldr	r1, [pc, #48]	; (3af8 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x60>)
    3ac6:	0022      	movs	r2, r4
    3ac8:	480c      	ldr	r0, [pc, #48]	; (3afc <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x64>)
    3aca:	4b0d      	ldr	r3, [pc, #52]	; (3b00 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x68>)
    3acc:	f001 ff0c 	bl	58e8 <assert_print>
    3ad0:	2310      	movs	r3, #16
    3ad2:	0029      	movs	r1, r5
    3ad4:	480b      	ldr	r0, [pc, #44]	; (3b04 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x6c>)
    3ad6:	220e      	movs	r2, #14
    3ad8:	425b      	negs	r3, r3
    3ada:	f001 ff05 	bl	58e8 <assert_print>
    3ade:	0020      	movs	r0, r4
    3ae0:	4907      	ldr	r1, [pc, #28]	; (3b00 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x68>)
    3ae2:	f001 fefd 	bl	58e0 <assert_post_action>
		new_thread->name[0] = '\0';
    3ae6:	7007      	strb	r7, [r0, #0]
    3ae8:	e7dc      	b.n	3aa4 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xc>
    3aea:	46c0      	nop			; (mov r8, r8)
    3aec:	00003cdd 	.word	0x00003cdd
    3af0:	20000330 	.word	0x20000330
    3af4:	00006d97 	.word	0x00006d97
    3af8:	00006dba 	.word	0x00006dba
    3afc:	00006347 	.word	0x00006347
    3b00:	0000021a 	.word	0x0000021a
    3b04:	00006e3a 	.word	0x00006e3a

00003b08 <z_impl_k_thread_create>:
{
    3b08:	b570      	push	{r4, r5, r6, lr}
    3b0a:	b086      	sub	sp, #24
    3b0c:	0004      	movs	r4, r0
    3b0e:	9e10      	ldr	r6, [sp, #64]	; 0x40
    3b10:	9d11      	ldr	r5, [sp, #68]	; 0x44
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    3b12:	f3ef 8005 	mrs	r0, IPSR
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
    3b16:	2800      	cmp	r0, #0
    3b18:	d00f      	beq.n	3b3a <z_impl_k_thread_create+0x32>
    3b1a:	23a3      	movs	r3, #163	; 0xa3
    3b1c:	4c19      	ldr	r4, [pc, #100]	; (3b84 <z_impl_k_thread_create+0x7c>)
    3b1e:	491a      	ldr	r1, [pc, #104]	; (3b88 <z_impl_k_thread_create+0x80>)
    3b20:	0022      	movs	r2, r4
    3b22:	481a      	ldr	r0, [pc, #104]	; (3b8c <z_impl_k_thread_create+0x84>)
    3b24:	009b      	lsls	r3, r3, #2
    3b26:	f001 fedf 	bl	58e8 <assert_print>
    3b2a:	4819      	ldr	r0, [pc, #100]	; (3b90 <z_impl_k_thread_create+0x88>)
    3b2c:	f001 fedc 	bl	58e8 <assert_print>
    3b30:	21a3      	movs	r1, #163	; 0xa3
    3b32:	0020      	movs	r0, r4
    3b34:	0089      	lsls	r1, r1, #2
    3b36:	f001 fed3 	bl	58e0 <assert_post_action>
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    3b3a:	9005      	str	r0, [sp, #20]
    3b3c:	980e      	ldr	r0, [sp, #56]	; 0x38
    3b3e:	9004      	str	r0, [sp, #16]
    3b40:	980d      	ldr	r0, [sp, #52]	; 0x34
    3b42:	9003      	str	r0, [sp, #12]
    3b44:	980c      	ldr	r0, [sp, #48]	; 0x30
    3b46:	9002      	str	r0, [sp, #8]
    3b48:	980b      	ldr	r0, [sp, #44]	; 0x2c
    3b4a:	9001      	str	r0, [sp, #4]
    3b4c:	980a      	ldr	r0, [sp, #40]	; 0x28
    3b4e:	9000      	str	r0, [sp, #0]
    3b50:	0020      	movs	r0, r4
    3b52:	f7ff ff75 	bl	3a40 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
    3b56:	002b      	movs	r3, r5
    3b58:	1c72      	adds	r2, r6, #1
    3b5a:	d101      	bne.n	3b60 <z_impl_k_thread_create+0x58>
    3b5c:	3301      	adds	r3, #1
    3b5e:	d005      	beq.n	3b6c <z_impl_k_thread_create+0x64>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    3b60:	002b      	movs	r3, r5
    3b62:	4333      	orrs	r3, r6
    3b64:	d105      	bne.n	3b72 <z_impl_k_thread_create+0x6a>
	z_sched_start(thread);
    3b66:	0020      	movs	r0, r4
    3b68:	f000 fb4e 	bl	4208 <z_sched_start>
}
    3b6c:	0020      	movs	r0, r4
    3b6e:	b006      	add	sp, #24
    3b70:	bd70      	pop	{r4, r5, r6, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    3b72:	0020      	movs	r0, r4
    3b74:	0032      	movs	r2, r6
    3b76:	002b      	movs	r3, r5
    3b78:	4906      	ldr	r1, [pc, #24]	; (3b94 <z_impl_k_thread_create+0x8c>)
    3b7a:	3018      	adds	r0, #24
    3b7c:	f001 fadc 	bl	5138 <z_add_timeout>
    3b80:	e7f4      	b.n	3b6c <z_impl_k_thread_create+0x64>
    3b82:	46c0      	nop			; (mov r8, r8)
    3b84:	00006d97 	.word	0x00006d97
    3b88:	00006e6b 	.word	0x00006e6b
    3b8c:	00006347 	.word	0x00006347
    3b90:	00006e7d 	.word	0x00006e7d
    3b94:	00005cf5 	.word	0x00005cf5

00003b98 <z_init_static_threads>:
{
    3b98:	b5f0      	push	{r4, r5, r6, r7, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
    3b9a:	4e34      	ldr	r6, [pc, #208]	; (3c6c <z_init_static_threads+0xd4>)
{
    3b9c:	b089      	sub	sp, #36	; 0x24
    3b9e:	0034      	movs	r4, r6
	_FOREACH_STATIC_THREAD(thread_data) {
    3ba0:	4d33      	ldr	r5, [pc, #204]	; (3c70 <z_init_static_threads+0xd8>)
    3ba2:	42ae      	cmp	r6, r5
    3ba4:	d923      	bls.n	3bee <z_init_static_threads+0x56>
    3ba6:	4c33      	ldr	r4, [pc, #204]	; (3c74 <z_init_static_threads+0xdc>)
    3ba8:	4933      	ldr	r1, [pc, #204]	; (3c78 <z_init_static_threads+0xe0>)
    3baa:	0022      	movs	r2, r4
    3bac:	4833      	ldr	r0, [pc, #204]	; (3c7c <z_init_static_threads+0xe4>)
    3bae:	4b34      	ldr	r3, [pc, #208]	; (3c80 <z_init_static_threads+0xe8>)
    3bb0:	f001 fe9a 	bl	58e8 <assert_print>
    3bb4:	4833      	ldr	r0, [pc, #204]	; (3c84 <z_init_static_threads+0xec>)
    3bb6:	f001 fe97 	bl	58e8 <assert_print>
    3bba:	4931      	ldr	r1, [pc, #196]	; (3c80 <z_init_static_threads+0xe8>)
	_FOREACH_STATIC_THREAD(thread_data) {
    3bbc:	0020      	movs	r0, r4
    3bbe:	f001 fe8f 	bl	58e0 <assert_post_action>
		z_setup_new_thread(
    3bc2:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    3bc4:	9305      	str	r3, [sp, #20]
    3bc6:	6a33      	ldr	r3, [r6, #32]
    3bc8:	9304      	str	r3, [sp, #16]
    3bca:	69f3      	ldr	r3, [r6, #28]
    3bcc:	9303      	str	r3, [sp, #12]
    3bce:	69b3      	ldr	r3, [r6, #24]
    3bd0:	9302      	str	r3, [sp, #8]
    3bd2:	6973      	ldr	r3, [r6, #20]
    3bd4:	9301      	str	r3, [sp, #4]
    3bd6:	6933      	ldr	r3, [r6, #16]
    3bd8:	9300      	str	r3, [sp, #0]
    3bda:	68f3      	ldr	r3, [r6, #12]
    3bdc:	68b2      	ldr	r2, [r6, #8]
    3bde:	6871      	ldr	r1, [r6, #4]
    3be0:	6830      	ldr	r0, [r6, #0]
    3be2:	f7ff ff2d 	bl	3a40 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    3be6:	6833      	ldr	r3, [r6, #0]
    3be8:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
    3bea:	362c      	adds	r6, #44	; 0x2c
    3bec:	e7d8      	b.n	3ba0 <z_init_static_threads+0x8>
    3bee:	42ae      	cmp	r6, r5
    3bf0:	d3e7      	bcc.n	3bc2 <z_init_static_threads+0x2a>
	k_sched_lock();
    3bf2:	f000 fb5b 	bl	42ac <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    3bf6:	42ac      	cmp	r4, r5
    3bf8:	d931      	bls.n	3c5e <z_init_static_threads+0xc6>
    3bfa:	4c1e      	ldr	r4, [pc, #120]	; (3c74 <z_init_static_threads+0xdc>)
    3bfc:	491e      	ldr	r1, [pc, #120]	; (3c78 <z_init_static_threads+0xe0>)
    3bfe:	0022      	movs	r2, r4
    3c00:	481e      	ldr	r0, [pc, #120]	; (3c7c <z_init_static_threads+0xe4>)
    3c02:	4b21      	ldr	r3, [pc, #132]	; (3c88 <z_init_static_threads+0xf0>)
    3c04:	f001 fe70 	bl	58e8 <assert_print>
    3c08:	481e      	ldr	r0, [pc, #120]	; (3c84 <z_init_static_threads+0xec>)
    3c0a:	f001 fe6d 	bl	58e8 <assert_print>
    3c0e:	491e      	ldr	r1, [pc, #120]	; (3c88 <z_init_static_threads+0xf0>)
    3c10:	e7d4      	b.n	3bbc <z_init_static_threads+0x24>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    3c12:	6a63      	ldr	r3, [r4, #36]	; 0x24
    3c14:	1c5a      	adds	r2, r3, #1
    3c16:	d013      	beq.n	3c40 <z_init_static_threads+0xa8>
					    K_MSEC(thread_data->init_delay));
    3c18:	43da      	mvns	r2, r3
    3c1a:	17d2      	asrs	r2, r2, #31
    3c1c:	4013      	ands	r3, r2
    3c1e:	9306      	str	r3, [sp, #24]
    3c20:	17db      	asrs	r3, r3, #31
    3c22:	9307      	str	r3, [sp, #28]
		t += off;
    3c24:	2209      	movs	r2, #9
    3c26:	9806      	ldr	r0, [sp, #24]
    3c28:	9907      	ldr	r1, [sp, #28]
    3c2a:	2300      	movs	r3, #0
    3c2c:	1880      	adds	r0, r0, r2
    3c2e:	4159      	adcs	r1, r3
			schedule_new_thread(thread_data->init_thread,
    3c30:	6826      	ldr	r6, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    3c32:	2809      	cmp	r0, #9
    3c34:	d106      	bne.n	3c44 <z_init_static_threads+0xac>
    3c36:	2900      	cmp	r1, #0
    3c38:	d104      	bne.n	3c44 <z_init_static_threads+0xac>
	z_sched_start(thread);
    3c3a:	0030      	movs	r0, r6
    3c3c:	f000 fae4 	bl	4208 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    3c40:	342c      	adds	r4, #44	; 0x2c
    3c42:	e7d8      	b.n	3bf6 <z_init_static_threads+0x5e>
			return t / ((uint64_t)from_hz / to_hz);
    3c44:	220a      	movs	r2, #10
    3c46:	2300      	movs	r3, #0
    3c48:	f7fc fb1c 	bl	284 <__aeabi_uldivmod>
    3c4c:	0002      	movs	r2, r0
    3c4e:	0030      	movs	r0, r6
    3c50:	4f0e      	ldr	r7, [pc, #56]	; (3c8c <z_init_static_threads+0xf4>)
    3c52:	000b      	movs	r3, r1
    3c54:	3018      	adds	r0, #24
    3c56:	0039      	movs	r1, r7
    3c58:	f001 fa6e 	bl	5138 <z_add_timeout>
    3c5c:	e7f0      	b.n	3c40 <z_init_static_threads+0xa8>
    3c5e:	42ac      	cmp	r4, r5
    3c60:	d3d7      	bcc.n	3c12 <z_init_static_threads+0x7a>
	k_sched_unlock();
    3c62:	f000 fb93 	bl	438c <k_sched_unlock>
}
    3c66:	b009      	add	sp, #36	; 0x24
    3c68:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3c6a:	46c0      	nop			; (mov r8, r8)
    3c6c:	00005e64 	.word	0x00005e64
    3c70:	00005e64 	.word	0x00005e64
    3c74:	00006d97 	.word	0x00006d97
    3c78:	00006ea2 	.word	0x00006ea2
    3c7c:	00006347 	.word	0x00006347
    3c80:	000002f3 	.word	0x000002f3
    3c84:	00006c87 	.word	0x00006c87
    3c88:	00000312 	.word	0x00000312
    3c8c:	00005cf5 	.word	0x00005cf5

00003c90 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
    3c90:	6803      	ldr	r3, [r0, #0]
	if (thread_cpu != 0U) {
		if ((thread_cpu & 3U) == _current_cpu->id) {
			return false;
		}
	}
	return true;
    3c92:	2001      	movs	r0, #1
	if (thread_cpu != 0U) {
    3c94:	2b00      	cmp	r3, #0
    3c96:	d007      	beq.n	3ca8 <z_spin_lock_valid+0x18>
		if ((thread_cpu & 3U) == _current_cpu->id) {
    3c98:	2203      	movs	r2, #3
    3c9a:	4013      	ands	r3, r2
    3c9c:	4a03      	ldr	r2, [pc, #12]	; (3cac <z_spin_lock_valid+0x1c>)
    3c9e:	7c12      	ldrb	r2, [r2, #16]
    3ca0:	1a9b      	subs	r3, r3, r2
    3ca2:	1e5a      	subs	r2, r3, #1
    3ca4:	4193      	sbcs	r3, r2
    3ca6:	b2d8      	uxtb	r0, r3
}
    3ca8:	4770      	bx	lr
    3caa:	46c0      	nop			; (mov r8, r8)
    3cac:	20000330 	.word	0x20000330

00003cb0 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
    3cb0:	4a05      	ldr	r2, [pc, #20]	; (3cc8 <z_spin_unlock_valid+0x18>)
{
    3cb2:	0003      	movs	r3, r0
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
    3cb4:	7c11      	ldrb	r1, [r2, #16]
    3cb6:	6892      	ldr	r2, [r2, #8]
    3cb8:	430a      	orrs	r2, r1
    3cba:	6801      	ldr	r1, [r0, #0]
    3cbc:	2000      	movs	r0, #0
    3cbe:	4291      	cmp	r1, r2
    3cc0:	d101      	bne.n	3cc6 <z_spin_unlock_valid+0x16>
		return false;
	}
	l->thread_cpu = 0;
    3cc2:	6018      	str	r0, [r3, #0]
	return true;
    3cc4:	3001      	adds	r0, #1
}
    3cc6:	4770      	bx	lr
    3cc8:	20000330 	.word	0x20000330

00003ccc <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
    3ccc:	4b02      	ldr	r3, [pc, #8]	; (3cd8 <z_spin_lock_set_owner+0xc>)
    3cce:	7c1a      	ldrb	r2, [r3, #16]
    3cd0:	689b      	ldr	r3, [r3, #8]
    3cd2:	4313      	orrs	r3, r2
    3cd4:	6003      	str	r3, [r0, #0]
}
    3cd6:	4770      	bx	lr
    3cd8:	20000330 	.word	0x20000330

00003cdc <idle>:
	sys_clock_idle_exit();
#endif
}

void idle(void *unused1, void *unused2, void *unused3)
{
    3cdc:	b510      	push	{r4, lr}
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	__ASSERT_NO_MSG(_current->base.prio >= 0);
    3cde:	4c10      	ldr	r4, [pc, #64]	; (3d20 <idle+0x44>)
    3ce0:	68a3      	ldr	r3, [r4, #8]
    3ce2:	7b9b      	ldrb	r3, [r3, #14]
    3ce4:	2b7f      	cmp	r3, #127	; 0x7f
    3ce6:	d90e      	bls.n	3d06 <idle+0x2a>
    3ce8:	4c0e      	ldr	r4, [pc, #56]	; (3d24 <idle+0x48>)
    3cea:	490f      	ldr	r1, [pc, #60]	; (3d28 <idle+0x4c>)
    3cec:	480f      	ldr	r0, [pc, #60]	; (3d2c <idle+0x50>)
    3cee:	2329      	movs	r3, #41	; 0x29
    3cf0:	0022      	movs	r2, r4
    3cf2:	f001 fdf9 	bl	58e8 <assert_print>
    3cf6:	2129      	movs	r1, #41	; 0x29
    3cf8:	0020      	movs	r0, r4
    3cfa:	f001 fdf1 	bl	58e0 <assert_post_action>
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
    3cfe:	f7fd fa11 	bl	1124 <pm_system_suspend>
    3d02:	2800      	cmp	r0, #0
    3d04:	d009      	beq.n	3d1a <idle+0x3e>
	__asm__ volatile("mrs %0, PRIMASK;"
    3d06:	f3ef 8310 	mrs	r3, PRIMASK
    3d0a:	b672      	cpsid	i
		_kernel.idle = z_get_next_timeout_expiry();
    3d0c:	f001 fb20 	bl	5350 <z_get_next_timeout_expiry>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
    3d10:	4b07      	ldr	r3, [pc, #28]	; (3d30 <idle+0x54>)
    3d12:	6160      	str	r0, [r4, #20]
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
    3d14:	781b      	ldrb	r3, [r3, #0]
    3d16:	2b00      	cmp	r3, #0
    3d18:	d1f1      	bne.n	3cfe <idle+0x22>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    3d1a:	f7fd fb2f 	bl	137c <arch_cpu_idle>
}
    3d1e:	e7f2      	b.n	3d06 <idle+0x2a>
    3d20:	20000330 	.word	0x20000330
    3d24:	00006ecf 	.word	0x00006ecf
    3d28:	00006ef0 	.word	0x00006ef0
    3d2c:	00006347 	.word	0x00006347
    3d30:	20000378 	.word	0x20000378

00003d34 <z_impl_k_sem_give>:
	return false;
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    3d34:	b570      	push	{r4, r5, r6, lr}
    3d36:	0005      	movs	r5, r0
    3d38:	f3ef 8610 	mrs	r6, PRIMASK
    3d3c:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    3d3e:	4c23      	ldr	r4, [pc, #140]	; (3dcc <z_impl_k_sem_give+0x98>)
    3d40:	0020      	movs	r0, r4
    3d42:	f7ff ffa5 	bl	3c90 <z_spin_lock_valid>
    3d46:	2800      	cmp	r0, #0
    3d48:	d10e      	bne.n	3d68 <z_impl_k_sem_give+0x34>
    3d4a:	4d21      	ldr	r5, [pc, #132]	; (3dd0 <z_impl_k_sem_give+0x9c>)
    3d4c:	2394      	movs	r3, #148	; 0x94
    3d4e:	002a      	movs	r2, r5
    3d50:	4920      	ldr	r1, [pc, #128]	; (3dd4 <z_impl_k_sem_give+0xa0>)
    3d52:	4821      	ldr	r0, [pc, #132]	; (3dd8 <z_impl_k_sem_give+0xa4>)
    3d54:	f001 fdc8 	bl	58e8 <assert_print>
    3d58:	0021      	movs	r1, r4
    3d5a:	4820      	ldr	r0, [pc, #128]	; (3ddc <z_impl_k_sem_give+0xa8>)
    3d5c:	f001 fdc4 	bl	58e8 <assert_print>
    3d60:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    3d62:	0028      	movs	r0, r5
    3d64:	f001 fdbc 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    3d68:	0020      	movs	r0, r4
    3d6a:	f7ff ffaf 	bl	3ccc <z_spin_lock_set_owner>
	struct k_thread *thread;
	bool resched = true;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    3d6e:	0028      	movs	r0, r5
    3d70:	f000 fe24 	bl	49bc <z_unpend_first_thread>

	if (thread != NULL) {
    3d74:	2800      	cmp	r0, #0
    3d76:	d00a      	beq.n	3d8e <z_impl_k_sem_give+0x5a>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    3d78:	0003      	movs	r3, r0
    3d7a:	2200      	movs	r2, #0
    3d7c:	338c      	adds	r3, #140	; 0x8c
    3d7e:	601a      	str	r2, [r3, #0]
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    3d80:	f000 f9b4 	bl	40ec <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		resched = handle_poll_events(sem);
	}

	if (resched) {
		z_reschedule(&lock, key);
    3d84:	0031      	movs	r1, r6
    3d86:	0020      	movs	r0, r4
    3d88:	f000 f9f6 	bl	4178 <z_reschedule>
	} else {
		k_spin_unlock(&lock, key);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    3d8c:	bd70      	pop	{r4, r5, r6, pc}
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    3d8e:	68aa      	ldr	r2, [r5, #8]
    3d90:	68eb      	ldr	r3, [r5, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    3d92:	0020      	movs	r0, r4
    3d94:	1a9b      	subs	r3, r3, r2
    3d96:	1e59      	subs	r1, r3, #1
    3d98:	418b      	sbcs	r3, r1
    3d9a:	189b      	adds	r3, r3, r2
    3d9c:	60ab      	str	r3, [r5, #8]
    3d9e:	f7ff ff87 	bl	3cb0 <z_spin_unlock_valid>
    3da2:	2800      	cmp	r0, #0
    3da4:	d10c      	bne.n	3dc0 <z_impl_k_sem_give+0x8c>
    3da6:	4d0a      	ldr	r5, [pc, #40]	; (3dd0 <z_impl_k_sem_give+0x9c>)
    3da8:	23c3      	movs	r3, #195	; 0xc3
    3daa:	002a      	movs	r2, r5
    3dac:	490c      	ldr	r1, [pc, #48]	; (3de0 <z_impl_k_sem_give+0xac>)
    3dae:	480a      	ldr	r0, [pc, #40]	; (3dd8 <z_impl_k_sem_give+0xa4>)
    3db0:	f001 fd9a 	bl	58e8 <assert_print>
    3db4:	0021      	movs	r1, r4
    3db6:	480b      	ldr	r0, [pc, #44]	; (3de4 <z_impl_k_sem_give+0xb0>)
    3db8:	f001 fd96 	bl	58e8 <assert_print>
    3dbc:	21c3      	movs	r1, #195	; 0xc3
    3dbe:	e7d0      	b.n	3d62 <z_impl_k_sem_give+0x2e>
	if (key != 0U) {
    3dc0:	2e00      	cmp	r6, #0
    3dc2:	d1e3      	bne.n	3d8c <z_impl_k_sem_give+0x58>
	__asm__ volatile(
    3dc4:	b662      	cpsie	i
    3dc6:	f3bf 8f6f 	isb	sy
}
    3dca:	e7df      	b.n	3d8c <z_impl_k_sem_give+0x58>
    3dcc:	20000354 	.word	0x20000354
    3dd0:	00006305 	.word	0x00006305
    3dd4:	00006332 	.word	0x00006332
    3dd8:	00006347 	.word	0x00006347
    3ddc:	00006364 	.word	0x00006364
    3de0:	0000637c 	.word	0x0000637c
    3de4:	00006393 	.word	0x00006393

00003de8 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    3de8:	b5f0      	push	{r4, r5, r6, r7, lr}
    3dea:	b085      	sub	sp, #20
    3dec:	0005      	movs	r5, r0
    3dee:	0016      	movs	r6, r2
    3df0:	9303      	str	r3, [sp, #12]
    3df2:	f3ef 8305 	mrs	r3, IPSR
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
    3df6:	2b00      	cmp	r3, #0
    3df8:	d010      	beq.n	3e1c <z_impl_k_sem_take+0x34>
    3dfa:	9b03      	ldr	r3, [sp, #12]
    3dfc:	4313      	orrs	r3, r2
    3dfe:	d00d      	beq.n	3e1c <z_impl_k_sem_take+0x34>
    3e00:	4c2f      	ldr	r4, [pc, #188]	; (3ec0 <z_impl_k_sem_take+0xd8>)
    3e02:	4930      	ldr	r1, [pc, #192]	; (3ec4 <z_impl_k_sem_take+0xdc>)
    3e04:	2380      	movs	r3, #128	; 0x80
    3e06:	0022      	movs	r2, r4
    3e08:	482f      	ldr	r0, [pc, #188]	; (3ec8 <z_impl_k_sem_take+0xe0>)
    3e0a:	f001 fd6d 	bl	58e8 <assert_print>
    3e0e:	482f      	ldr	r0, [pc, #188]	; (3ecc <z_impl_k_sem_take+0xe4>)
    3e10:	f001 fd6a 	bl	58e8 <assert_print>
    3e14:	2180      	movs	r1, #128	; 0x80
    3e16:	0020      	movs	r0, r4
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    3e18:	f001 fd62 	bl	58e0 <assert_post_action>
	__asm__ volatile("mrs %0, PRIMASK;"
    3e1c:	f3ef 8710 	mrs	r7, PRIMASK
    3e20:	b672      	cpsid	i
    3e22:	4c2b      	ldr	r4, [pc, #172]	; (3ed0 <z_impl_k_sem_take+0xe8>)
    3e24:	0020      	movs	r0, r4
    3e26:	f7ff ff33 	bl	3c90 <z_spin_lock_valid>
    3e2a:	2800      	cmp	r0, #0
    3e2c:	d10d      	bne.n	3e4a <z_impl_k_sem_take+0x62>
    3e2e:	4d29      	ldr	r5, [pc, #164]	; (3ed4 <z_impl_k_sem_take+0xec>)
    3e30:	2394      	movs	r3, #148	; 0x94
    3e32:	002a      	movs	r2, r5
    3e34:	4928      	ldr	r1, [pc, #160]	; (3ed8 <z_impl_k_sem_take+0xf0>)
    3e36:	4824      	ldr	r0, [pc, #144]	; (3ec8 <z_impl_k_sem_take+0xe0>)
    3e38:	f001 fd56 	bl	58e8 <assert_print>
    3e3c:	0021      	movs	r1, r4
    3e3e:	4827      	ldr	r0, [pc, #156]	; (3edc <z_impl_k_sem_take+0xf4>)
    3e40:	f001 fd52 	bl	58e8 <assert_print>
    3e44:	2194      	movs	r1, #148	; 0x94
    3e46:	0028      	movs	r0, r5
    3e48:	e7e6      	b.n	3e18 <z_impl_k_sem_take+0x30>
	z_spin_lock_set_owner(l);
    3e4a:	0020      	movs	r0, r4
    3e4c:	f7ff ff3e 	bl	3ccc <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
    3e50:	68ab      	ldr	r3, [r5, #8]
    3e52:	2b00      	cmp	r3, #0
    3e54:	d01b      	beq.n	3e8e <z_impl_k_sem_take+0xa6>
		sem->count--;
    3e56:	3b01      	subs	r3, #1
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    3e58:	0020      	movs	r0, r4
    3e5a:	60ab      	str	r3, [r5, #8]
    3e5c:	f7ff ff28 	bl	3cb0 <z_spin_unlock_valid>
    3e60:	2800      	cmp	r0, #0
    3e62:	d10c      	bne.n	3e7e <z_impl_k_sem_take+0x96>
    3e64:	4d1b      	ldr	r5, [pc, #108]	; (3ed4 <z_impl_k_sem_take+0xec>)
    3e66:	23c3      	movs	r3, #195	; 0xc3
    3e68:	002a      	movs	r2, r5
    3e6a:	491d      	ldr	r1, [pc, #116]	; (3ee0 <z_impl_k_sem_take+0xf8>)
    3e6c:	4816      	ldr	r0, [pc, #88]	; (3ec8 <z_impl_k_sem_take+0xe0>)
    3e6e:	f001 fd3b 	bl	58e8 <assert_print>
    3e72:	0021      	movs	r1, r4
    3e74:	481b      	ldr	r0, [pc, #108]	; (3ee4 <z_impl_k_sem_take+0xfc>)
    3e76:	f001 fd37 	bl	58e8 <assert_print>
    3e7a:	21c3      	movs	r1, #195	; 0xc3
    3e7c:	e7e3      	b.n	3e46 <z_impl_k_sem_take+0x5e>
	if (key != 0U) {
    3e7e:	2f00      	cmp	r7, #0
    3e80:	d102      	bne.n	3e88 <z_impl_k_sem_take+0xa0>
	__asm__ volatile(
    3e82:	b662      	cpsie	i
    3e84:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
    3e88:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
    3e8a:	b005      	add	sp, #20
    3e8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    3e8e:	9b03      	ldr	r3, [sp, #12]
    3e90:	4333      	orrs	r3, r6
    3e92:	d10c      	bne.n	3eae <z_impl_k_sem_take+0xc6>
    3e94:	0020      	movs	r0, r4
    3e96:	f7ff ff0b 	bl	3cb0 <z_spin_unlock_valid>
    3e9a:	2800      	cmp	r0, #0
    3e9c:	d0e2      	beq.n	3e64 <z_impl_k_sem_take+0x7c>
	if (key != 0U) {
    3e9e:	2f00      	cmp	r7, #0
    3ea0:	d102      	bne.n	3ea8 <z_impl_k_sem_take+0xc0>
	__asm__ volatile(
    3ea2:	b662      	cpsie	i
    3ea4:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
    3ea8:	2010      	movs	r0, #16
    3eaa:	4240      	negs	r0, r0
    3eac:	e7ed      	b.n	3e8a <z_impl_k_sem_take+0xa2>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    3eae:	9b03      	ldr	r3, [sp, #12]
    3eb0:	002a      	movs	r2, r5
    3eb2:	0039      	movs	r1, r7
    3eb4:	0020      	movs	r0, r4
    3eb6:	9600      	str	r6, [sp, #0]
    3eb8:	9301      	str	r3, [sp, #4]
    3eba:	f000 fc29 	bl	4710 <z_pend_curr>
	return ret;
    3ebe:	e7e4      	b.n	3e8a <z_impl_k_sem_take+0xa2>
    3ec0:	00006f18 	.word	0x00006f18
    3ec4:	00006f38 	.word	0x00006f38
    3ec8:	00006347 	.word	0x00006347
    3ecc:	00006f86 	.word	0x00006f86
    3ed0:	20000354 	.word	0x20000354
    3ed4:	00006305 	.word	0x00006305
    3ed8:	00006332 	.word	0x00006332
    3edc:	00006364 	.word	0x00006364
    3ee0:	0000637c 	.word	0x0000637c
    3ee4:	00006393 	.word	0x00006393

00003ee8 <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
    3ee8:	89c2      	ldrh	r2, [r0, #14]
{
    3eea:	0003      	movs	r3, r0
		&& !z_is_idle_thread_object(thread);
    3eec:	2000      	movs	r0, #0
    3eee:	2a7f      	cmp	r2, #127	; 0x7f
    3ef0:	d811      	bhi.n	3f16 <sliceable+0x2e>
	int ret = slice_ticks;
    3ef2:	4a0a      	ldr	r2, [pc, #40]	; (3f1c <sliceable+0x34>)
    3ef4:	6810      	ldr	r0, [r2, #0]
		&& slice_time(thread) != 0
    3ef6:	2800      	cmp	r0, #0
    3ef8:	d00d      	beq.n	3f16 <sliceable+0x2e>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    3efa:	210e      	movs	r1, #14
    3efc:	4a08      	ldr	r2, [pc, #32]	; (3f20 <sliceable+0x38>)
    3efe:	5659      	ldrsb	r1, [r3, r1]
    3f00:	6812      	ldr	r2, [r2, #0]
		&& !z_is_idle_thread_object(thread);
    3f02:	2000      	movs	r0, #0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    3f04:	4291      	cmp	r1, r2
    3f06:	db06      	blt.n	3f16 <sliceable+0x2e>
		&& !z_is_thread_prevented_from_running(thread)
    3f08:	7b5a      	ldrb	r2, [r3, #13]
    3f0a:	06d2      	lsls	r2, r2, #27
    3f0c:	d103      	bne.n	3f16 <sliceable+0x2e>
		&& !z_is_idle_thread_object(thread);
    3f0e:	4805      	ldr	r0, [pc, #20]	; (3f24 <sliceable+0x3c>)
    3f10:	1a18      	subs	r0, r3, r0
    3f12:	1e43      	subs	r3, r0, #1
    3f14:	4198      	sbcs	r0, r3

#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
    3f16:	2301      	movs	r3, #1
    3f18:	4018      	ands	r0, r3
}
    3f1a:	4770      	bx	lr
    3f1c:	20000360 	.word	0x20000360
    3f20:	2000035c 	.word	0x2000035c
    3f24:	20000120 	.word	0x20000120

00003f28 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
    3f28:	b510      	push	{r4, lr}
	int cpu = ARRAY_INDEX(slice_timeouts, t);
    3f2a:	2800      	cmp	r0, #0
    3f2c:	d00e      	beq.n	3f4c <slice_timeout+0x24>
    3f2e:	4b11      	ldr	r3, [pc, #68]	; (3f74 <__kernel_ram_size+0x4>)
    3f30:	4298      	cmp	r0, r3
    3f32:	d30b      	bcc.n	3f4c <slice_timeout+0x24>
    3f34:	4a10      	ldr	r2, [pc, #64]	; (3f78 <__kernel_ram_size+0x8>)
    3f36:	4290      	cmp	r0, r2
    3f38:	d208      	bcs.n	3f4c <slice_timeout+0x24>
    3f3a:	1ac0      	subs	r0, r0, r3
    3f3c:	4b0f      	ldr	r3, [pc, #60]	; (3f7c <__kernel_ram_size+0xc>)
    3f3e:	2103      	movs	r1, #3
    3f40:	001a      	movs	r2, r3
    3f42:	4342      	muls	r2, r0
    3f44:	41ca      	rors	r2, r1
    3f46:	490e      	ldr	r1, [pc, #56]	; (3f80 <__kernel_ram_size+0x10>)
    3f48:	428a      	cmp	r2, r1
    3f4a:	d90c      	bls.n	3f66 <slice_timeout+0x3e>
    3f4c:	23c8      	movs	r3, #200	; 0xc8
    3f4e:	4c0d      	ldr	r4, [pc, #52]	; (3f84 <__kernel_ram_size+0x14>)
    3f50:	490d      	ldr	r1, [pc, #52]	; (3f88 <__kernel_ram_size+0x18>)
    3f52:	480e      	ldr	r0, [pc, #56]	; (3f8c <__kernel_ram_size+0x1c>)
    3f54:	0022      	movs	r2, r4
    3f56:	33ff      	adds	r3, #255	; 0xff
    3f58:	f001 fcc6 	bl	58e8 <assert_print>
    3f5c:	21c8      	movs	r1, #200	; 0xc8
    3f5e:	0020      	movs	r0, r4
    3f60:	31ff      	adds	r1, #255	; 0xff
    3f62:	f001 fcbd 	bl	58e0 <assert_post_action>

	slice_expired[cpu] = true;
    3f66:	2101      	movs	r1, #1
	int cpu = ARRAY_INDEX(slice_timeouts, t);
    3f68:	10c0      	asrs	r0, r0, #3
    3f6a:	4343      	muls	r3, r0
	slice_expired[cpu] = true;
    3f6c:	4a08      	ldr	r2, [pc, #32]	; (3f90 <__kernel_ram_size+0x20>)
    3f6e:	54d1      	strb	r1, [r2, r3]
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
    3f70:	bd10      	pop	{r4, pc}
    3f72:	46c0      	nop			; (mov r8, r8)
    3f74:	20000240 	.word	0x20000240
    3f78:	20000258 	.word	0x20000258
    3f7c:	aaaaaaab 	.word	0xaaaaaaab
    3f80:	0aaaaaaa 	.word	0x0aaaaaaa
    3f84:	00006f89 	.word	0x00006f89
    3f88:	00006fab 	.word	0x00006fab
    3f8c:	00006347 	.word	0x00006347
    3f90:	20000379 	.word	0x20000379

00003f94 <z_reset_time_slice>:

void z_reset_time_slice(struct k_thread *curr)
{
    3f94:	b570      	push	{r4, r5, r6, lr}
	int cpu = _current_cpu->id;

	z_abort_timeout(&slice_timeouts[cpu]);
    3f96:	2418      	movs	r4, #24
	int cpu = _current_cpu->id;
    3f98:	4b0c      	ldr	r3, [pc, #48]	; (3fcc <z_reset_time_slice+0x38>)
{
    3f9a:	0005      	movs	r5, r0
	int cpu = _current_cpu->id;
    3f9c:	7c1e      	ldrb	r6, [r3, #16]
	z_abort_timeout(&slice_timeouts[cpu]);
    3f9e:	4b0c      	ldr	r3, [pc, #48]	; (3fd0 <z_reset_time_slice+0x3c>)
    3fa0:	4374      	muls	r4, r6
    3fa2:	18e4      	adds	r4, r4, r3
    3fa4:	0020      	movs	r0, r4
    3fa6:	f001 f985 	bl	52b4 <z_abort_timeout>
	slice_expired[cpu] = false;
    3faa:	2200      	movs	r2, #0
    3fac:	4b09      	ldr	r3, [pc, #36]	; (3fd4 <z_reset_time_slice+0x40>)
	if (sliceable(curr)) {
    3fae:	0028      	movs	r0, r5
	slice_expired[cpu] = false;
    3fb0:	559a      	strb	r2, [r3, r6]
	if (sliceable(curr)) {
    3fb2:	f7ff ff99 	bl	3ee8 <sliceable>
    3fb6:	2800      	cmp	r0, #0
    3fb8:	d007      	beq.n	3fca <z_reset_time_slice+0x36>
	int ret = slice_ticks;
    3fba:	4b07      	ldr	r3, [pc, #28]	; (3fd8 <z_reset_time_slice+0x44>)
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
    3fbc:	0020      	movs	r0, r4
			      K_TICKS(slice_time(curr) - 1));
    3fbe:	681a      	ldr	r2, [r3, #0]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
    3fc0:	4906      	ldr	r1, [pc, #24]	; (3fdc <z_reset_time_slice+0x48>)
			      K_TICKS(slice_time(curr) - 1));
    3fc2:	3a01      	subs	r2, #1
    3fc4:	17d3      	asrs	r3, r2, #31
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
    3fc6:	f001 f8b7 	bl	5138 <z_add_timeout>
	}
}
    3fca:	bd70      	pop	{r4, r5, r6, pc}
    3fcc:	20000330 	.word	0x20000330
    3fd0:	20000240 	.word	0x20000240
    3fd4:	20000379 	.word	0x20000379
    3fd8:	20000360 	.word	0x20000360
    3fdc:	00003f29 	.word	0x00003f29

00003fe0 <update_cache>:
	}
#endif
}

static void update_cache(int preempt_ok)
{
    3fe0:	b570      	push	{r4, r5, r6, lr}
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    3fe2:	4d16      	ldr	r5, [pc, #88]	; (403c <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3c>)
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    3fe4:	4b16      	ldr	r3, [pc, #88]	; (4040 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40>)
	return list->head == list;
    3fe6:	69ec      	ldr	r4, [r5, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    3fe8:	429c      	cmp	r4, r3
    3fea:	d001      	beq.n	3ff0 <update_cache+0x10>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    3fec:	2c00      	cmp	r4, #0
    3fee:	d100      	bne.n	3ff2 <update_cache+0x12>
    3ff0:	68ec      	ldr	r4, [r5, #12]
	__ASSERT(_current != NULL, "");
    3ff2:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
    3ff4:	2800      	cmp	r0, #0
    3ff6:	d118      	bne.n	402a <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x2a>
	__ASSERT(_current != NULL, "");
    3ff8:	2b00      	cmp	r3, #0
    3ffa:	d10d      	bne.n	4018 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x18>
    3ffc:	4c11      	ldr	r4, [pc, #68]	; (4044 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x44>)
    3ffe:	4912      	ldr	r1, [pc, #72]	; (4048 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x48>)
    4000:	0022      	movs	r2, r4
    4002:	4812      	ldr	r0, [pc, #72]	; (404c <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4c>)
    4004:	338a      	adds	r3, #138	; 0x8a
    4006:	f001 fc6f 	bl	58e8 <assert_print>
    400a:	4811      	ldr	r0, [pc, #68]	; (4050 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x50>)
    400c:	f001 fc6c 	bl	58e8 <assert_print>
    4010:	218a      	movs	r1, #138	; 0x8a
    4012:	0020      	movs	r0, r4
    4014:	f001 fc64 	bl	58e0 <assert_post_action>
	if (z_is_thread_prevented_from_running(_current)) {
    4018:	7b5a      	ldrb	r2, [r3, #13]
    401a:	06d2      	lsls	r2, r2, #27
    401c:	d105      	bne.n	402a <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    401e:	69a2      	ldr	r2, [r4, #24]
    4020:	2a00      	cmp	r2, #0
    4022:	d102      	bne.n	402a <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
    4024:	89da      	ldrh	r2, [r3, #14]
    4026:	2a7f      	cmp	r2, #127	; 0x7f
    4028:	d805      	bhi.n	4036 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x36>
#ifndef CONFIG_SMP
	struct k_thread *thread = next_up();

	if (should_preempt(thread, preempt_ok)) {
#ifdef CONFIG_TIMESLICING
		if (thread != _current) {
    402a:	429c      	cmp	r4, r3
    402c:	d002      	beq.n	4034 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x34>
			z_reset_time_slice(thread);
    402e:	0020      	movs	r0, r4
    4030:	f7ff ffb0 	bl	3f94 <z_reset_time_slice>
		}
#endif
		update_metairq_preempt(thread);
		_kernel.ready_q.cache = thread;
    4034:	0023      	movs	r3, r4
    4036:	61ab      	str	r3, [r5, #24]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
    4038:	bd70      	pop	{r4, r5, r6, pc}
    403a:	46c0      	nop			; (mov r8, r8)
    403c:	20000330 	.word	0x20000330
    4040:	2000034c 	.word	0x2000034c
    4044:	00006f89 	.word	0x00006f89
    4048:	00007144 	.word	0x00007144
    404c:	00006347 	.word	0x00006347
    4050:	00006f86 	.word	0x00006f86

00004054 <ready_thread>:
#endif

	/* If thread is queued already, do not try and added it to the
	 * run queue again
	 */
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    4054:	230d      	movs	r3, #13
{
    4056:	b570      	push	{r4, r5, r6, lr}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    4058:	56c3      	ldrsb	r3, [r0, r3]
	return (thread->base.thread_state & state) != 0U;
    405a:	7b41      	ldrb	r1, [r0, #13]
    405c:	2b00      	cmp	r3, #0
    405e:	db34      	blt.n	40ca <ready_thread+0x76>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    4060:	06cb      	lsls	r3, r1, #27
    4062:	d132      	bne.n	40ca <ready_thread+0x76>
	return node->next != NULL;
    4064:	6983      	ldr	r3, [r0, #24]
    4066:	2b00      	cmp	r3, #0
    4068:	d12f      	bne.n	40ca <ready_thread+0x76>
	thread->base.thread_state |= _THREAD_QUEUED;
    406a:	2280      	movs	r2, #128	; 0x80
    406c:	4252      	negs	r2, r2
    406e:	430a      	orrs	r2, r1
    4070:	7342      	strb	r2, [r0, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    4072:	4a18      	ldr	r2, [pc, #96]	; (40d4 <ready_thread+0x80>)
    4074:	4290      	cmp	r0, r2
    4076:	d10a      	bne.n	408e <ready_thread+0x3a>
    4078:	4c17      	ldr	r4, [pc, #92]	; (40d8 <ready_thread+0x84>)
    407a:	4918      	ldr	r1, [pc, #96]	; (40dc <ready_thread+0x88>)
    407c:	4818      	ldr	r0, [pc, #96]	; (40e0 <ready_thread+0x8c>)
    407e:	0022      	movs	r2, r4
    4080:	33bc      	adds	r3, #188	; 0xbc
    4082:	f001 fc31 	bl	58e8 <assert_print>
    4086:	21bc      	movs	r1, #188	; 0xbc
    4088:	0020      	movs	r0, r4
    408a:	f001 fc29 	bl	58e0 <assert_post_action>
	return list->head == list;
    408e:	4a15      	ldr	r2, [pc, #84]	; (40e4 <ready_thread+0x90>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4090:	4c15      	ldr	r4, [pc, #84]	; (40e8 <ready_thread+0x94>)
	return list->head == list;
    4092:	69d1      	ldr	r1, [r2, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4094:	42a1      	cmp	r1, r4
    4096:	d000      	beq.n	409a <ready_thread+0x46>
    4098:	000b      	movs	r3, r1
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
    409a:	6a11      	ldr	r1, [r2, #32]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    409c:	2b00      	cmp	r3, #0
    409e:	d104      	bne.n	40aa <ready_thread+0x56>

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;

	node->next = list;
    40a0:	6004      	str	r4, [r0, #0]
	node->prev = tail;
    40a2:	6041      	str	r1, [r0, #4]

	tail->next = node;
    40a4:	6008      	str	r0, [r1, #0]
	list->tail = node;
    40a6:	6210      	str	r0, [r2, #32]
}
    40a8:	e00c      	b.n	40c4 <ready_thread+0x70>
	int32_t b1 = thread_1->base.prio;
    40aa:	250e      	movs	r5, #14
	int32_t b2 = thread_2->base.prio;
    40ac:	260e      	movs	r6, #14
	int32_t b1 = thread_1->base.prio;
    40ae:	5745      	ldrsb	r5, [r0, r5]
	int32_t b2 = thread_2->base.prio;
    40b0:	579e      	ldrsb	r6, [r3, r6]
	if (b1 != b2) {
    40b2:	42b5      	cmp	r5, r6
    40b4:	d00a      	beq.n	40cc <ready_thread+0x78>
		if (z_sched_prio_cmp(thread, t) > 0) {
    40b6:	42ae      	cmp	r6, r5
    40b8:	dd08      	ble.n	40cc <ready_thread+0x78>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
    40ba:	685a      	ldr	r2, [r3, #4]

	node->prev = prev;
	node->next = successor;
    40bc:	6003      	str	r3, [r0, #0]
	node->prev = prev;
    40be:	6042      	str	r2, [r0, #4]
	prev->next = node;
    40c0:	6010      	str	r0, [r2, #0]
	successor->prev = node;
    40c2:	6058      	str	r0, [r3, #4]
		SYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_ready, thread);

		queue_thread(thread);
		update_cache(0);
    40c4:	2000      	movs	r0, #0
    40c6:	f7ff ff8b 	bl	3fe0 <update_cache>
		flag_ipi();
	}
}
    40ca:	bd70      	pop	{r4, r5, r6, pc}
	return (node == list->tail) ? NULL : node->next;
    40cc:	428b      	cmp	r3, r1
    40ce:	d0e7      	beq.n	40a0 <ready_thread+0x4c>
    40d0:	681b      	ldr	r3, [r3, #0]
    40d2:	e7e3      	b.n	409c <ready_thread+0x48>
    40d4:	20000120 	.word	0x20000120
    40d8:	00006f89 	.word	0x00006f89
    40dc:	0000716b 	.word	0x0000716b
    40e0:	00006347 	.word	0x00006347
    40e4:	20000330 	.word	0x20000330
    40e8:	2000034c 	.word	0x2000034c

000040ec <z_ready_thread>:

void z_ready_thread(struct k_thread *thread)
{
    40ec:	b570      	push	{r4, r5, r6, lr}
    40ee:	0005      	movs	r5, r0
	__asm__ volatile("mrs %0, PRIMASK;"
    40f0:	f3ef 8610 	mrs	r6, PRIMASK
    40f4:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    40f6:	4c19      	ldr	r4, [pc, #100]	; (415c <z_ready_thread+0x70>)
    40f8:	0020      	movs	r0, r4
    40fa:	f7ff fdc9 	bl	3c90 <z_spin_lock_valid>
    40fe:	2800      	cmp	r0, #0
    4100:	d10e      	bne.n	4120 <z_ready_thread+0x34>
    4102:	4d17      	ldr	r5, [pc, #92]	; (4160 <z_ready_thread+0x74>)
    4104:	2394      	movs	r3, #148	; 0x94
    4106:	002a      	movs	r2, r5
    4108:	4916      	ldr	r1, [pc, #88]	; (4164 <z_ready_thread+0x78>)
    410a:	4817      	ldr	r0, [pc, #92]	; (4168 <z_ready_thread+0x7c>)
    410c:	f001 fbec 	bl	58e8 <assert_print>
    4110:	0021      	movs	r1, r4
    4112:	4816      	ldr	r0, [pc, #88]	; (416c <z_ready_thread+0x80>)
    4114:	f001 fbe8 	bl	58e8 <assert_print>
    4118:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    411a:	0028      	movs	r0, r5
    411c:	f001 fbe0 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    4120:	0020      	movs	r0, r4
    4122:	f7ff fdd3 	bl	3ccc <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		if (!thread_active_elsewhere(thread)) {
			ready_thread(thread);
    4126:	0028      	movs	r0, r5
    4128:	f7ff ff94 	bl	4054 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    412c:	0020      	movs	r0, r4
    412e:	f7ff fdbf 	bl	3cb0 <z_spin_unlock_valid>
    4132:	2800      	cmp	r0, #0
    4134:	d10c      	bne.n	4150 <z_ready_thread+0x64>
    4136:	4d0a      	ldr	r5, [pc, #40]	; (4160 <z_ready_thread+0x74>)
    4138:	23c3      	movs	r3, #195	; 0xc3
    413a:	002a      	movs	r2, r5
    413c:	490c      	ldr	r1, [pc, #48]	; (4170 <z_ready_thread+0x84>)
    413e:	480a      	ldr	r0, [pc, #40]	; (4168 <z_ready_thread+0x7c>)
    4140:	f001 fbd2 	bl	58e8 <assert_print>
    4144:	0021      	movs	r1, r4
    4146:	480b      	ldr	r0, [pc, #44]	; (4174 <z_ready_thread+0x88>)
    4148:	f001 fbce 	bl	58e8 <assert_print>
    414c:	21c3      	movs	r1, #195	; 0xc3
    414e:	e7e4      	b.n	411a <z_ready_thread+0x2e>
	if (key != 0U) {
    4150:	2e00      	cmp	r6, #0
    4152:	d102      	bne.n	415a <z_ready_thread+0x6e>
	__asm__ volatile(
    4154:	b662      	cpsie	i
    4156:	f3bf 8f6f 	isb	sy
		}
	}
}
    415a:	bd70      	pop	{r4, r5, r6, pc}
    415c:	20000364 	.word	0x20000364
    4160:	00006305 	.word	0x00006305
    4164:	00006332 	.word	0x00006332
    4168:	00006347 	.word	0x00006347
    416c:	00006364 	.word	0x00006364
    4170:	0000637c 	.word	0x0000637c
    4174:	00006393 	.word	0x00006393

00004178 <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
    4178:	b570      	push	{r4, r5, r6, lr}
    417a:	0004      	movs	r4, r0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    417c:	2900      	cmp	r1, #0
    417e:	d11f      	bne.n	41c0 <z_reschedule+0x48>
    4180:	f3ef 8505 	mrs	r5, IPSR
    4184:	2d00      	cmp	r5, #0
    4186:	d12c      	bne.n	41e2 <z_reschedule+0x6a>
	new_thread = _kernel.ready_q.cache;
    4188:	4b1a      	ldr	r3, [pc, #104]	; (41f4 <z_reschedule+0x7c>)
	if (resched(key.key) && need_swap()) {
    418a:	699a      	ldr	r2, [r3, #24]
    418c:	689b      	ldr	r3, [r3, #8]
    418e:	429a      	cmp	r2, r3
    4190:	d027      	beq.n	41e2 <z_reschedule+0x6a>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4192:	f7ff fd8d 	bl	3cb0 <z_spin_unlock_valid>
    4196:	2800      	cmp	r0, #0
    4198:	d10e      	bne.n	41b8 <z_reschedule+0x40>
    419a:	4d17      	ldr	r5, [pc, #92]	; (41f8 <z_reschedule+0x80>)
    419c:	23e2      	movs	r3, #226	; 0xe2
    419e:	002a      	movs	r2, r5
    41a0:	4916      	ldr	r1, [pc, #88]	; (41fc <z_reschedule+0x84>)
    41a2:	4817      	ldr	r0, [pc, #92]	; (4200 <z_reschedule+0x88>)
    41a4:	f001 fba0 	bl	58e8 <assert_print>
    41a8:	0021      	movs	r1, r4
    41aa:	4816      	ldr	r0, [pc, #88]	; (4204 <z_reschedule+0x8c>)
    41ac:	f001 fb9c 	bl	58e8 <assert_print>
    41b0:	21e2      	movs	r1, #226	; 0xe2
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    41b2:	0028      	movs	r0, r5
    41b4:	f001 fb94 	bl	58e0 <assert_post_action>
	ret = arch_swap(key);
    41b8:	0028      	movs	r0, r5
    41ba:	f7fd f973 	bl	14a4 <arch_swap>
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
		signal_pending_ipi();
	}
}
    41be:	bd70      	pop	{r4, r5, r6, pc}
    41c0:	f7ff fd76 	bl	3cb0 <z_spin_unlock_valid>
    41c4:	2800      	cmp	r0, #0
    41c6:	d1fa      	bne.n	41be <z_reschedule+0x46>
    41c8:	4d0b      	ldr	r5, [pc, #44]	; (41f8 <z_reschedule+0x80>)
    41ca:	23c3      	movs	r3, #195	; 0xc3
    41cc:	002a      	movs	r2, r5
    41ce:	490b      	ldr	r1, [pc, #44]	; (41fc <z_reschedule+0x84>)
    41d0:	480b      	ldr	r0, [pc, #44]	; (4200 <z_reschedule+0x88>)
    41d2:	f001 fb89 	bl	58e8 <assert_print>
    41d6:	0021      	movs	r1, r4
    41d8:	480a      	ldr	r0, [pc, #40]	; (4204 <z_reschedule+0x8c>)
    41da:	f001 fb85 	bl	58e8 <assert_print>
    41de:	21c3      	movs	r1, #195	; 0xc3
    41e0:	e7e7      	b.n	41b2 <z_reschedule+0x3a>
    41e2:	f7ff fd65 	bl	3cb0 <z_spin_unlock_valid>
    41e6:	2800      	cmp	r0, #0
    41e8:	d0ee      	beq.n	41c8 <z_reschedule+0x50>
    41ea:	b662      	cpsie	i
    41ec:	f3bf 8f6f 	isb	sy
    41f0:	e7e5      	b.n	41be <z_reschedule+0x46>
    41f2:	46c0      	nop			; (mov r8, r8)
    41f4:	20000330 	.word	0x20000330
    41f8:	00006305 	.word	0x00006305
    41fc:	0000637c 	.word	0x0000637c
    4200:	00006347 	.word	0x00006347
    4204:	00006393 	.word	0x00006393

00004208 <z_sched_start>:
{
    4208:	b570      	push	{r4, r5, r6, lr}
    420a:	0005      	movs	r5, r0
	__asm__ volatile("mrs %0, PRIMASK;"
    420c:	f3ef 8610 	mrs	r6, PRIMASK
    4210:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    4212:	4c1f      	ldr	r4, [pc, #124]	; (4290 <z_sched_start+0x88>)
    4214:	0020      	movs	r0, r4
    4216:	f7ff fd3b 	bl	3c90 <z_spin_lock_valid>
    421a:	2800      	cmp	r0, #0
    421c:	d10e      	bne.n	423c <z_sched_start+0x34>
    421e:	4d1d      	ldr	r5, [pc, #116]	; (4294 <z_sched_start+0x8c>)
    4220:	2394      	movs	r3, #148	; 0x94
    4222:	002a      	movs	r2, r5
    4224:	491c      	ldr	r1, [pc, #112]	; (4298 <z_sched_start+0x90>)
    4226:	481d      	ldr	r0, [pc, #116]	; (429c <z_sched_start+0x94>)
    4228:	f001 fb5e 	bl	58e8 <assert_print>
    422c:	0021      	movs	r1, r4
    422e:	481c      	ldr	r0, [pc, #112]	; (42a0 <z_sched_start+0x98>)
    4230:	f001 fb5a 	bl	58e8 <assert_print>
    4234:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4236:	0028      	movs	r0, r5
    4238:	f001 fb52 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    423c:	0020      	movs	r0, r4
    423e:	f7ff fd45 	bl	3ccc <z_spin_lock_set_owner>
	if (z_has_thread_started(thread)) {
    4242:	2204      	movs	r2, #4
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    4244:	7b6b      	ldrb	r3, [r5, #13]
    4246:	4213      	tst	r3, r2
    4248:	d117      	bne.n	427a <z_sched_start+0x72>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    424a:	0020      	movs	r0, r4
    424c:	f7ff fd30 	bl	3cb0 <z_spin_unlock_valid>
    4250:	2800      	cmp	r0, #0
    4252:	d10c      	bne.n	426e <z_sched_start+0x66>
    4254:	4d0f      	ldr	r5, [pc, #60]	; (4294 <z_sched_start+0x8c>)
    4256:	23c3      	movs	r3, #195	; 0xc3
    4258:	002a      	movs	r2, r5
    425a:	4912      	ldr	r1, [pc, #72]	; (42a4 <z_sched_start+0x9c>)
    425c:	480f      	ldr	r0, [pc, #60]	; (429c <z_sched_start+0x94>)
    425e:	f001 fb43 	bl	58e8 <assert_print>
    4262:	0021      	movs	r1, r4
    4264:	4810      	ldr	r0, [pc, #64]	; (42a8 <z_sched_start+0xa0>)
    4266:	f001 fb3f 	bl	58e8 <assert_print>
    426a:	21c3      	movs	r1, #195	; 0xc3
    426c:	e7e3      	b.n	4236 <z_sched_start+0x2e>
	if (key != 0U) {
    426e:	2e00      	cmp	r6, #0
    4270:	d102      	bne.n	4278 <z_sched_start+0x70>
	__asm__ volatile(
    4272:	b662      	cpsie	i
    4274:	f3bf 8f6f 	isb	sy
}
    4278:	bd70      	pop	{r4, r5, r6, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    427a:	4393      	bics	r3, r2
	ready_thread(thread);
    427c:	0028      	movs	r0, r5
    427e:	736b      	strb	r3, [r5, #13]
    4280:	f7ff fee8 	bl	4054 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    4284:	0031      	movs	r1, r6
    4286:	0020      	movs	r0, r4
    4288:	f7ff ff76 	bl	4178 <z_reschedule>
    428c:	e7f4      	b.n	4278 <z_sched_start+0x70>
    428e:	46c0      	nop			; (mov r8, r8)
    4290:	20000364 	.word	0x20000364
    4294:	00006305 	.word	0x00006305
    4298:	00006332 	.word	0x00006332
    429c:	00006347 	.word	0x00006347
    42a0:	00006364 	.word	0x00006364
    42a4:	0000637c 	.word	0x0000637c
    42a8:	00006393 	.word	0x00006393

000042ac <k_sched_lock>:
		signal_pending_ipi();
	}
}

void k_sched_lock(void)
{
    42ac:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    42ae:	f3ef 8510 	mrs	r5, PRIMASK
    42b2:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    42b4:	4c29      	ldr	r4, [pc, #164]	; (435c <k_sched_lock+0xb0>)
    42b6:	0020      	movs	r0, r4
    42b8:	f7ff fcea 	bl	3c90 <z_spin_lock_valid>
    42bc:	2800      	cmp	r0, #0
    42be:	d10d      	bne.n	42dc <k_sched_lock+0x30>
    42c0:	4d27      	ldr	r5, [pc, #156]	; (4360 <k_sched_lock+0xb4>)
    42c2:	2394      	movs	r3, #148	; 0x94
    42c4:	002a      	movs	r2, r5
    42c6:	4927      	ldr	r1, [pc, #156]	; (4364 <k_sched_lock+0xb8>)
    42c8:	4827      	ldr	r0, [pc, #156]	; (4368 <k_sched_lock+0xbc>)
    42ca:	f001 fb0d 	bl	58e8 <assert_print>
    42ce:	0021      	movs	r1, r4
    42d0:	4826      	ldr	r0, [pc, #152]	; (436c <k_sched_lock+0xc0>)
    42d2:	f001 fb09 	bl	58e8 <assert_print>
    42d6:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    42d8:	0028      	movs	r0, r5
    42da:	e012      	b.n	4302 <k_sched_lock+0x56>
	z_spin_lock_set_owner(l);
    42dc:	0020      	movs	r0, r4
    42de:	f7ff fcf5 	bl	3ccc <z_spin_lock_set_owner>
    42e2:	f3ef 8305 	mrs	r3, IPSR
	}
}

static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
    42e6:	2b00      	cmp	r3, #0
    42e8:	d00d      	beq.n	4306 <k_sched_lock+0x5a>
    42ea:	4c21      	ldr	r4, [pc, #132]	; (4370 <k_sched_lock+0xc4>)
    42ec:	4921      	ldr	r1, [pc, #132]	; (4374 <k_sched_lock+0xc8>)
    42ee:	23fd      	movs	r3, #253	; 0xfd
    42f0:	0022      	movs	r2, r4
    42f2:	481d      	ldr	r0, [pc, #116]	; (4368 <k_sched_lock+0xbc>)
    42f4:	f001 faf8 	bl	58e8 <assert_print>
    42f8:	481f      	ldr	r0, [pc, #124]	; (4378 <k_sched_lock+0xcc>)
    42fa:	f001 faf5 	bl	58e8 <assert_print>
    42fe:	21fd      	movs	r1, #253	; 0xfd
    4300:	0020      	movs	r0, r4
    4302:	f001 faed 	bl	58e0 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1U, "");
    4306:	4b1d      	ldr	r3, [pc, #116]	; (437c <k_sched_lock+0xd0>)
    4308:	689a      	ldr	r2, [r3, #8]
    430a:	7bd3      	ldrb	r3, [r2, #15]
    430c:	2b01      	cmp	r3, #1
    430e:	d10b      	bne.n	4328 <k_sched_lock+0x7c>
    4310:	4c17      	ldr	r4, [pc, #92]	; (4370 <k_sched_lock+0xc4>)
    4312:	491b      	ldr	r1, [pc, #108]	; (4380 <k_sched_lock+0xd4>)
    4314:	0022      	movs	r2, r4
    4316:	4814      	ldr	r0, [pc, #80]	; (4368 <k_sched_lock+0xbc>)
    4318:	33fd      	adds	r3, #253	; 0xfd
    431a:	f001 fae5 	bl	58e8 <assert_print>
    431e:	4816      	ldr	r0, [pc, #88]	; (4378 <k_sched_lock+0xcc>)
    4320:	f001 fae2 	bl	58e8 <assert_print>
    4324:	21fe      	movs	r1, #254	; 0xfe
    4326:	e7eb      	b.n	4300 <k_sched_lock+0x54>

	--_current->base.sched_locked;
    4328:	3b01      	subs	r3, #1
    432a:	73d3      	strb	r3, [r2, #15]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    432c:	0020      	movs	r0, r4
    432e:	f7ff fcbf 	bl	3cb0 <z_spin_unlock_valid>
    4332:	2800      	cmp	r0, #0
    4334:	d10c      	bne.n	4350 <k_sched_lock+0xa4>
    4336:	4d0a      	ldr	r5, [pc, #40]	; (4360 <k_sched_lock+0xb4>)
    4338:	23c3      	movs	r3, #195	; 0xc3
    433a:	002a      	movs	r2, r5
    433c:	4911      	ldr	r1, [pc, #68]	; (4384 <k_sched_lock+0xd8>)
    433e:	480a      	ldr	r0, [pc, #40]	; (4368 <k_sched_lock+0xbc>)
    4340:	f001 fad2 	bl	58e8 <assert_print>
    4344:	0021      	movs	r1, r4
    4346:	4810      	ldr	r0, [pc, #64]	; (4388 <k_sched_lock+0xdc>)
    4348:	f001 face 	bl	58e8 <assert_print>
    434c:	21c3      	movs	r1, #195	; 0xc3
    434e:	e7c3      	b.n	42d8 <k_sched_lock+0x2c>
	if (key != 0U) {
    4350:	2d00      	cmp	r5, #0
    4352:	d102      	bne.n	435a <k_sched_lock+0xae>
	__asm__ volatile(
    4354:	b662      	cpsie	i
    4356:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
    435a:	bd70      	pop	{r4, r5, r6, pc}
    435c:	20000364 	.word	0x20000364
    4360:	00006305 	.word	0x00006305
    4364:	00006332 	.word	0x00006332
    4368:	00006347 	.word	0x00006347
    436c:	00006364 	.word	0x00006364
    4370:	0000718c 	.word	0x0000718c
    4374:	00006e6b 	.word	0x00006e6b
    4378:	00006f86 	.word	0x00006f86
    437c:	20000330 	.word	0x20000330
    4380:	000071b7 	.word	0x000071b7
    4384:	0000637c 	.word	0x0000637c
    4388:	00006393 	.word	0x00006393

0000438c <k_sched_unlock>:

void k_sched_unlock(void)
{
    438c:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    438e:	f3ef 8510 	mrs	r5, PRIMASK
    4392:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    4394:	4c2c      	ldr	r4, [pc, #176]	; (4448 <k_sched_unlock+0xbc>)
    4396:	0020      	movs	r0, r4
    4398:	f7ff fc7a 	bl	3c90 <z_spin_lock_valid>
    439c:	2800      	cmp	r0, #0
    439e:	d10d      	bne.n	43bc <k_sched_unlock+0x30>
    43a0:	4d2a      	ldr	r5, [pc, #168]	; (444c <k_sched_unlock+0xc0>)
    43a2:	2394      	movs	r3, #148	; 0x94
    43a4:	002a      	movs	r2, r5
    43a6:	492a      	ldr	r1, [pc, #168]	; (4450 <k_sched_unlock+0xc4>)
    43a8:	482a      	ldr	r0, [pc, #168]	; (4454 <k_sched_unlock+0xc8>)
    43aa:	f001 fa9d 	bl	58e8 <assert_print>
    43ae:	0021      	movs	r1, r4
    43b0:	4829      	ldr	r0, [pc, #164]	; (4458 <k_sched_unlock+0xcc>)
    43b2:	f001 fa99 	bl	58e8 <assert_print>
    43b6:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    43b8:	0028      	movs	r0, r5
    43ba:	e013      	b.n	43e4 <k_sched_unlock+0x58>
	z_spin_lock_set_owner(l);
    43bc:	0020      	movs	r0, r4
    43be:	f7ff fc85 	bl	3ccc <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		__ASSERT(_current->base.sched_locked != 0U, "");
    43c2:	4b26      	ldr	r3, [pc, #152]	; (445c <k_sched_unlock+0xd0>)
    43c4:	689a      	ldr	r2, [r3, #8]
    43c6:	7bd3      	ldrb	r3, [r2, #15]
    43c8:	2b00      	cmp	r3, #0
    43ca:	d10d      	bne.n	43e8 <k_sched_unlock+0x5c>
    43cc:	4c24      	ldr	r4, [pc, #144]	; (4460 <k_sched_unlock+0xd4>)
    43ce:	4925      	ldr	r1, [pc, #148]	; (4464 <k_sched_unlock+0xd8>)
    43d0:	0022      	movs	r2, r4
    43d2:	4820      	ldr	r0, [pc, #128]	; (4454 <k_sched_unlock+0xc8>)
    43d4:	4b24      	ldr	r3, [pc, #144]	; (4468 <k_sched_unlock+0xdc>)
    43d6:	f001 fa87 	bl	58e8 <assert_print>
    43da:	4824      	ldr	r0, [pc, #144]	; (446c <k_sched_unlock+0xe0>)
    43dc:	f001 fa84 	bl	58e8 <assert_print>
    43e0:	4921      	ldr	r1, [pc, #132]	; (4468 <k_sched_unlock+0xdc>)
    43e2:	0020      	movs	r0, r4
    43e4:	f001 fa7c 	bl	58e0 <assert_post_action>
    43e8:	f3ef 8005 	mrs	r0, IPSR
		__ASSERT(!arch_is_in_isr(), "");
    43ec:	2800      	cmp	r0, #0
    43ee:	d00d      	beq.n	440c <k_sched_unlock+0x80>
    43f0:	23fb      	movs	r3, #251	; 0xfb
    43f2:	4c1b      	ldr	r4, [pc, #108]	; (4460 <k_sched_unlock+0xd4>)
    43f4:	491e      	ldr	r1, [pc, #120]	; (4470 <k_sched_unlock+0xe4>)
    43f6:	0022      	movs	r2, r4
    43f8:	4816      	ldr	r0, [pc, #88]	; (4454 <k_sched_unlock+0xc8>)
    43fa:	009b      	lsls	r3, r3, #2
    43fc:	f001 fa74 	bl	58e8 <assert_print>
    4400:	481a      	ldr	r0, [pc, #104]	; (446c <k_sched_unlock+0xe0>)
    4402:	f001 fa71 	bl	58e8 <assert_print>
    4406:	21fb      	movs	r1, #251	; 0xfb
    4408:	0089      	lsls	r1, r1, #2
    440a:	e7ea      	b.n	43e2 <k_sched_unlock+0x56>

		++_current->base.sched_locked;
    440c:	3301      	adds	r3, #1
    440e:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    4410:	f7ff fde6 	bl	3fe0 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4414:	0020      	movs	r0, r4
    4416:	f7ff fc4b 	bl	3cb0 <z_spin_unlock_valid>
    441a:	2800      	cmp	r0, #0
    441c:	d10c      	bne.n	4438 <k_sched_unlock+0xac>
    441e:	4d0b      	ldr	r5, [pc, #44]	; (444c <k_sched_unlock+0xc0>)
    4420:	23c3      	movs	r3, #195	; 0xc3
    4422:	002a      	movs	r2, r5
    4424:	4913      	ldr	r1, [pc, #76]	; (4474 <k_sched_unlock+0xe8>)
    4426:	480b      	ldr	r0, [pc, #44]	; (4454 <k_sched_unlock+0xc8>)
    4428:	f001 fa5e 	bl	58e8 <assert_print>
    442c:	0021      	movs	r1, r4
    442e:	4812      	ldr	r0, [pc, #72]	; (4478 <k_sched_unlock+0xec>)
    4430:	f001 fa5a 	bl	58e8 <assert_print>
    4434:	21c3      	movs	r1, #195	; 0xc3
    4436:	e7bf      	b.n	43b8 <k_sched_unlock+0x2c>
	if (key != 0U) {
    4438:	2d00      	cmp	r5, #0
    443a:	d102      	bne.n	4442 <k_sched_unlock+0xb6>
	__asm__ volatile(
    443c:	b662      	cpsie	i
    443e:	f3bf 8f6f 	isb	sy
	LOG_DBG("scheduler unlocked (%p:%d)",
		_current, _current->base.sched_locked);

	SYS_PORT_TRACING_FUNC(k_thread, sched_unlock);

	z_reschedule_unlocked();
    4442:	f001 fc50 	bl	5ce6 <z_reschedule_unlocked>
}
    4446:	bd70      	pop	{r4, r5, r6, pc}
    4448:	20000364 	.word	0x20000364
    444c:	00006305 	.word	0x00006305
    4450:	00006332 	.word	0x00006332
    4454:	00006347 	.word	0x00006347
    4458:	00006364 	.word	0x00006364
    445c:	20000330 	.word	0x20000330
    4460:	00006f89 	.word	0x00006f89
    4464:	000071e8 	.word	0x000071e8
    4468:	000003eb 	.word	0x000003eb
    446c:	00006f86 	.word	0x00006f86
    4470:	00006e6b 	.word	0x00006e6b
    4474:	0000637c 	.word	0x0000637c
    4478:	00006393 	.word	0x00006393

0000447c <z_priq_dumb_remove>:
}
#endif

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    447c:	4b0b      	ldr	r3, [pc, #44]	; (44ac <z_priq_dumb_remove+0x30>)
{
    447e:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    4480:	4299      	cmp	r1, r3
    4482:	d10a      	bne.n	449a <z_priq_dumb_remove+0x1e>
    4484:	4c0a      	ldr	r4, [pc, #40]	; (44b0 <z_priq_dumb_remove+0x34>)
    4486:	490b      	ldr	r1, [pc, #44]	; (44b4 <z_priq_dumb_remove+0x38>)
    4488:	480b      	ldr	r0, [pc, #44]	; (44b8 <z_priq_dumb_remove+0x3c>)
    448a:	0022      	movs	r2, r4
    448c:	4b0b      	ldr	r3, [pc, #44]	; (44bc <z_priq_dumb_remove+0x40>)
    448e:	f001 fa2b 	bl	58e8 <assert_print>
    4492:	0020      	movs	r0, r4
    4494:	4909      	ldr	r1, [pc, #36]	; (44bc <z_priq_dumb_remove+0x40>)
    4496:	f001 fa23 	bl	58e0 <assert_post_action>
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
	sys_dnode_t *const next = node->next;
    449a:	680b      	ldr	r3, [r1, #0]
	sys_dnode_t *const prev = node->prev;
    449c:	684a      	ldr	r2, [r1, #4]

	prev->next = next;
    449e:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    44a0:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    44a2:	2300      	movs	r3, #0
    44a4:	600b      	str	r3, [r1, #0]
	node->prev = NULL;
    44a6:	604b      	str	r3, [r1, #4]

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    44a8:	bd10      	pop	{r4, pc}
    44aa:	46c0      	nop			; (mov r8, r8)
    44ac:	20000120 	.word	0x20000120
    44b0:	00006f89 	.word	0x00006f89
    44b4:	0000716b 	.word	0x0000716b
    44b8:	00006347 	.word	0x00006347
    44bc:	0000047b 	.word	0x0000047b

000044c0 <move_thread_to_end_of_prio_q>:
	if (z_is_thread_queued(thread)) {
    44c0:	220d      	movs	r2, #13
{
    44c2:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
    44c4:	5682      	ldrsb	r2, [r0, r2]
{
    44c6:	0004      	movs	r4, r0
	return (thread->base.thread_state & state) != 0U;
    44c8:	7b43      	ldrb	r3, [r0, #13]
    44ca:	4d21      	ldr	r5, [pc, #132]	; (4550 <move_thread_to_end_of_prio_q+0x90>)
	if (z_is_thread_queued(thread)) {
    44cc:	2a00      	cmp	r2, #0
    44ce:	da06      	bge.n	44de <move_thread_to_end_of_prio_q+0x1e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    44d0:	227f      	movs	r2, #127	; 0x7f
    44d2:	4013      	ands	r3, r2
	_priq_run_remove(thread_runq(thread), thread);
    44d4:	0001      	movs	r1, r0
	thread->base.thread_state &= ~_THREAD_QUEUED;
    44d6:	7343      	strb	r3, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
    44d8:	0028      	movs	r0, r5
    44da:	f7ff ffcf 	bl	447c <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    44de:	2380      	movs	r3, #128	; 0x80
    44e0:	7b62      	ldrb	r2, [r4, #13]
    44e2:	425b      	negs	r3, r3
    44e4:	4313      	orrs	r3, r2
    44e6:	7363      	strb	r3, [r4, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    44e8:	4b1a      	ldr	r3, [pc, #104]	; (4554 <move_thread_to_end_of_prio_q+0x94>)
    44ea:	429c      	cmp	r4, r3
    44ec:	d10a      	bne.n	4504 <move_thread_to_end_of_prio_q+0x44>
    44ee:	4c1a      	ldr	r4, [pc, #104]	; (4558 <move_thread_to_end_of_prio_q+0x98>)
    44f0:	491a      	ldr	r1, [pc, #104]	; (455c <move_thread_to_end_of_prio_q+0x9c>)
    44f2:	481b      	ldr	r0, [pc, #108]	; (4560 <move_thread_to_end_of_prio_q+0xa0>)
    44f4:	23bc      	movs	r3, #188	; 0xbc
    44f6:	0022      	movs	r2, r4
    44f8:	f001 f9f6 	bl	58e8 <assert_print>
    44fc:	21bc      	movs	r1, #188	; 0xbc
    44fe:	0020      	movs	r0, r4
    4500:	f001 f9ee 	bl	58e0 <assert_post_action>
	return list->head == list;
    4504:	4a17      	ldr	r2, [pc, #92]	; (4564 <move_thread_to_end_of_prio_q+0xa4>)
    4506:	69d3      	ldr	r3, [r2, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4508:	42ab      	cmp	r3, r5
    450a:	d100      	bne.n	450e <move_thread_to_end_of_prio_q+0x4e>
    450c:	2300      	movs	r3, #0
	return (node == list->tail) ? NULL : node->next;
    450e:	6a11      	ldr	r1, [r2, #32]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4510:	2b00      	cmp	r3, #0
    4512:	d104      	bne.n	451e <move_thread_to_end_of_prio_q+0x5e>
	node->next = list;
    4514:	6025      	str	r5, [r4, #0]
	node->prev = tail;
    4516:	6061      	str	r1, [r4, #4]
	tail->next = node;
    4518:	600c      	str	r4, [r1, #0]
	list->tail = node;
    451a:	6214      	str	r4, [r2, #32]
}
    451c:	e00c      	b.n	4538 <move_thread_to_end_of_prio_q+0x78>
	int32_t b1 = thread_1->base.prio;
    451e:	200e      	movs	r0, #14
	int32_t b2 = thread_2->base.prio;
    4520:	260e      	movs	r6, #14
	int32_t b1 = thread_1->base.prio;
    4522:	5620      	ldrsb	r0, [r4, r0]
	int32_t b2 = thread_2->base.prio;
    4524:	579e      	ldrsb	r6, [r3, r6]
	if (b1 != b2) {
    4526:	42b0      	cmp	r0, r6
    4528:	d00d      	beq.n	4546 <move_thread_to_end_of_prio_q+0x86>
		if (z_sched_prio_cmp(thread, t) > 0) {
    452a:	4286      	cmp	r6, r0
    452c:	dd0b      	ble.n	4546 <move_thread_to_end_of_prio_q+0x86>
	sys_dnode_t *const prev = successor->prev;
    452e:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
    4530:	6023      	str	r3, [r4, #0]
	node->prev = prev;
    4532:	6061      	str	r1, [r4, #4]
	prev->next = node;
    4534:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    4536:	605c      	str	r4, [r3, #4]
	update_cache(thread == _current);
    4538:	6890      	ldr	r0, [r2, #8]
    453a:	1b00      	subs	r0, r0, r4
    453c:	4243      	negs	r3, r0
    453e:	4158      	adcs	r0, r3
    4540:	f7ff fd4e 	bl	3fe0 <update_cache>
}
    4544:	bd70      	pop	{r4, r5, r6, pc}
	return (node == list->tail) ? NULL : node->next;
    4546:	4299      	cmp	r1, r3
    4548:	d0e4      	beq.n	4514 <move_thread_to_end_of_prio_q+0x54>
    454a:	681b      	ldr	r3, [r3, #0]
    454c:	e7e0      	b.n	4510 <move_thread_to_end_of_prio_q+0x50>
    454e:	46c0      	nop			; (mov r8, r8)
    4550:	2000034c 	.word	0x2000034c
    4554:	20000120 	.word	0x20000120
    4558:	00006f89 	.word	0x00006f89
    455c:	0000716b 	.word	0x0000716b
    4560:	00006347 	.word	0x00006347
    4564:	20000330 	.word	0x20000330

00004568 <z_time_slice>:
{
    4568:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    456a:	f3ef 8610 	mrs	r6, PRIMASK
    456e:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    4570:	4c25      	ldr	r4, [pc, #148]	; (4608 <z_time_slice+0xa0>)
    4572:	0020      	movs	r0, r4
    4574:	f7ff fb8c 	bl	3c90 <z_spin_lock_valid>
    4578:	2800      	cmp	r0, #0
    457a:	d10e      	bne.n	459a <z_time_slice+0x32>
    457c:	4d23      	ldr	r5, [pc, #140]	; (460c <z_time_slice+0xa4>)
    457e:	2394      	movs	r3, #148	; 0x94
    4580:	002a      	movs	r2, r5
    4582:	4923      	ldr	r1, [pc, #140]	; (4610 <z_time_slice+0xa8>)
    4584:	4823      	ldr	r0, [pc, #140]	; (4614 <z_time_slice+0xac>)
    4586:	f001 f9af 	bl	58e8 <assert_print>
    458a:	0021      	movs	r1, r4
    458c:	4822      	ldr	r0, [pc, #136]	; (4618 <z_time_slice+0xb0>)
    458e:	f001 f9ab 	bl	58e8 <assert_print>
    4592:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4594:	0028      	movs	r0, r5
    4596:	f001 f9a3 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    459a:	0020      	movs	r0, r4
    459c:	f7ff fb96 	bl	3ccc <z_spin_lock_set_owner>
	struct k_thread *curr = _current;
    45a0:	4a1e      	ldr	r2, [pc, #120]	; (461c <z_time_slice+0xb4>)
	if (pending_current == curr) {
    45a2:	4b1f      	ldr	r3, [pc, #124]	; (4620 <z_time_slice+0xb8>)
	struct k_thread *curr = _current;
    45a4:	6895      	ldr	r5, [r2, #8]
	if (pending_current == curr) {
    45a6:	6818      	ldr	r0, [r3, #0]
    45a8:	42a8      	cmp	r0, r5
    45aa:	d113      	bne.n	45d4 <z_time_slice+0x6c>
		z_reset_time_slice(curr);
    45ac:	f7ff fcf2 	bl	3f94 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    45b0:	0020      	movs	r0, r4
    45b2:	f7ff fb7d 	bl	3cb0 <z_spin_unlock_valid>
    45b6:	2800      	cmp	r0, #0
    45b8:	d120      	bne.n	45fc <z_time_slice+0x94>
    45ba:	4d14      	ldr	r5, [pc, #80]	; (460c <z_time_slice+0xa4>)
    45bc:	23c3      	movs	r3, #195	; 0xc3
    45be:	002a      	movs	r2, r5
    45c0:	4918      	ldr	r1, [pc, #96]	; (4624 <z_time_slice+0xbc>)
    45c2:	4814      	ldr	r0, [pc, #80]	; (4614 <z_time_slice+0xac>)
    45c4:	f001 f990 	bl	58e8 <assert_print>
    45c8:	0021      	movs	r1, r4
    45ca:	4817      	ldr	r0, [pc, #92]	; (4628 <z_time_slice+0xc0>)
    45cc:	f001 f98c 	bl	58e8 <assert_print>
    45d0:	21c3      	movs	r1, #195	; 0xc3
    45d2:	e7df      	b.n	4594 <z_time_slice+0x2c>
	pending_current = NULL;
    45d4:	2100      	movs	r1, #0
    45d6:	6019      	str	r1, [r3, #0]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
    45d8:	7c12      	ldrb	r2, [r2, #16]
    45da:	4b14      	ldr	r3, [pc, #80]	; (462c <z_time_slice+0xc4>)
    45dc:	5c9b      	ldrb	r3, [r3, r2]
    45de:	428b      	cmp	r3, r1
    45e0:	d0e6      	beq.n	45b0 <z_time_slice+0x48>
    45e2:	0028      	movs	r0, r5
    45e4:	f7ff fc80 	bl	3ee8 <sliceable>
    45e8:	2800      	cmp	r0, #0
    45ea:	d0e1      	beq.n	45b0 <z_time_slice+0x48>
		if (!z_is_thread_prevented_from_running(curr)) {
    45ec:	7b6b      	ldrb	r3, [r5, #13]
    45ee:	06db      	lsls	r3, r3, #27
    45f0:	d102      	bne.n	45f8 <z_time_slice+0x90>
			move_thread_to_end_of_prio_q(curr);
    45f2:	0028      	movs	r0, r5
    45f4:	f7ff ff64 	bl	44c0 <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
    45f8:	0028      	movs	r0, r5
    45fa:	e7d7      	b.n	45ac <z_time_slice+0x44>
	if (key != 0U) {
    45fc:	2e00      	cmp	r6, #0
    45fe:	d102      	bne.n	4606 <z_time_slice+0x9e>
	__asm__ volatile(
    4600:	b662      	cpsie	i
    4602:	f3bf 8f6f 	isb	sy
}
    4606:	bd70      	pop	{r4, r5, r6, pc}
    4608:	20000364 	.word	0x20000364
    460c:	00006305 	.word	0x00006305
    4610:	00006332 	.word	0x00006332
    4614:	00006347 	.word	0x00006347
    4618:	00006364 	.word	0x00006364
    461c:	20000330 	.word	0x20000330
    4620:	20000358 	.word	0x20000358
    4624:	0000637c 	.word	0x0000637c
    4628:	00006393 	.word	0x00006393
    462c:	20000379 	.word	0x20000379

00004630 <unready_thread>:
	if (z_is_thread_queued(thread)) {
    4630:	220d      	movs	r2, #13
{
    4632:	b510      	push	{r4, lr}
	if (z_is_thread_queued(thread)) {
    4634:	5682      	ldrsb	r2, [r0, r2]
{
    4636:	0004      	movs	r4, r0
    4638:	7b43      	ldrb	r3, [r0, #13]
	if (z_is_thread_queued(thread)) {
    463a:	2a00      	cmp	r2, #0
    463c:	da06      	bge.n	464c <unready_thread+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    463e:	227f      	movs	r2, #127	; 0x7f
    4640:	4013      	ands	r3, r2
    4642:	7343      	strb	r3, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
    4644:	0021      	movs	r1, r4
    4646:	4805      	ldr	r0, [pc, #20]	; (465c <unready_thread+0x2c>)
    4648:	f7ff ff18 	bl	447c <z_priq_dumb_remove>
	update_cache(thread == _current);
    464c:	4b04      	ldr	r3, [pc, #16]	; (4660 <unready_thread+0x30>)
    464e:	6898      	ldr	r0, [r3, #8]
    4650:	1b00      	subs	r0, r0, r4
    4652:	4243      	negs	r3, r0
    4654:	4158      	adcs	r0, r3
    4656:	f7ff fcc3 	bl	3fe0 <update_cache>
}
    465a:	bd10      	pop	{r4, pc}
    465c:	2000034c 	.word	0x2000034c
    4660:	20000330 	.word	0x20000330

00004664 <add_to_waitq_locked>:
{
    4664:	b570      	push	{r4, r5, r6, lr}
    4666:	0004      	movs	r4, r0
    4668:	000d      	movs	r5, r1
	unready_thread(thread);
    466a:	f7ff ffe1 	bl	4630 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    466e:	2302      	movs	r3, #2
    4670:	7b62      	ldrb	r2, [r4, #13]
    4672:	4313      	orrs	r3, r2
    4674:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
    4676:	2d00      	cmp	r5, #0
    4678:	d02a      	beq.n	46d0 <add_to_waitq_locked+0x6c>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    467a:	4b16      	ldr	r3, [pc, #88]	; (46d4 <add_to_waitq_locked+0x70>)
		thread->base.pended_on = wait_q;
    467c:	60a5      	str	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    467e:	429c      	cmp	r4, r3
    4680:	d10a      	bne.n	4698 <add_to_waitq_locked+0x34>
    4682:	4c15      	ldr	r4, [pc, #84]	; (46d8 <add_to_waitq_locked+0x74>)
    4684:	4915      	ldr	r1, [pc, #84]	; (46dc <add_to_waitq_locked+0x78>)
    4686:	4816      	ldr	r0, [pc, #88]	; (46e0 <add_to_waitq_locked+0x7c>)
    4688:	23bc      	movs	r3, #188	; 0xbc
    468a:	0022      	movs	r2, r4
    468c:	f001 f92c 	bl	58e8 <assert_print>
    4690:	21bc      	movs	r1, #188	; 0xbc
    4692:	0020      	movs	r0, r4
    4694:	f001 f924 	bl	58e0 <assert_post_action>
	return list->head == list;
    4698:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    469a:	429d      	cmp	r5, r3
    469c:	d109      	bne.n	46b2 <add_to_waitq_locked+0x4e>
	sys_dnode_t *const tail = list->tail;
    469e:	686b      	ldr	r3, [r5, #4]
	node->next = list;
    46a0:	6025      	str	r5, [r4, #0]
	node->prev = tail;
    46a2:	6063      	str	r3, [r4, #4]
	tail->next = node;
    46a4:	601c      	str	r4, [r3, #0]
	list->tail = node;
    46a6:	606c      	str	r4, [r5, #4]
}
    46a8:	e012      	b.n	46d0 <add_to_waitq_locked+0x6c>
	return (node == list->tail) ? NULL : node->next;
    46aa:	686a      	ldr	r2, [r5, #4]
    46ac:	4293      	cmp	r3, r2
    46ae:	d0f6      	beq.n	469e <add_to_waitq_locked+0x3a>
    46b0:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    46b2:	2b00      	cmp	r3, #0
    46b4:	d0f3      	beq.n	469e <add_to_waitq_locked+0x3a>
	int32_t b1 = thread_1->base.prio;
    46b6:	220e      	movs	r2, #14
	int32_t b2 = thread_2->base.prio;
    46b8:	210e      	movs	r1, #14
	int32_t b1 = thread_1->base.prio;
    46ba:	56a2      	ldrsb	r2, [r4, r2]
	int32_t b2 = thread_2->base.prio;
    46bc:	5659      	ldrsb	r1, [r3, r1]
	if (b1 != b2) {
    46be:	428a      	cmp	r2, r1
    46c0:	d0f3      	beq.n	46aa <add_to_waitq_locked+0x46>
		if (z_sched_prio_cmp(thread, t) > 0) {
    46c2:	4291      	cmp	r1, r2
    46c4:	ddf1      	ble.n	46aa <add_to_waitq_locked+0x46>
	sys_dnode_t *const prev = successor->prev;
    46c6:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    46c8:	6023      	str	r3, [r4, #0]
	node->prev = prev;
    46ca:	6062      	str	r2, [r4, #4]
	prev->next = node;
    46cc:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    46ce:	605c      	str	r4, [r3, #4]
}
    46d0:	bd70      	pop	{r4, r5, r6, pc}
    46d2:	46c0      	nop			; (mov r8, r8)
    46d4:	20000120 	.word	0x20000120
    46d8:	00006f89 	.word	0x00006f89
    46dc:	0000716b 	.word	0x0000716b
    46e0:	00006347 	.word	0x00006347

000046e4 <pend_locked>:
{
    46e4:	b570      	push	{r4, r5, r6, lr}
    46e6:	001d      	movs	r5, r3
    46e8:	0016      	movs	r6, r2
    46ea:	0004      	movs	r4, r0
	add_to_waitq_locked(thread, wait_q);
    46ec:	f7ff ffba 	bl	4664 <add_to_waitq_locked>
	add_thread_timeout(thread, timeout);
    46f0:	002b      	movs	r3, r5
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    46f2:	1c72      	adds	r2, r6, #1
    46f4:	d101      	bne.n	46fa <pend_locked+0x16>
    46f6:	3301      	adds	r3, #1
    46f8:	d006      	beq.n	4708 <pend_locked+0x24>
    46fa:	0020      	movs	r0, r4
    46fc:	0032      	movs	r2, r6
    46fe:	002b      	movs	r3, r5
    4700:	4902      	ldr	r1, [pc, #8]	; (470c <pend_locked+0x28>)
    4702:	3018      	adds	r0, #24
    4704:	f000 fd18 	bl	5138 <z_add_timeout>
}
    4708:	bd70      	pop	{r4, r5, r6, pc}
    470a:	46c0      	nop			; (mov r8, r8)
    470c:	00005cf5 	.word	0x00005cf5

00004710 <z_pend_curr>:
{
    4710:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	pending_current = _current;
    4712:	4f2e      	ldr	r7, [pc, #184]	; (47cc <z_pend_curr+0xbc>)
    4714:	4b2e      	ldr	r3, [pc, #184]	; (47d0 <z_pend_curr+0xc0>)
{
    4716:	9201      	str	r2, [sp, #4]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
    4718:	4c2e      	ldr	r4, [pc, #184]	; (47d4 <z_pend_curr+0xc4>)
	pending_current = _current;
    471a:	68ba      	ldr	r2, [r7, #8]
{
    471c:	0005      	movs	r5, r0
    471e:	000e      	movs	r6, r1
	pending_current = _current;
    4720:	601a      	str	r2, [r3, #0]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
    4722:	42a0      	cmp	r0, r4
    4724:	d109      	bne.n	473a <z_pend_curr+0x2a>
    4726:	4c2c      	ldr	r4, [pc, #176]	; (47d8 <z_pend_curr+0xc8>)
    4728:	492c      	ldr	r1, [pc, #176]	; (47dc <z_pend_curr+0xcc>)
    472a:	0022      	movs	r2, r4
    472c:	482c      	ldr	r0, [pc, #176]	; (47e0 <z_pend_curr+0xd0>)
    472e:	4b2d      	ldr	r3, [pc, #180]	; (47e4 <z_pend_curr+0xd4>)
    4730:	f001 f8da 	bl	58e8 <assert_print>
    4734:	492b      	ldr	r1, [pc, #172]	; (47e4 <z_pend_curr+0xd4>)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4736:	0020      	movs	r0, r4
    4738:	e014      	b.n	4764 <z_pend_curr+0x54>
	__asm__ volatile("mrs %0, PRIMASK;"
    473a:	f3ef 8310 	mrs	r3, PRIMASK
    473e:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    4740:	0020      	movs	r0, r4
    4742:	f7ff faa5 	bl	3c90 <z_spin_lock_valid>
    4746:	2800      	cmp	r0, #0
    4748:	d10e      	bne.n	4768 <z_pend_curr+0x58>
    474a:	4d27      	ldr	r5, [pc, #156]	; (47e8 <z_pend_curr+0xd8>)
    474c:	2394      	movs	r3, #148	; 0x94
    474e:	002a      	movs	r2, r5
    4750:	4926      	ldr	r1, [pc, #152]	; (47ec <z_pend_curr+0xdc>)
    4752:	4823      	ldr	r0, [pc, #140]	; (47e0 <z_pend_curr+0xd0>)
    4754:	f001 f8c8 	bl	58e8 <assert_print>
    4758:	0021      	movs	r1, r4
    475a:	4825      	ldr	r0, [pc, #148]	; (47f0 <z_pend_curr+0xe0>)
    475c:	f001 f8c4 	bl	58e8 <assert_print>
    4760:	2194      	movs	r1, #148	; 0x94
    4762:	0028      	movs	r0, r5
    4764:	f001 f8bc 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    4768:	0020      	movs	r0, r4
    476a:	f7ff faaf 	bl	3ccc <z_spin_lock_set_owner>
	pend_locked(_current, wait_q, timeout);
    476e:	9a08      	ldr	r2, [sp, #32]
    4770:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4772:	68b8      	ldr	r0, [r7, #8]
    4774:	9901      	ldr	r1, [sp, #4]
    4776:	f7ff ffb5 	bl	46e4 <pend_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    477a:	0028      	movs	r0, r5
    477c:	f7ff fa98 	bl	3cb0 <z_spin_unlock_valid>
    4780:	2800      	cmp	r0, #0
    4782:	d10c      	bne.n	479e <z_pend_curr+0x8e>
    4784:	4c18      	ldr	r4, [pc, #96]	; (47e8 <z_pend_curr+0xd8>)
    4786:	23e2      	movs	r3, #226	; 0xe2
    4788:	0022      	movs	r2, r4
    478a:	491a      	ldr	r1, [pc, #104]	; (47f4 <z_pend_curr+0xe4>)
    478c:	4814      	ldr	r0, [pc, #80]	; (47e0 <z_pend_curr+0xd0>)
    478e:	f001 f8ab 	bl	58e8 <assert_print>
    4792:	0029      	movs	r1, r5
    4794:	4818      	ldr	r0, [pc, #96]	; (47f8 <z_pend_curr+0xe8>)
    4796:	f001 f8a7 	bl	58e8 <assert_print>
    479a:	21e2      	movs	r1, #226	; 0xe2
    479c:	e7cb      	b.n	4736 <z_pend_curr+0x26>
    479e:	0020      	movs	r0, r4
    47a0:	f7ff fa86 	bl	3cb0 <z_spin_unlock_valid>
    47a4:	2800      	cmp	r0, #0
    47a6:	d10c      	bne.n	47c2 <z_pend_curr+0xb2>
    47a8:	4d0f      	ldr	r5, [pc, #60]	; (47e8 <z_pend_curr+0xd8>)
    47aa:	23e2      	movs	r3, #226	; 0xe2
    47ac:	002a      	movs	r2, r5
    47ae:	4911      	ldr	r1, [pc, #68]	; (47f4 <z_pend_curr+0xe4>)
    47b0:	480b      	ldr	r0, [pc, #44]	; (47e0 <z_pend_curr+0xd0>)
    47b2:	f001 f899 	bl	58e8 <assert_print>
    47b6:	0021      	movs	r1, r4
    47b8:	480f      	ldr	r0, [pc, #60]	; (47f8 <z_pend_curr+0xe8>)
    47ba:	f001 f895 	bl	58e8 <assert_print>
    47be:	21e2      	movs	r1, #226	; 0xe2
    47c0:	e7cf      	b.n	4762 <z_pend_curr+0x52>
    47c2:	0030      	movs	r0, r6
    47c4:	f7fc fe6e 	bl	14a4 <arch_swap>
}
    47c8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    47ca:	46c0      	nop			; (mov r8, r8)
    47cc:	20000330 	.word	0x20000330
    47d0:	20000358 	.word	0x20000358
    47d4:	20000364 	.word	0x20000364
    47d8:	00006f89 	.word	0x00006f89
    47dc:	00007219 	.word	0x00007219
    47e0:	00006347 	.word	0x00006347
    47e4:	00000352 	.word	0x00000352
    47e8:	00006305 	.word	0x00006305
    47ec:	00006332 	.word	0x00006332
    47f0:	00006364 	.word	0x00006364
    47f4:	0000637c 	.word	0x0000637c
    47f8:	00006393 	.word	0x00006393

000047fc <z_impl_k_thread_suspend>:
{
    47fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    47fe:	0004      	movs	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    4800:	3018      	adds	r0, #24
    4802:	f000 fd57 	bl	52b4 <z_abort_timeout>
    4806:	f3ef 8710 	mrs	r7, PRIMASK
    480a:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    480c:	4d25      	ldr	r5, [pc, #148]	; (48a4 <z_impl_k_thread_suspend+0xa8>)
    480e:	0028      	movs	r0, r5
    4810:	f7ff fa3e 	bl	3c90 <z_spin_lock_valid>
    4814:	2800      	cmp	r0, #0
    4816:	d10e      	bne.n	4836 <z_impl_k_thread_suspend+0x3a>
    4818:	4c23      	ldr	r4, [pc, #140]	; (48a8 <z_impl_k_thread_suspend+0xac>)
    481a:	2394      	movs	r3, #148	; 0x94
    481c:	0022      	movs	r2, r4
    481e:	4923      	ldr	r1, [pc, #140]	; (48ac <z_impl_k_thread_suspend+0xb0>)
    4820:	4823      	ldr	r0, [pc, #140]	; (48b0 <z_impl_k_thread_suspend+0xb4>)
    4822:	f001 f861 	bl	58e8 <assert_print>
    4826:	0029      	movs	r1, r5
    4828:	4822      	ldr	r0, [pc, #136]	; (48b4 <z_impl_k_thread_suspend+0xb8>)
    482a:	f001 f85d 	bl	58e8 <assert_print>
    482e:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4830:	0020      	movs	r0, r4
    4832:	f001 f855 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    4836:	0028      	movs	r0, r5
    4838:	f7ff fa48 	bl	3ccc <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
    483c:	220d      	movs	r2, #13
    483e:	56a2      	ldrsb	r2, [r4, r2]
	return (thread->base.thread_state & state) != 0U;
    4840:	7b63      	ldrb	r3, [r4, #13]
    4842:	2a00      	cmp	r2, #0
    4844:	da06      	bge.n	4854 <z_impl_k_thread_suspend+0x58>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4846:	227f      	movs	r2, #127	; 0x7f
    4848:	4013      	ands	r3, r2
	_priq_run_remove(thread_runq(thread), thread);
    484a:	0021      	movs	r1, r4
    484c:	481a      	ldr	r0, [pc, #104]	; (48b8 <z_impl_k_thread_suspend+0xbc>)
	thread->base.thread_state &= ~_THREAD_QUEUED;
    484e:	7363      	strb	r3, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
    4850:	f7ff fe14 	bl	447c <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
    4854:	2310      	movs	r3, #16
		update_cache(thread == _current);
    4856:	4e19      	ldr	r6, [pc, #100]	; (48bc <z_impl_k_thread_suspend+0xc0>)
    4858:	7b62      	ldrb	r2, [r4, #13]
    485a:	68b0      	ldr	r0, [r6, #8]
    485c:	4313      	orrs	r3, r2
    485e:	1b00      	subs	r0, r0, r4
    4860:	7363      	strb	r3, [r4, #13]
    4862:	4243      	negs	r3, r0
    4864:	4158      	adcs	r0, r3
    4866:	f7ff fbbb 	bl	3fe0 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    486a:	0028      	movs	r0, r5
    486c:	f7ff fa20 	bl	3cb0 <z_spin_unlock_valid>
    4870:	2800      	cmp	r0, #0
    4872:	d10c      	bne.n	488e <z_impl_k_thread_suspend+0x92>
    4874:	4c0c      	ldr	r4, [pc, #48]	; (48a8 <z_impl_k_thread_suspend+0xac>)
    4876:	23c3      	movs	r3, #195	; 0xc3
    4878:	0022      	movs	r2, r4
    487a:	4911      	ldr	r1, [pc, #68]	; (48c0 <z_impl_k_thread_suspend+0xc4>)
    487c:	480c      	ldr	r0, [pc, #48]	; (48b0 <z_impl_k_thread_suspend+0xb4>)
    487e:	f001 f833 	bl	58e8 <assert_print>
    4882:	0029      	movs	r1, r5
    4884:	480f      	ldr	r0, [pc, #60]	; (48c4 <z_impl_k_thread_suspend+0xc8>)
    4886:	f001 f82f 	bl	58e8 <assert_print>
    488a:	21c3      	movs	r1, #195	; 0xc3
    488c:	e7d0      	b.n	4830 <z_impl_k_thread_suspend+0x34>
	if (key != 0U) {
    488e:	2f00      	cmp	r7, #0
    4890:	d102      	bne.n	4898 <z_impl_k_thread_suspend+0x9c>
	__asm__ volatile(
    4892:	b662      	cpsie	i
    4894:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
    4898:	68b3      	ldr	r3, [r6, #8]
    489a:	42a3      	cmp	r3, r4
    489c:	d101      	bne.n	48a2 <z_impl_k_thread_suspend+0xa6>
		z_reschedule_unlocked();
    489e:	f001 fa22 	bl	5ce6 <z_reschedule_unlocked>
}
    48a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    48a4:	20000364 	.word	0x20000364
    48a8:	00006305 	.word	0x00006305
    48ac:	00006332 	.word	0x00006332
    48b0:	00006347 	.word	0x00006347
    48b4:	00006364 	.word	0x00006364
    48b8:	2000034c 	.word	0x2000034c
    48bc:	20000330 	.word	0x20000330
    48c0:	0000637c 	.word	0x0000637c
    48c4:	00006393 	.word	0x00006393

000048c8 <unpend_thread_no_timeout>:
{
    48c8:	b510      	push	{r4, lr}
    48ca:	0004      	movs	r4, r0
    48cc:	6880      	ldr	r0, [r0, #8]
	__ASSERT_NO_MSG(thread->base.pended_on);
    48ce:	2800      	cmp	r0, #0
    48d0:	d10a      	bne.n	48e8 <unpend_thread_no_timeout+0x20>
    48d2:	4c0a      	ldr	r4, [pc, #40]	; (48fc <unpend_thread_no_timeout+0x34>)
    48d4:	490a      	ldr	r1, [pc, #40]	; (4900 <unpend_thread_no_timeout+0x38>)
    48d6:	480b      	ldr	r0, [pc, #44]	; (4904 <unpend_thread_no_timeout+0x3c>)
    48d8:	0022      	movs	r2, r4
    48da:	4b0b      	ldr	r3, [pc, #44]	; (4908 <unpend_thread_no_timeout+0x40>)
    48dc:	f001 f804 	bl	58e8 <assert_print>
    48e0:	0020      	movs	r0, r4
    48e2:	4909      	ldr	r1, [pc, #36]	; (4908 <unpend_thread_no_timeout+0x40>)
    48e4:	f000 fffc 	bl	58e0 <assert_post_action>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    48e8:	0021      	movs	r1, r4
    48ea:	f7ff fdc7 	bl	447c <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    48ee:	2202      	movs	r2, #2
    48f0:	7b63      	ldrb	r3, [r4, #13]
    48f2:	4393      	bics	r3, r2
    48f4:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    48f6:	2300      	movs	r3, #0
    48f8:	60a3      	str	r3, [r4, #8]
}
    48fa:	bd10      	pop	{r4, pc}
    48fc:	00006f89 	.word	0x00006f89
    4900:	00007250 	.word	0x00007250
    4904:	00006347 	.word	0x00006347
    4908:	000002c5 	.word	0x000002c5

0000490c <z_sched_wake_thread>:
{
    490c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    490e:	0004      	movs	r4, r0
    4910:	000f      	movs	r7, r1
	__asm__ volatile("mrs %0, PRIMASK;"
    4912:	f3ef 8610 	mrs	r6, PRIMASK
    4916:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    4918:	4d21      	ldr	r5, [pc, #132]	; (49a0 <z_sched_wake_thread+0x94>)
    491a:	0028      	movs	r0, r5
    491c:	f7ff f9b8 	bl	3c90 <z_spin_lock_valid>
    4920:	2800      	cmp	r0, #0
    4922:	d10e      	bne.n	4942 <z_sched_wake_thread+0x36>
    4924:	4c1f      	ldr	r4, [pc, #124]	; (49a4 <z_sched_wake_thread+0x98>)
    4926:	2394      	movs	r3, #148	; 0x94
    4928:	0022      	movs	r2, r4
    492a:	491f      	ldr	r1, [pc, #124]	; (49a8 <z_sched_wake_thread+0x9c>)
    492c:	481f      	ldr	r0, [pc, #124]	; (49ac <z_sched_wake_thread+0xa0>)
    492e:	f000 ffdb 	bl	58e8 <assert_print>
    4932:	0029      	movs	r1, r5
    4934:	481e      	ldr	r0, [pc, #120]	; (49b0 <z_sched_wake_thread+0xa4>)
    4936:	f000 ffd7 	bl	58e8 <assert_print>
    493a:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    493c:	0020      	movs	r0, r4
    493e:	f000 ffcf 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    4942:	0028      	movs	r0, r5
    4944:	f7ff f9c2 	bl	3ccc <z_spin_lock_set_owner>
		if (!killed) {
    4948:	2328      	movs	r3, #40	; 0x28
    494a:	7b62      	ldrb	r2, [r4, #13]
    494c:	421a      	tst	r2, r3
    494e:	d10f      	bne.n	4970 <z_sched_wake_thread+0x64>
			if (thread->base.pended_on != NULL) {
    4950:	68a3      	ldr	r3, [r4, #8]
    4952:	2b00      	cmp	r3, #0
    4954:	d002      	beq.n	495c <z_sched_wake_thread+0x50>
				unpend_thread_no_timeout(thread);
    4956:	0020      	movs	r0, r4
    4958:	f7ff ffb6 	bl	48c8 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    495c:	2204      	movs	r2, #4
    495e:	7b63      	ldrb	r3, [r4, #13]
			if (is_timeout) {
    4960:	2f00      	cmp	r7, #0
    4962:	d000      	beq.n	4966 <z_sched_wake_thread+0x5a>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    4964:	2214      	movs	r2, #20
    4966:	4393      	bics	r3, r2
			ready_thread(thread);
    4968:	0020      	movs	r0, r4
	thread->base.thread_state &= ~_THREAD_PRESTART;
    496a:	7363      	strb	r3, [r4, #13]
    496c:	f7ff fb72 	bl	4054 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4970:	0028      	movs	r0, r5
    4972:	f7ff f99d 	bl	3cb0 <z_spin_unlock_valid>
    4976:	2800      	cmp	r0, #0
    4978:	d10c      	bne.n	4994 <z_sched_wake_thread+0x88>
    497a:	4c0a      	ldr	r4, [pc, #40]	; (49a4 <z_sched_wake_thread+0x98>)
    497c:	23c3      	movs	r3, #195	; 0xc3
    497e:	0022      	movs	r2, r4
    4980:	490c      	ldr	r1, [pc, #48]	; (49b4 <z_sched_wake_thread+0xa8>)
    4982:	480a      	ldr	r0, [pc, #40]	; (49ac <z_sched_wake_thread+0xa0>)
    4984:	f000 ffb0 	bl	58e8 <assert_print>
    4988:	0029      	movs	r1, r5
    498a:	480b      	ldr	r0, [pc, #44]	; (49b8 <z_sched_wake_thread+0xac>)
    498c:	f000 ffac 	bl	58e8 <assert_print>
    4990:	21c3      	movs	r1, #195	; 0xc3
    4992:	e7d3      	b.n	493c <z_sched_wake_thread+0x30>
	if (key != 0U) {
    4994:	2e00      	cmp	r6, #0
    4996:	d102      	bne.n	499e <z_sched_wake_thread+0x92>
	__asm__ volatile(
    4998:	b662      	cpsie	i
    499a:	f3bf 8f6f 	isb	sy
}
    499e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    49a0:	20000364 	.word	0x20000364
    49a4:	00006305 	.word	0x00006305
    49a8:	00006332 	.word	0x00006332
    49ac:	00006347 	.word	0x00006347
    49b0:	00006364 	.word	0x00006364
    49b4:	0000637c 	.word	0x0000637c
    49b8:	00006393 	.word	0x00006393

000049bc <z_unpend_first_thread>:
{
    49bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    49be:	0006      	movs	r6, r0
	__asm__ volatile("mrs %0, PRIMASK;"
    49c0:	f3ef 8710 	mrs	r7, PRIMASK
    49c4:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    49c6:	4d1f      	ldr	r5, [pc, #124]	; (4a44 <z_unpend_first_thread+0x88>)
    49c8:	0028      	movs	r0, r5
    49ca:	f7ff f961 	bl	3c90 <z_spin_lock_valid>
    49ce:	2800      	cmp	r0, #0
    49d0:	d10e      	bne.n	49f0 <z_unpend_first_thread+0x34>
    49d2:	4c1d      	ldr	r4, [pc, #116]	; (4a48 <z_unpend_first_thread+0x8c>)
    49d4:	2394      	movs	r3, #148	; 0x94
    49d6:	0022      	movs	r2, r4
    49d8:	491c      	ldr	r1, [pc, #112]	; (4a4c <z_unpend_first_thread+0x90>)
    49da:	481d      	ldr	r0, [pc, #116]	; (4a50 <z_unpend_first_thread+0x94>)
    49dc:	f000 ff84 	bl	58e8 <assert_print>
    49e0:	0029      	movs	r1, r5
    49e2:	481c      	ldr	r0, [pc, #112]	; (4a54 <z_unpend_first_thread+0x98>)
    49e4:	f000 ff80 	bl	58e8 <assert_print>
    49e8:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    49ea:	0020      	movs	r0, r4
    49ec:	f000 ff78 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    49f0:	0028      	movs	r0, r5
    49f2:	f7ff f96b 	bl	3ccc <z_spin_lock_set_owner>
	return list->head == list;
    49f6:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    49f8:	42a6      	cmp	r6, r4
    49fa:	d01a      	beq.n	4a32 <z_unpend_first_thread+0x76>
		if (thread != NULL) {
    49fc:	2c00      	cmp	r4, #0
    49fe:	d006      	beq.n	4a0e <z_unpend_first_thread+0x52>
			unpend_thread_no_timeout(thread);
    4a00:	0020      	movs	r0, r4
    4a02:	f7ff ff61 	bl	48c8 <unpend_thread_no_timeout>
    4a06:	0020      	movs	r0, r4
    4a08:	3018      	adds	r0, #24
    4a0a:	f000 fc53 	bl	52b4 <z_abort_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4a0e:	0028      	movs	r0, r5
    4a10:	f7ff f94e 	bl	3cb0 <z_spin_unlock_valid>
    4a14:	2800      	cmp	r0, #0
    4a16:	d10e      	bne.n	4a36 <z_unpend_first_thread+0x7a>
    4a18:	4c0b      	ldr	r4, [pc, #44]	; (4a48 <z_unpend_first_thread+0x8c>)
    4a1a:	23c3      	movs	r3, #195	; 0xc3
    4a1c:	0022      	movs	r2, r4
    4a1e:	490e      	ldr	r1, [pc, #56]	; (4a58 <z_unpend_first_thread+0x9c>)
    4a20:	480b      	ldr	r0, [pc, #44]	; (4a50 <z_unpend_first_thread+0x94>)
    4a22:	f000 ff61 	bl	58e8 <assert_print>
    4a26:	0029      	movs	r1, r5
    4a28:	480c      	ldr	r0, [pc, #48]	; (4a5c <z_unpend_first_thread+0xa0>)
    4a2a:	f000 ff5d 	bl	58e8 <assert_print>
    4a2e:	21c3      	movs	r1, #195	; 0xc3
    4a30:	e7db      	b.n	49ea <z_unpend_first_thread+0x2e>
    4a32:	2400      	movs	r4, #0
    4a34:	e7eb      	b.n	4a0e <z_unpend_first_thread+0x52>
	if (key != 0U) {
    4a36:	2f00      	cmp	r7, #0
    4a38:	d102      	bne.n	4a40 <z_unpend_first_thread+0x84>
	__asm__ volatile(
    4a3a:	b662      	cpsie	i
    4a3c:	f3bf 8f6f 	isb	sy
}
    4a40:	0020      	movs	r0, r4
    4a42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4a44:	20000364 	.word	0x20000364
    4a48:	00006305 	.word	0x00006305
    4a4c:	00006332 	.word	0x00006332
    4a50:	00006347 	.word	0x00006347
    4a54:	00006364 	.word	0x00006364
    4a58:	0000637c 	.word	0x0000637c
    4a5c:	00006393 	.word	0x00006393

00004a60 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    4a60:	4b02      	ldr	r3, [pc, #8]	; (4a6c <z_sched_init+0xc>)
    4a62:	4a03      	ldr	r2, [pc, #12]	; (4a70 <z_sched_init+0x10>)
    4a64:	61da      	str	r2, [r3, #28]
	list->tail = (sys_dnode_t *)list;
    4a66:	621a      	str	r2, [r3, #32]
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
#endif
}
    4a68:	4770      	bx	lr
    4a6a:	46c0      	nop			; (mov r8, r8)
    4a6c:	20000330 	.word	0x20000330
    4a70:	2000034c 	.word	0x2000034c

00004a74 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
    4a74:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    4a76:	f3ef 8705 	mrs	r7, IPSR
	__ASSERT(!arch_is_in_isr(), "");
    4a7a:	2f00      	cmp	r7, #0
    4a7c:	d00c      	beq.n	4a98 <z_impl_k_yield+0x24>
    4a7e:	4c3d      	ldr	r4, [pc, #244]	; (4b74 <z_impl_k_yield+0x100>)
    4a80:	493d      	ldr	r1, [pc, #244]	; (4b78 <z_impl_k_yield+0x104>)
    4a82:	0022      	movs	r2, r4
    4a84:	483d      	ldr	r0, [pc, #244]	; (4b7c <z_impl_k_yield+0x108>)
    4a86:	4b3e      	ldr	r3, [pc, #248]	; (4b80 <z_impl_k_yield+0x10c>)
    4a88:	f000 ff2e 	bl	58e8 <assert_print>
    4a8c:	483d      	ldr	r0, [pc, #244]	; (4b84 <z_impl_k_yield+0x110>)
    4a8e:	f000 ff2b 	bl	58e8 <assert_print>
    4a92:	493b      	ldr	r1, [pc, #236]	; (4b80 <z_impl_k_yield+0x10c>)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    4a94:	0020      	movs	r0, r4
    4a96:	e016      	b.n	4ac6 <z_impl_k_yield+0x52>
	__asm__ volatile("mrs %0, PRIMASK;"
    4a98:	f3ef 8310 	mrs	r3, PRIMASK
    4a9c:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    4a9e:	4c3a      	ldr	r4, [pc, #232]	; (4b88 <z_impl_k_yield+0x114>)
    4aa0:	9301      	str	r3, [sp, #4]
    4aa2:	0020      	movs	r0, r4
    4aa4:	f7ff f8f4 	bl	3c90 <z_spin_lock_valid>
    4aa8:	2800      	cmp	r0, #0
    4aaa:	d10e      	bne.n	4aca <z_impl_k_yield+0x56>
    4aac:	4d37      	ldr	r5, [pc, #220]	; (4b8c <z_impl_k_yield+0x118>)
    4aae:	2394      	movs	r3, #148	; 0x94
    4ab0:	002a      	movs	r2, r5
    4ab2:	4937      	ldr	r1, [pc, #220]	; (4b90 <z_impl_k_yield+0x11c>)
    4ab4:	4831      	ldr	r0, [pc, #196]	; (4b7c <z_impl_k_yield+0x108>)
    4ab6:	f000 ff17 	bl	58e8 <assert_print>
    4aba:	0021      	movs	r1, r4
    4abc:	4835      	ldr	r0, [pc, #212]	; (4b94 <z_impl_k_yield+0x120>)
    4abe:	f000 ff13 	bl	58e8 <assert_print>
    4ac2:	2194      	movs	r1, #148	; 0x94
    4ac4:	0028      	movs	r0, r5
    4ac6:	f000 ff0b 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    4aca:	0020      	movs	r0, r4
    4acc:	f7ff f8fe 	bl	3ccc <z_spin_lock_set_owner>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4ad0:	227f      	movs	r2, #127	; 0x7f

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
    4ad2:	4d31      	ldr	r5, [pc, #196]	; (4b98 <z_impl_k_yield+0x124>)
	_priq_run_remove(thread_runq(thread), thread);
    4ad4:	4e31      	ldr	r6, [pc, #196]	; (4b9c <z_impl_k_yield+0x128>)
		dequeue_thread(_current);
    4ad6:	68a9      	ldr	r1, [r5, #8]
	_priq_run_remove(thread_runq(thread), thread);
    4ad8:	0030      	movs	r0, r6
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4ada:	7b4b      	ldrb	r3, [r1, #13]
    4adc:	4013      	ands	r3, r2
    4ade:	734b      	strb	r3, [r1, #13]
	_priq_run_remove(thread_runq(thread), thread);
    4ae0:	f7ff fccc 	bl	447c <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    4ae4:	2280      	movs	r2, #128	; 0x80
	}
	queue_thread(_current);
    4ae6:	68ab      	ldr	r3, [r5, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
    4ae8:	4252      	negs	r2, r2
    4aea:	7b59      	ldrb	r1, [r3, #13]
    4aec:	430a      	orrs	r2, r1
    4aee:	735a      	strb	r2, [r3, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    4af0:	4a2b      	ldr	r2, [pc, #172]	; (4ba0 <z_impl_k_yield+0x12c>)
    4af2:	4293      	cmp	r3, r2
    4af4:	d108      	bne.n	4b08 <z_impl_k_yield+0x94>
    4af6:	4c1f      	ldr	r4, [pc, #124]	; (4b74 <z_impl_k_yield+0x100>)
    4af8:	492a      	ldr	r1, [pc, #168]	; (4ba4 <z_impl_k_yield+0x130>)
    4afa:	23bc      	movs	r3, #188	; 0xbc
    4afc:	0022      	movs	r2, r4
    4afe:	481f      	ldr	r0, [pc, #124]	; (4b7c <z_impl_k_yield+0x108>)
    4b00:	f000 fef2 	bl	58e8 <assert_print>
    4b04:	21bc      	movs	r1, #188	; 0xbc
    4b06:	e7c5      	b.n	4a94 <z_impl_k_yield+0x20>
	return list->head == list;
    4b08:	69ea      	ldr	r2, [r5, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4b0a:	42b2      	cmp	r2, r6
    4b0c:	d100      	bne.n	4b10 <z_impl_k_yield+0x9c>
    4b0e:	003a      	movs	r2, r7
	return (node == list->tail) ? NULL : node->next;
    4b10:	6a29      	ldr	r1, [r5, #32]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4b12:	2a00      	cmp	r2, #0
    4b14:	d104      	bne.n	4b20 <z_impl_k_yield+0xac>
	node->next = list;
    4b16:	601e      	str	r6, [r3, #0]
	node->prev = tail;
    4b18:	6059      	str	r1, [r3, #4]
	tail->next = node;
    4b1a:	600b      	str	r3, [r1, #0]
	list->tail = node;
    4b1c:	622b      	str	r3, [r5, #32]
}
    4b1e:	e00c      	b.n	4b3a <z_impl_k_yield+0xc6>
	int32_t b1 = thread_1->base.prio;
    4b20:	200e      	movs	r0, #14
	int32_t b2 = thread_2->base.prio;
    4b22:	270e      	movs	r7, #14
	int32_t b1 = thread_1->base.prio;
    4b24:	5618      	ldrsb	r0, [r3, r0]
	int32_t b2 = thread_2->base.prio;
    4b26:	57d7      	ldrsb	r7, [r2, r7]
	if (b1 != b2) {
    4b28:	42b8      	cmp	r0, r7
    4b2a:	d01b      	beq.n	4b64 <z_impl_k_yield+0xf0>
		if (z_sched_prio_cmp(thread, t) > 0) {
    4b2c:	4287      	cmp	r7, r0
    4b2e:	dd19      	ble.n	4b64 <z_impl_k_yield+0xf0>
	sys_dnode_t *const prev = successor->prev;
    4b30:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    4b32:	601a      	str	r2, [r3, #0]
	node->prev = prev;
    4b34:	6059      	str	r1, [r3, #4]
	prev->next = node;
    4b36:	600b      	str	r3, [r1, #0]
	successor->prev = node;
    4b38:	6053      	str	r3, [r2, #4]
	update_cache(1);
    4b3a:	2001      	movs	r0, #1
    4b3c:	f7ff fa50 	bl	3fe0 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4b40:	0020      	movs	r0, r4
    4b42:	f7ff f8b5 	bl	3cb0 <z_spin_unlock_valid>
    4b46:	2800      	cmp	r0, #0
    4b48:	d110      	bne.n	4b6c <z_impl_k_yield+0xf8>
    4b4a:	4d10      	ldr	r5, [pc, #64]	; (4b8c <z_impl_k_yield+0x118>)
    4b4c:	23e2      	movs	r3, #226	; 0xe2
    4b4e:	002a      	movs	r2, r5
    4b50:	4915      	ldr	r1, [pc, #84]	; (4ba8 <z_impl_k_yield+0x134>)
    4b52:	480a      	ldr	r0, [pc, #40]	; (4b7c <z_impl_k_yield+0x108>)
    4b54:	f000 fec8 	bl	58e8 <assert_print>
    4b58:	0021      	movs	r1, r4
    4b5a:	4814      	ldr	r0, [pc, #80]	; (4bac <z_impl_k_yield+0x138>)
    4b5c:	f000 fec4 	bl	58e8 <assert_print>
    4b60:	21e2      	movs	r1, #226	; 0xe2
    4b62:	e7af      	b.n	4ac4 <z_impl_k_yield+0x50>
	return (node == list->tail) ? NULL : node->next;
    4b64:	428a      	cmp	r2, r1
    4b66:	d0d6      	beq.n	4b16 <z_impl_k_yield+0xa2>
    4b68:	6812      	ldr	r2, [r2, #0]
    4b6a:	e7d2      	b.n	4b12 <z_impl_k_yield+0x9e>
    4b6c:	9801      	ldr	r0, [sp, #4]
    4b6e:	f7fc fc99 	bl	14a4 <arch_swap>
	z_swap(&sched_spinlock, key);
}
    4b72:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    4b74:	00006f89 	.word	0x00006f89
    4b78:	00006e6b 	.word	0x00006e6b
    4b7c:	00006347 	.word	0x00006347
    4b80:	00000571 	.word	0x00000571
    4b84:	00006f86 	.word	0x00006f86
    4b88:	20000364 	.word	0x20000364
    4b8c:	00006305 	.word	0x00006305
    4b90:	00006332 	.word	0x00006332
    4b94:	00006364 	.word	0x00006364
    4b98:	20000330 	.word	0x20000330
    4b9c:	2000034c 	.word	0x2000034c
    4ba0:	20000120 	.word	0x20000120
    4ba4:	0000716b 	.word	0x0000716b
    4ba8:	0000637c 	.word	0x0000637c
    4bac:	00006393 	.word	0x00006393

00004bb0 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
    4bb0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    4bb2:	0004      	movs	r4, r0
    4bb4:	000d      	movs	r5, r1
    4bb6:	f3ef 8305 	mrs	r3, IPSR
#ifdef CONFIG_MULTITHREADING
	uint32_t expected_wakeup_ticks;

	__ASSERT(!arch_is_in_isr(), "");
    4bba:	2b00      	cmp	r3, #0
    4bbc:	d00d      	beq.n	4bda <z_tick_sleep+0x2a>
    4bbe:	4c42      	ldr	r4, [pc, #264]	; (4cc8 <z_tick_sleep+0x118>)
    4bc0:	4942      	ldr	r1, [pc, #264]	; (4ccc <z_tick_sleep+0x11c>)
    4bc2:	0022      	movs	r2, r4
    4bc4:	4842      	ldr	r0, [pc, #264]	; (4cd0 <z_tick_sleep+0x120>)
    4bc6:	4b43      	ldr	r3, [pc, #268]	; (4cd4 <z_tick_sleep+0x124>)
    4bc8:	f000 fe8e 	bl	58e8 <assert_print>
    4bcc:	4842      	ldr	r0, [pc, #264]	; (4cd8 <z_tick_sleep+0x128>)
    4bce:	f000 fe8b 	bl	58e8 <assert_print>
    4bd2:	4940      	ldr	r1, [pc, #256]	; (4cd4 <z_tick_sleep+0x124>)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    4bd4:	0020      	movs	r0, r4
    4bd6:	f000 fe83 	bl	58e0 <assert_post_action>

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
    4bda:	0003      	movs	r3, r0
    4bdc:	430b      	orrs	r3, r1
    4bde:	d103      	bne.n	4be8 <z_tick_sleep+0x38>
	z_impl_k_yield();
    4be0:	f7ff ff48 	bl	4a74 <z_impl_k_yield>
		k_yield();
		return 0;
    4be4:	2000      	movs	r0, #0
    4be6:	e06e      	b.n	4cc6 <z_tick_sleep+0x116>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
    4be8:	1c4b      	adds	r3, r1, #1
    4bea:	db1e      	blt.n	4c2a <z_tick_sleep+0x7a>
    4bec:	1c4b      	adds	r3, r1, #1
    4bee:	d101      	bne.n	4bf4 <z_tick_sleep+0x44>
    4bf0:	1c83      	adds	r3, r0, #2
    4bf2:	d31a      	bcc.n	4c2a <z_tick_sleep+0x7a>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    4bf4:	f001 f884 	bl	5d00 <sys_clock_tick_get_32>
    4bf8:	1823      	adds	r3, r4, r0
	} else {
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
    4bfa:	9300      	str	r3, [sp, #0]
    4bfc:	f3ef 8310 	mrs	r3, PRIMASK
    4c00:	b672      	cpsid	i
    4c02:	4e36      	ldr	r6, [pc, #216]	; (4cdc <z_tick_sleep+0x12c>)
    4c04:	9301      	str	r3, [sp, #4]
    4c06:	0030      	movs	r0, r6
    4c08:	f7ff f842 	bl	3c90 <z_spin_lock_valid>
    4c0c:	2800      	cmp	r0, #0
    4c0e:	d110      	bne.n	4c32 <z_tick_sleep+0x82>
    4c10:	4c33      	ldr	r4, [pc, #204]	; (4ce0 <z_tick_sleep+0x130>)
    4c12:	2394      	movs	r3, #148	; 0x94
    4c14:	0022      	movs	r2, r4
    4c16:	4933      	ldr	r1, [pc, #204]	; (4ce4 <z_tick_sleep+0x134>)
    4c18:	482d      	ldr	r0, [pc, #180]	; (4cd0 <z_tick_sleep+0x120>)
    4c1a:	f000 fe65 	bl	58e8 <assert_print>
    4c1e:	0031      	movs	r1, r6
    4c20:	4831      	ldr	r0, [pc, #196]	; (4ce8 <z_tick_sleep+0x138>)
    4c22:	f000 fe61 	bl	58e8 <assert_print>
    4c26:	2194      	movs	r1, #148	; 0x94
    4c28:	e7d4      	b.n	4bd4 <z_tick_sleep+0x24>
    4c2a:	2302      	movs	r3, #2
    4c2c:	425b      	negs	r3, r3
    4c2e:	1b1b      	subs	r3, r3, r4
    4c30:	e7e3      	b.n	4bfa <z_tick_sleep+0x4a>
	z_spin_lock_set_owner(l);
    4c32:	0030      	movs	r0, r6
    4c34:	f7ff f84a 	bl	3ccc <z_spin_lock_set_owner>
	}

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
    4c38:	4f2c      	ldr	r7, [pc, #176]	; (4cec <z_tick_sleep+0x13c>)
    4c3a:	4b2d      	ldr	r3, [pc, #180]	; (4cf0 <z_tick_sleep+0x140>)
    4c3c:	68b8      	ldr	r0, [r7, #8]
    4c3e:	6018      	str	r0, [r3, #0]
#endif
	unready_thread(_current);
    4c40:	f7ff fcf6 	bl	4630 <unready_thread>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    4c44:	0022      	movs	r2, r4
	thread->base.thread_state |= _THREAD_SUSPENDED;
    4c46:	2410      	movs	r4, #16
	z_add_thread_timeout(_current, timeout);
    4c48:	68b8      	ldr	r0, [r7, #8]
    4c4a:	002b      	movs	r3, r5
    4c4c:	3018      	adds	r0, #24
    4c4e:	4929      	ldr	r1, [pc, #164]	; (4cf4 <z_tick_sleep+0x144>)
    4c50:	f000 fa72 	bl	5138 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    4c54:	68ba      	ldr	r2, [r7, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4c56:	0030      	movs	r0, r6
    4c58:	7b53      	ldrb	r3, [r2, #13]
    4c5a:	4323      	orrs	r3, r4
    4c5c:	7353      	strb	r3, [r2, #13]
    4c5e:	f7ff f827 	bl	3cb0 <z_spin_unlock_valid>
    4c62:	2800      	cmp	r0, #0
    4c64:	d10c      	bne.n	4c80 <z_tick_sleep+0xd0>
    4c66:	4c1e      	ldr	r4, [pc, #120]	; (4ce0 <z_tick_sleep+0x130>)
    4c68:	23e2      	movs	r3, #226	; 0xe2
    4c6a:	0022      	movs	r2, r4
    4c6c:	4922      	ldr	r1, [pc, #136]	; (4cf8 <z_tick_sleep+0x148>)
    4c6e:	4818      	ldr	r0, [pc, #96]	; (4cd0 <z_tick_sleep+0x120>)
    4c70:	f000 fe3a 	bl	58e8 <assert_print>
    4c74:	0031      	movs	r1, r6
    4c76:	4821      	ldr	r0, [pc, #132]	; (4cfc <z_tick_sleep+0x14c>)
    4c78:	f000 fe36 	bl	58e8 <assert_print>
    4c7c:	21e2      	movs	r1, #226	; 0xe2
    4c7e:	e7a9      	b.n	4bd4 <z_tick_sleep+0x24>
    4c80:	9801      	ldr	r0, [sp, #4]
    4c82:	f7fc fc0f 	bl	14a4 <arch_swap>
	return (thread->base.thread_state & state) != 0U;
    4c86:	68bb      	ldr	r3, [r7, #8]

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
    4c88:	7b5b      	ldrb	r3, [r3, #13]
    4c8a:	001d      	movs	r5, r3
    4c8c:	4025      	ands	r5, r4
    4c8e:	4223      	tst	r3, r4
    4c90:	d00b      	beq.n	4caa <z_tick_sleep+0xfa>
    4c92:	4c0d      	ldr	r4, [pc, #52]	; (4cc8 <z_tick_sleep+0x118>)
    4c94:	491a      	ldr	r1, [pc, #104]	; (4d00 <z_tick_sleep+0x150>)
    4c96:	0022      	movs	r2, r4
    4c98:	480d      	ldr	r0, [pc, #52]	; (4cd0 <z_tick_sleep+0x120>)
    4c9a:	4b1a      	ldr	r3, [pc, #104]	; (4d04 <z_tick_sleep+0x154>)
    4c9c:	f000 fe24 	bl	58e8 <assert_print>
    4ca0:	480d      	ldr	r0, [pc, #52]	; (4cd8 <z_tick_sleep+0x128>)
    4ca2:	f000 fe21 	bl	58e8 <assert_print>
    4ca6:	4917      	ldr	r1, [pc, #92]	; (4d04 <z_tick_sleep+0x154>)
    4ca8:	e794      	b.n	4bd4 <z_tick_sleep+0x24>

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    4caa:	f001 f829 	bl	5d00 <sys_clock_tick_get_32>
    4cae:	002f      	movs	r7, r5
    4cb0:	0006      	movs	r6, r0
    4cb2:	002b      	movs	r3, r5
    4cb4:	9a00      	ldr	r2, [sp, #0]
    4cb6:	1b92      	subs	r2, r2, r6
    4cb8:	41bb      	sbcs	r3, r7
    4cba:	0010      	movs	r0, r2
	if (ticks > 0) {
    4cbc:	2b00      	cmp	r3, #0
    4cbe:	dc02      	bgt.n	4cc6 <z_tick_sleep+0x116>
    4cc0:	d190      	bne.n	4be4 <z_tick_sleep+0x34>
    4cc2:	2a00      	cmp	r2, #0
    4cc4:	d08e      	beq.n	4be4 <z_tick_sleep+0x34>
		return ticks;
	}
#endif

	return 0;
}
    4cc6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    4cc8:	00006f89 	.word	0x00006f89
    4ccc:	00006e6b 	.word	0x00006e6b
    4cd0:	00006347 	.word	0x00006347
    4cd4:	0000058d 	.word	0x0000058d
    4cd8:	00006f86 	.word	0x00006f86
    4cdc:	20000364 	.word	0x20000364
    4ce0:	00006305 	.word	0x00006305
    4ce4:	00006332 	.word	0x00006332
    4ce8:	00006364 	.word	0x00006364
    4cec:	20000330 	.word	0x20000330
    4cf0:	20000358 	.word	0x20000358
    4cf4:	00005cf5 	.word	0x00005cf5
    4cf8:	0000637c 	.word	0x0000637c
    4cfc:	00006393 	.word	0x00006393
    4d00:	00007267 	.word	0x00007267
    4d04:	000005a9 	.word	0x000005a9

00004d08 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
    4d08:	b510      	push	{r4, lr}
    4d0a:	0002      	movs	r2, r0
    4d0c:	000c      	movs	r4, r1
    4d0e:	000b      	movs	r3, r1
    4d10:	f3ef 8105 	mrs	r1, IPSR
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
    4d14:	2900      	cmp	r1, #0
    4d16:	d00f      	beq.n	4d38 <z_impl_k_sleep+0x30>
    4d18:	23b7      	movs	r3, #183	; 0xb7
    4d1a:	4c11      	ldr	r4, [pc, #68]	; (4d60 <z_impl_k_sleep+0x58>)
    4d1c:	4911      	ldr	r1, [pc, #68]	; (4d64 <z_impl_k_sleep+0x5c>)
    4d1e:	0022      	movs	r2, r4
    4d20:	4811      	ldr	r0, [pc, #68]	; (4d68 <z_impl_k_sleep+0x60>)
    4d22:	00db      	lsls	r3, r3, #3
    4d24:	f000 fde0 	bl	58e8 <assert_print>
    4d28:	4810      	ldr	r0, [pc, #64]	; (4d6c <z_impl_k_sleep+0x64>)
    4d2a:	f000 fddd 	bl	58e8 <assert_print>
    4d2e:	21b7      	movs	r1, #183	; 0xb7
    4d30:	0020      	movs	r0, r4
    4d32:	00c9      	lsls	r1, r1, #3
    4d34:	f000 fdd4 	bl	58e0 <assert_post_action>

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    4d38:	3201      	adds	r2, #1
    4d3a:	d107      	bne.n	4d4c <z_impl_k_sleep+0x44>
    4d3c:	3301      	adds	r3, #1
    4d3e:	d105      	bne.n	4d4c <z_impl_k_sleep+0x44>
		k_thread_suspend(_current);
    4d40:	4b0b      	ldr	r3, [pc, #44]	; (4d70 <z_impl_k_sleep+0x68>)
    4d42:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
    4d44:	f7ff fd5a 	bl	47fc <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
    4d48:	0020      	movs	r0, r4
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
    4d4a:	bd10      	pop	{r4, pc}
	ticks = z_tick_sleep(ticks);
    4d4c:	0021      	movs	r1, r4
    4d4e:	f7ff ff2f 	bl	4bb0 <z_tick_sleep>
			return t * ((uint64_t)to_hz / from_hz);
    4d52:	220a      	movs	r2, #10
    4d54:	2300      	movs	r3, #0
	int32_t ret = k_ticks_to_ms_floor64(ticks);
    4d56:	17c1      	asrs	r1, r0, #31
    4d58:	f7fb fad8 	bl	30c <__aeabi_lmul>
	return ret;
    4d5c:	e7f5      	b.n	4d4a <z_impl_k_sleep+0x42>
    4d5e:	46c0      	nop			; (mov r8, r8)
    4d60:	00006f89 	.word	0x00006f89
    4d64:	00006e6b 	.word	0x00006e6b
    4d68:	00006347 	.word	0x00006347
    4d6c:	00006f86 	.word	0x00006f86
    4d70:	20000330 	.word	0x20000330

00004d74 <z_impl_z_current_get>:
	 * local interrupts when reading it.
	 */
	unsigned int k = arch_irq_lock();
#endif

	k_tid_t ret = _current_cpu->current;
    4d74:	4b01      	ldr	r3, [pc, #4]	; (4d7c <z_impl_z_current_get+0x8>)

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
    4d76:	6898      	ldr	r0, [r3, #8]
}
    4d78:	4770      	bx	lr
    4d7a:	46c0      	nop			; (mov r8, r8)
    4d7c:	20000330 	.word	0x20000330

00004d80 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    4d80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4d82:	0004      	movs	r4, r0
    4d84:	f3ef 8710 	mrs	r7, PRIMASK
    4d88:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    4d8a:	4d58      	ldr	r5, [pc, #352]	; (4eec <z_thread_abort+0x16c>)
    4d8c:	0028      	movs	r0, r5
    4d8e:	f7fe ff7f 	bl	3c90 <z_spin_lock_valid>
    4d92:	2800      	cmp	r0, #0
    4d94:	d10e      	bne.n	4db4 <z_thread_abort+0x34>
    4d96:	4c56      	ldr	r4, [pc, #344]	; (4ef0 <z_thread_abort+0x170>)
    4d98:	2394      	movs	r3, #148	; 0x94
    4d9a:	0022      	movs	r2, r4
    4d9c:	4955      	ldr	r1, [pc, #340]	; (4ef4 <z_thread_abort+0x174>)
    4d9e:	4856      	ldr	r0, [pc, #344]	; (4ef8 <z_thread_abort+0x178>)
    4da0:	f000 fda2 	bl	58e8 <assert_print>
    4da4:	0029      	movs	r1, r5
    4da6:	4855      	ldr	r0, [pc, #340]	; (4efc <z_thread_abort+0x17c>)
    4da8:	f000 fd9e 	bl	58e8 <assert_print>
    4dac:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4dae:	0020      	movs	r0, r4
    4db0:	f000 fd96 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    4db4:	0028      	movs	r0, r5
    4db6:	f7fe ff89 	bl	3ccc <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
    4dba:	7b23      	ldrb	r3, [r4, #12]
    4dbc:	07db      	lsls	r3, r3, #31
    4dbe:	d524      	bpl.n	4e0a <z_thread_abort+0x8a>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4dc0:	0028      	movs	r0, r5
    4dc2:	f7fe ff75 	bl	3cb0 <z_spin_unlock_valid>
    4dc6:	2800      	cmp	r0, #0
    4dc8:	d10c      	bne.n	4de4 <z_thread_abort+0x64>
    4dca:	4c49      	ldr	r4, [pc, #292]	; (4ef0 <z_thread_abort+0x170>)
    4dcc:	23c3      	movs	r3, #195	; 0xc3
    4dce:	0022      	movs	r2, r4
    4dd0:	494b      	ldr	r1, [pc, #300]	; (4f00 <z_thread_abort+0x180>)
    4dd2:	4849      	ldr	r0, [pc, #292]	; (4ef8 <z_thread_abort+0x178>)
    4dd4:	f000 fd88 	bl	58e8 <assert_print>
    4dd8:	0029      	movs	r1, r5
    4dda:	484a      	ldr	r0, [pc, #296]	; (4f04 <z_thread_abort+0x184>)
    4ddc:	f000 fd84 	bl	58e8 <assert_print>
    4de0:	21c3      	movs	r1, #195	; 0xc3
    4de2:	e7e4      	b.n	4dae <z_thread_abort+0x2e>
	if (key != 0U) {
    4de4:	2f00      	cmp	r7, #0
    4de6:	d102      	bne.n	4dee <z_thread_abort+0x6e>
	__asm__ volatile(
    4de8:	b662      	cpsie	i
    4dea:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
    4dee:	4d46      	ldr	r5, [pc, #280]	; (4f08 <z_thread_abort+0x188>)
    4df0:	4946      	ldr	r1, [pc, #280]	; (4f0c <z_thread_abort+0x18c>)
    4df2:	002a      	movs	r2, r5
    4df4:	4840      	ldr	r0, [pc, #256]	; (4ef8 <z_thread_abort+0x178>)
    4df6:	4b46      	ldr	r3, [pc, #280]	; (4f10 <z_thread_abort+0x190>)
    4df8:	f000 fd76 	bl	58e8 <assert_print>
    4dfc:	0021      	movs	r1, r4
    4dfe:	4845      	ldr	r0, [pc, #276]	; (4f14 <z_thread_abort+0x194>)
    4e00:	f000 fd72 	bl	58e8 <assert_print>
    4e04:	0028      	movs	r0, r5
    4e06:	4942      	ldr	r1, [pc, #264]	; (4f10 <z_thread_abort+0x190>)
    4e08:	e7d2      	b.n	4db0 <z_thread_abort+0x30>
		k_panic();
		return;
	}

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    4e0a:	2308      	movs	r3, #8
    4e0c:	7b62      	ldrb	r2, [r4, #13]
    4e0e:	421a      	tst	r2, r3
    4e10:	d00a      	beq.n	4e28 <z_thread_abort+0xa8>
    4e12:	0028      	movs	r0, r5
    4e14:	f7fe ff4c 	bl	3cb0 <z_spin_unlock_valid>
    4e18:	2800      	cmp	r0, #0
    4e1a:	d0d6      	beq.n	4dca <z_thread_abort+0x4a>
	if (key != 0U) {
    4e1c:	2f00      	cmp	r7, #0
    4e1e:	d102      	bne.n	4e26 <z_thread_abort+0xa6>
	__asm__ volatile(
    4e20:	b662      	cpsie	i
    4e22:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    4e26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
    4e28:	2120      	movs	r1, #32
    4e2a:	0010      	movs	r0, r2
    4e2c:	4388      	bics	r0, r1
    4e2e:	0001      	movs	r1, r0
    4e30:	4319      	orrs	r1, r3
		if (z_is_thread_queued(thread)) {
    4e32:	b248      	sxtb	r0, r1
    4e34:	2800      	cmp	r0, #0
    4e36:	db2f      	blt.n	4e98 <z_thread_abort+0x118>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    4e38:	7361      	strb	r1, [r4, #13]
		if (thread->base.pended_on != NULL) {
    4e3a:	68a3      	ldr	r3, [r4, #8]
    4e3c:	2b00      	cmp	r3, #0
    4e3e:	d002      	beq.n	4e46 <z_thread_abort+0xc6>
			unpend_thread_no_timeout(thread);
    4e40:	0020      	movs	r0, r4
    4e42:	f7ff fd41 	bl	48c8 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
    4e46:	0020      	movs	r0, r4
    4e48:	3018      	adds	r0, #24
    4e4a:	f000 fa33 	bl	52b4 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    4e4e:	0023      	movs	r3, r4
	return list->head == list;
    4e50:	6da6      	ldr	r6, [r4, #88]	; 0x58
    4e52:	3358      	adds	r3, #88	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4e54:	429e      	cmp	r6, r3
    4e56:	d001      	beq.n	4e5c <z_thread_abort+0xdc>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    4e58:	2e00      	cmp	r6, #0
    4e5a:	d126      	bne.n	4eaa <z_thread_abort+0x12a>
		update_cache(1);
    4e5c:	2001      	movs	r0, #1
    4e5e:	f7ff f8bf 	bl	3fe0 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
    4e62:	4b2d      	ldr	r3, [pc, #180]	; (4f18 <z_thread_abort+0x198>)
    4e64:	689b      	ldr	r3, [r3, #8]
    4e66:	42a3      	cmp	r3, r4
    4e68:	d1d3      	bne.n	4e12 <z_thread_abort+0x92>
    4e6a:	f3ef 8305 	mrs	r3, IPSR
    4e6e:	2b00      	cmp	r3, #0
    4e70:	d1cf      	bne.n	4e12 <z_thread_abort+0x92>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4e72:	0028      	movs	r0, r5
    4e74:	f7fe ff1c 	bl	3cb0 <z_spin_unlock_valid>
    4e78:	4e1f      	ldr	r6, [pc, #124]	; (4ef8 <z_thread_abort+0x178>)
    4e7a:	2800      	cmp	r0, #0
    4e7c:	d124      	bne.n	4ec8 <z_thread_abort+0x148>
    4e7e:	4c1c      	ldr	r4, [pc, #112]	; (4ef0 <z_thread_abort+0x170>)
    4e80:	23e2      	movs	r3, #226	; 0xe2
    4e82:	0022      	movs	r2, r4
    4e84:	0030      	movs	r0, r6
    4e86:	491e      	ldr	r1, [pc, #120]	; (4f00 <z_thread_abort+0x180>)
    4e88:	f000 fd2e 	bl	58e8 <assert_print>
    4e8c:	0029      	movs	r1, r5
    4e8e:	481d      	ldr	r0, [pc, #116]	; (4f04 <z_thread_abort+0x184>)
    4e90:	f000 fd2a 	bl	58e8 <assert_print>
    4e94:	21e2      	movs	r1, #226	; 0xe2
    4e96:	e78a      	b.n	4dae <z_thread_abort+0x2e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4e98:	215f      	movs	r1, #95	; 0x5f
    4e9a:	400a      	ands	r2, r1
    4e9c:	4313      	orrs	r3, r2
	_priq_run_remove(thread_runq(thread), thread);
    4e9e:	0021      	movs	r1, r4
    4ea0:	481e      	ldr	r0, [pc, #120]	; (4f1c <z_thread_abort+0x19c>)
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4ea2:	7363      	strb	r3, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
    4ea4:	f7ff faea 	bl	447c <z_priq_dumb_remove>
}
    4ea8:	e7c7      	b.n	4e3a <z_thread_abort+0xba>
		unpend_thread_no_timeout(thread);
    4eaa:	0030      	movs	r0, r6
    4eac:	f7ff fd0c 	bl	48c8 <unpend_thread_no_timeout>
    4eb0:	0030      	movs	r0, r6
    4eb2:	3018      	adds	r0, #24
    4eb4:	f000 f9fe 	bl	52b4 <z_abort_timeout>
    4eb8:	0033      	movs	r3, r6
    4eba:	2200      	movs	r2, #0
    4ebc:	338c      	adds	r3, #140	; 0x8c
		ready_thread(thread);
    4ebe:	0030      	movs	r0, r6
    4ec0:	601a      	str	r2, [r3, #0]
    4ec2:	f7ff f8c7 	bl	4054 <ready_thread>
    4ec6:	e7c2      	b.n	4e4e <z_thread_abort+0xce>
    4ec8:	0038      	movs	r0, r7
    4eca:	f7fc faeb 	bl	14a4 <arch_swap>
		__ASSERT(false, "aborted _current back from dead");
    4ece:	23e0      	movs	r3, #224	; 0xe0
    4ed0:	4c0d      	ldr	r4, [pc, #52]	; (4f08 <z_thread_abort+0x188>)
    4ed2:	490e      	ldr	r1, [pc, #56]	; (4f0c <z_thread_abort+0x18c>)
    4ed4:	0022      	movs	r2, r4
    4ed6:	0030      	movs	r0, r6
    4ed8:	00db      	lsls	r3, r3, #3
    4eda:	f000 fd05 	bl	58e8 <assert_print>
    4ede:	4810      	ldr	r0, [pc, #64]	; (4f20 <z_thread_abort+0x1a0>)
    4ee0:	f000 fd02 	bl	58e8 <assert_print>
    4ee4:	21e0      	movs	r1, #224	; 0xe0
    4ee6:	00c9      	lsls	r1, r1, #3
    4ee8:	e761      	b.n	4dae <z_thread_abort+0x2e>
    4eea:	46c0      	nop			; (mov r8, r8)
    4eec:	20000364 	.word	0x20000364
    4ef0:	00006305 	.word	0x00006305
    4ef4:	00006332 	.word	0x00006332
    4ef8:	00006347 	.word	0x00006347
    4efc:	00006364 	.word	0x00006364
    4f00:	0000637c 	.word	0x0000637c
    4f04:	00006393 	.word	0x00006393
    4f08:	00006f89 	.word	0x00006f89
    4f0c:	00006f16 	.word	0x00006f16
    4f10:	000006ca 	.word	0x000006ca
    4f14:	000072a7 	.word	0x000072a7
    4f18:	20000330 	.word	0x20000330
    4f1c:	2000034c 	.word	0x2000034c
    4f20:	000072c6 	.word	0x000072c6

00004f24 <z_impl_k_thread_join>:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, abort, thread);
}
#endif

int z_impl_k_thread_join(struct k_thread *thread, k_timeout_t timeout)
{
    4f24:	b5f0      	push	{r4, r5, r6, r7, lr}
    4f26:	b085      	sub	sp, #20
    4f28:	0004      	movs	r4, r0
    4f2a:	9200      	str	r2, [sp, #0]
    4f2c:	9301      	str	r3, [sp, #4]
	__asm__ volatile("mrs %0, PRIMASK;"
    4f2e:	f3ef 8610 	mrs	r6, PRIMASK
    4f32:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    4f34:	4d42      	ldr	r5, [pc, #264]	; (5040 <z_impl_k_thread_join+0x11c>)
    4f36:	0028      	movs	r0, r5
    4f38:	f7fe feaa 	bl	3c90 <z_spin_lock_valid>
    4f3c:	2800      	cmp	r0, #0
    4f3e:	d10e      	bne.n	4f5e <z_impl_k_thread_join+0x3a>
    4f40:	4c40      	ldr	r4, [pc, #256]	; (5044 <z_impl_k_thread_join+0x120>)
    4f42:	2394      	movs	r3, #148	; 0x94
    4f44:	0022      	movs	r2, r4
    4f46:	4940      	ldr	r1, [pc, #256]	; (5048 <z_impl_k_thread_join+0x124>)
    4f48:	4840      	ldr	r0, [pc, #256]	; (504c <z_impl_k_thread_join+0x128>)
    4f4a:	f000 fccd 	bl	58e8 <assert_print>
    4f4e:	0029      	movs	r1, r5
    4f50:	483f      	ldr	r0, [pc, #252]	; (5050 <z_impl_k_thread_join+0x12c>)
    4f52:	f000 fcc9 	bl	58e8 <assert_print>
    4f56:	2194      	movs	r1, #148	; 0x94
		ret = -EBUSY;
	} else if ((thread == _current) ||
		   (thread->base.pended_on == &_current->join_queue)) {
		ret = -EDEADLK;
	} else {
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
    4f58:	0020      	movs	r0, r4
    4f5a:	f000 fcc1 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    4f5e:	0028      	movs	r0, r5
    4f60:	f7fe feb4 	bl	3ccc <z_spin_lock_set_owner>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    4f64:	7b63      	ldrb	r3, [r4, #13]
    4f66:	071b      	lsls	r3, r3, #28
    4f68:	d44c      	bmi.n	5004 <z_impl_k_thread_join+0xe0>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    4f6a:	9b00      	ldr	r3, [sp, #0]
    4f6c:	9a01      	ldr	r2, [sp, #4]
    4f6e:	9302      	str	r3, [sp, #8]
    4f70:	9b01      	ldr	r3, [sp, #4]
    4f72:	9303      	str	r3, [sp, #12]
    4f74:	9b00      	ldr	r3, [sp, #0]
    4f76:	4313      	orrs	r3, r2
    4f78:	d057      	beq.n	502a <z_impl_k_thread_join+0x106>
	} else if ((thread == _current) ||
    4f7a:	4f36      	ldr	r7, [pc, #216]	; (5054 <z_impl_k_thread_join+0x130>)
    4f7c:	68b8      	ldr	r0, [r7, #8]
    4f7e:	42a0      	cmp	r0, r4
    4f80:	d056      	beq.n	5030 <z_impl_k_thread_join+0x10c>
    4f82:	0003      	movs	r3, r0
    4f84:	68a2      	ldr	r2, [r4, #8]
    4f86:	3358      	adds	r3, #88	; 0x58
    4f88:	429a      	cmp	r2, r3
    4f8a:	d051      	beq.n	5030 <z_impl_k_thread_join+0x10c>
    4f8c:	f3ef 8305 	mrs	r3, IPSR
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
    4f90:	2b00      	cmp	r3, #0
    4f92:	d00d      	beq.n	4fb0 <z_impl_k_thread_join+0x8c>
    4f94:	23e4      	movs	r3, #228	; 0xe4
    4f96:	4c30      	ldr	r4, [pc, #192]	; (5058 <z_impl_k_thread_join+0x134>)
    4f98:	4930      	ldr	r1, [pc, #192]	; (505c <z_impl_k_thread_join+0x138>)
    4f9a:	0022      	movs	r2, r4
    4f9c:	482b      	ldr	r0, [pc, #172]	; (504c <z_impl_k_thread_join+0x128>)
    4f9e:	00db      	lsls	r3, r3, #3
    4fa0:	f000 fca2 	bl	58e8 <assert_print>
    4fa4:	482e      	ldr	r0, [pc, #184]	; (5060 <z_impl_k_thread_join+0x13c>)
    4fa6:	f000 fc9f 	bl	58e8 <assert_print>
    4faa:	21e4      	movs	r1, #228	; 0xe4
    4fac:	00c9      	lsls	r1, r1, #3
    4fae:	e7d3      	b.n	4f58 <z_impl_k_thread_join+0x34>
		add_to_waitq_locked(_current, &thread->join_queue);
    4fb0:	0021      	movs	r1, r4
    4fb2:	3158      	adds	r1, #88	; 0x58
    4fb4:	f7ff fb56 	bl	4664 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    4fb8:	9b02      	ldr	r3, [sp, #8]
    4fba:	3301      	adds	r3, #1
    4fbc:	d102      	bne.n	4fc4 <z_impl_k_thread_join+0xa0>
    4fbe:	9b03      	ldr	r3, [sp, #12]
    4fc0:	3301      	adds	r3, #1
    4fc2:	d006      	beq.n	4fd2 <z_impl_k_thread_join+0xae>
		add_thread_timeout(_current, timeout);
    4fc4:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    4fc6:	4927      	ldr	r1, [pc, #156]	; (5064 <z_impl_k_thread_join+0x140>)
    4fc8:	9a00      	ldr	r2, [sp, #0]
    4fca:	9b01      	ldr	r3, [sp, #4]
    4fcc:	3018      	adds	r0, #24
    4fce:	f000 f8b3 	bl	5138 <z_add_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4fd2:	0028      	movs	r0, r5
    4fd4:	f7fe fe6c 	bl	3cb0 <z_spin_unlock_valid>
    4fd8:	2800      	cmp	r0, #0
    4fda:	d10c      	bne.n	4ff6 <z_impl_k_thread_join+0xd2>
    4fdc:	4c19      	ldr	r4, [pc, #100]	; (5044 <z_impl_k_thread_join+0x120>)
    4fde:	23e2      	movs	r3, #226	; 0xe2
    4fe0:	0022      	movs	r2, r4
    4fe2:	4921      	ldr	r1, [pc, #132]	; (5068 <z_impl_k_thread_join+0x144>)
    4fe4:	4819      	ldr	r0, [pc, #100]	; (504c <z_impl_k_thread_join+0x128>)
    4fe6:	f000 fc7f 	bl	58e8 <assert_print>
    4fea:	0029      	movs	r1, r5
    4fec:	481f      	ldr	r0, [pc, #124]	; (506c <z_impl_k_thread_join+0x148>)
    4fee:	f000 fc7b 	bl	58e8 <assert_print>
    4ff2:	21e2      	movs	r1, #226	; 0xe2
    4ff4:	e7b0      	b.n	4f58 <z_impl_k_thread_join+0x34>
    4ff6:	0030      	movs	r0, r6
    4ff8:	f7fc fa54 	bl	14a4 <arch_swap>
    4ffc:	0004      	movs	r4, r0

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);

	k_spin_unlock(&sched_spinlock, key);
	return ret;
}
    4ffe:	0020      	movs	r0, r4
    5000:	b005      	add	sp, #20
    5002:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ret = 0;
    5004:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    5006:	0028      	movs	r0, r5
    5008:	f7fe fe52 	bl	3cb0 <z_spin_unlock_valid>
    500c:	2800      	cmp	r0, #0
    500e:	d111      	bne.n	5034 <z_impl_k_thread_join+0x110>
    5010:	4c0c      	ldr	r4, [pc, #48]	; (5044 <z_impl_k_thread_join+0x120>)
    5012:	23c3      	movs	r3, #195	; 0xc3
    5014:	0022      	movs	r2, r4
    5016:	4914      	ldr	r1, [pc, #80]	; (5068 <z_impl_k_thread_join+0x144>)
    5018:	480c      	ldr	r0, [pc, #48]	; (504c <z_impl_k_thread_join+0x128>)
    501a:	f000 fc65 	bl	58e8 <assert_print>
    501e:	0029      	movs	r1, r5
    5020:	4812      	ldr	r0, [pc, #72]	; (506c <z_impl_k_thread_join+0x148>)
    5022:	f000 fc61 	bl	58e8 <assert_print>
    5026:	21c3      	movs	r1, #195	; 0xc3
    5028:	e796      	b.n	4f58 <z_impl_k_thread_join+0x34>
		ret = -EBUSY;
    502a:	2410      	movs	r4, #16
		ret = -EDEADLK;
    502c:	4264      	negs	r4, r4
    502e:	e7ea      	b.n	5006 <z_impl_k_thread_join+0xe2>
    5030:	242d      	movs	r4, #45	; 0x2d
    5032:	e7fb      	b.n	502c <z_impl_k_thread_join+0x108>
	if (key != 0U) {
    5034:	2e00      	cmp	r6, #0
    5036:	d1e2      	bne.n	4ffe <z_impl_k_thread_join+0xda>
	__asm__ volatile(
    5038:	b662      	cpsie	i
    503a:	f3bf 8f6f 	isb	sy
    503e:	e7de      	b.n	4ffe <z_impl_k_thread_join+0xda>
    5040:	20000364 	.word	0x20000364
    5044:	00006305 	.word	0x00006305
    5048:	00006332 	.word	0x00006332
    504c:	00006347 	.word	0x00006347
    5050:	00006364 	.word	0x00006364
    5054:	20000330 	.word	0x20000330
    5058:	00006f89 	.word	0x00006f89
    505c:	00006e6b 	.word	0x00006e6b
    5060:	000072e8 	.word	0x000072e8
    5064:	00005cf5 	.word	0x00005cf5
    5068:	0000637c 	.word	0x0000637c
    506c:	00006393 	.word	0x00006393

00005070 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
    5070:	b510      	push	{r4, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
    5072:	4806      	ldr	r0, [pc, #24]	; (508c <z_data_copy+0x1c>)
    5074:	4a06      	ldr	r2, [pc, #24]	; (5090 <z_data_copy+0x20>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
    5076:	4907      	ldr	r1, [pc, #28]	; (5094 <z_data_copy+0x24>)
		       __data_region_end - __data_region_start);
    5078:	1a12      	subs	r2, r2, r0
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
    507a:	f000 fe10 	bl	5c9e <z_early_memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
    507e:	4a06      	ldr	r2, [pc, #24]	; (5098 <z_data_copy+0x28>)
    5080:	4906      	ldr	r1, [pc, #24]	; (509c <z_data_copy+0x2c>)
    5082:	4807      	ldr	r0, [pc, #28]	; (50a0 <z_data_copy+0x30>)
    5084:	f000 fe0b 	bl	5c9e <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    5088:	bd10      	pop	{r4, pc}
    508a:	46c0      	nop			; (mov r8, r8)
    508c:	20000000 	.word	0x20000000
    5090:	2000008b 	.word	0x2000008b
    5094:	00007370 	.word	0x00007370
    5098:	00000000 	.word	0x00000000
    509c:	00007370 	.word	0x00007370
    50a0:	20000000 	.word	0x20000000

000050a4 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    50a4:	2000      	movs	r0, #0
{
    50a6:	b510      	push	{r4, lr}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    50a8:	4b03      	ldr	r3, [pc, #12]	; (50b8 <elapsed+0x14>)
    50aa:	681b      	ldr	r3, [r3, #0]
    50ac:	4283      	cmp	r3, r0
    50ae:	d101      	bne.n	50b4 <elapsed+0x10>
    50b0:	f7fb fefe 	bl	eb0 <sys_clock_elapsed>
}
    50b4:	bd10      	pop	{r4, pc}
    50b6:	46c0      	nop			; (mov r8, r8)
    50b8:	20000368 	.word	0x20000368

000050bc <next_timeout>:

static int32_t next_timeout(void)
{
    50bc:	b570      	push	{r4, r5, r6, lr}
	return list->head == list;
    50be:	4b0e      	ldr	r3, [pc, #56]	; (50f8 <next_timeout+0x3c>)
    50c0:	681e      	ldr	r6, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    50c2:	429e      	cmp	r6, r3
    50c4:	d103      	bne.n	50ce <next_timeout+0x12>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    50c6:	f7ff ffed 	bl	50a4 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
    50ca:	480c      	ldr	r0, [pc, #48]	; (50fc <next_timeout+0x40>)
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

	return ret;
}
    50cc:	bd70      	pop	{r4, r5, r6, pc}
	int32_t ticks_elapsed = elapsed();
    50ce:	f7ff ffe9 	bl	50a4 <elapsed>
	if ((to == NULL) ||
    50d2:	2e00      	cmp	r6, #0
    50d4:	d0f9      	beq.n	50ca <next_timeout+0xe>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
    50d6:	6932      	ldr	r2, [r6, #16]
    50d8:	6973      	ldr	r3, [r6, #20]
    50da:	0004      	movs	r4, r0
    50dc:	17c5      	asrs	r5, r0, #31
    50de:	1b12      	subs	r2, r2, r4
    50e0:	41ab      	sbcs	r3, r5
	if ((to == NULL) ||
    50e2:	2b00      	cmp	r3, #0
    50e4:	dcf1      	bgt.n	50ca <next_timeout+0xe>
    50e6:	d103      	bne.n	50f0 <next_timeout+0x34>
    50e8:	2180      	movs	r1, #128	; 0x80
    50ea:	0609      	lsls	r1, r1, #24
    50ec:	428a      	cmp	r2, r1
    50ee:	d2ec      	bcs.n	50ca <next_timeout+0xe>
		ret = MAX(0, to->dticks - ticks_elapsed);
    50f0:	43d8      	mvns	r0, r3
    50f2:	17c0      	asrs	r0, r0, #31
    50f4:	4010      	ands	r0, r2
	return ret;
    50f6:	e7e9      	b.n	50cc <next_timeout+0x10>
    50f8:	2000007c 	.word	0x2000007c
    50fc:	7fffffff 	.word	0x7fffffff

00005100 <remove_timeout>:
{
    5100:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    5102:	2800      	cmp	r0, #0
    5104:	d00e      	beq.n	5124 <remove_timeout+0x24>
	return (node == list->tail) ? NULL : node->next;
    5106:	4b0b      	ldr	r3, [pc, #44]	; (5134 <remove_timeout+0x34>)
    5108:	685b      	ldr	r3, [r3, #4]
    510a:	4298      	cmp	r0, r3
    510c:	d00a      	beq.n	5124 <remove_timeout+0x24>
    510e:	6801      	ldr	r1, [r0, #0]
	if (next(t) != NULL) {
    5110:	2900      	cmp	r1, #0
    5112:	d007      	beq.n	5124 <remove_timeout+0x24>
		next(t)->dticks += t->dticks;
    5114:	690a      	ldr	r2, [r1, #16]
    5116:	694b      	ldr	r3, [r1, #20]
    5118:	6904      	ldr	r4, [r0, #16]
    511a:	6945      	ldr	r5, [r0, #20]
    511c:	1912      	adds	r2, r2, r4
    511e:	416b      	adcs	r3, r5
    5120:	610a      	str	r2, [r1, #16]
    5122:	614b      	str	r3, [r1, #20]
	sys_dnode_t *const next = node->next;
    5124:	6803      	ldr	r3, [r0, #0]
	sys_dnode_t *const prev = node->prev;
    5126:	6842      	ldr	r2, [r0, #4]
	prev->next = next;
    5128:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    512a:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    512c:	2300      	movs	r3, #0
    512e:	6003      	str	r3, [r0, #0]
	node->prev = NULL;
    5130:	6043      	str	r3, [r0, #4]
}
    5132:	bd30      	pop	{r4, r5, pc}
    5134:	2000007c 	.word	0x2000007c

00005138 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    5138:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    513a:	0004      	movs	r4, r0
    513c:	0016      	movs	r6, r2
    513e:	001f      	movs	r7, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    5140:	1c53      	adds	r3, r2, #1
    5142:	d102      	bne.n	514a <z_add_timeout+0x12>
    5144:	1c7b      	adds	r3, r7, #1
    5146:	d100      	bne.n	514a <z_add_timeout+0x12>
    5148:	e09a      	b.n	5280 <z_add_timeout+0x148>
	return node->next != NULL;
    514a:	6825      	ldr	r5, [r4, #0]

#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
    514c:	2d00      	cmp	r5, #0
    514e:	d00d      	beq.n	516c <z_add_timeout+0x34>
    5150:	4c4c      	ldr	r4, [pc, #304]	; (5284 <z_add_timeout+0x14c>)
    5152:	494d      	ldr	r1, [pc, #308]	; (5288 <z_add_timeout+0x150>)
    5154:	235e      	movs	r3, #94	; 0x5e
    5156:	0022      	movs	r2, r4
    5158:	484c      	ldr	r0, [pc, #304]	; (528c <z_add_timeout+0x154>)
    515a:	f000 fbc5 	bl	58e8 <assert_print>
    515e:	484c      	ldr	r0, [pc, #304]	; (5290 <z_add_timeout+0x158>)
    5160:	f000 fbc2 	bl	58e8 <assert_print>
    5164:	215e      	movs	r1, #94	; 0x5e
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    5166:	0020      	movs	r0, r4
    5168:	f000 fbba 	bl	58e0 <assert_post_action>
	to->fn = fn;
    516c:	60a1      	str	r1, [r4, #8]
	__asm__ volatile("mrs %0, PRIMASK;"
    516e:	f3ef 8310 	mrs	r3, PRIMASK
    5172:	b672      	cpsid	i
    5174:	9301      	str	r3, [sp, #4]
    5176:	4b47      	ldr	r3, [pc, #284]	; (5294 <z_add_timeout+0x15c>)
    5178:	0018      	movs	r0, r3
    517a:	9300      	str	r3, [sp, #0]
    517c:	f7fe fd88 	bl	3c90 <z_spin_lock_valid>
    5180:	2800      	cmp	r0, #0
    5182:	d10c      	bne.n	519e <z_add_timeout+0x66>
    5184:	4c44      	ldr	r4, [pc, #272]	; (5298 <z_add_timeout+0x160>)
    5186:	2394      	movs	r3, #148	; 0x94
    5188:	0022      	movs	r2, r4
    518a:	4944      	ldr	r1, [pc, #272]	; (529c <z_add_timeout+0x164>)
    518c:	483f      	ldr	r0, [pc, #252]	; (528c <z_add_timeout+0x154>)
    518e:	f000 fbab 	bl	58e8 <assert_print>
    5192:	9900      	ldr	r1, [sp, #0]
    5194:	4842      	ldr	r0, [pc, #264]	; (52a0 <z_add_timeout+0x168>)
    5196:	f000 fba7 	bl	58e8 <assert_print>
    519a:	2194      	movs	r1, #148	; 0x94
    519c:	e7e3      	b.n	5166 <z_add_timeout+0x2e>
	z_spin_lock_set_owner(l);
    519e:	9800      	ldr	r0, [sp, #0]
    51a0:	f7fe fd94 	bl	3ccc <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    51a4:	2f00      	cmp	r7, #0
    51a6:	da23      	bge.n	51f0 <z_add_timeout+0xb8>
    51a8:	1c7b      	adds	r3, r7, #1
    51aa:	d101      	bne.n	51b0 <z_add_timeout+0x78>
    51ac:	1cb3      	adds	r3, r6, #2
    51ae:	d81f      	bhi.n	51f0 <z_add_timeout+0xb8>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    51b0:	4b3c      	ldr	r3, [pc, #240]	; (52a4 <z_add_timeout+0x16c>)
    51b2:	6818      	ldr	r0, [r3, #0]
    51b4:	6859      	ldr	r1, [r3, #4]
    51b6:	2202      	movs	r2, #2
    51b8:	4252      	negs	r2, r2
    51ba:	17d3      	asrs	r3, r2, #31
    51bc:	1a12      	subs	r2, r2, r0
    51be:	418b      	sbcs	r3, r1
    51c0:	1b92      	subs	r2, r2, r6
    51c2:	41bb      	sbcs	r3, r7

			to->dticks = MAX(1, ticks);
    51c4:	2b00      	cmp	r3, #0
    51c6:	dc04      	bgt.n	51d2 <z_add_timeout+0x9a>
    51c8:	d101      	bne.n	51ce <z_add_timeout+0x96>
    51ca:	2a00      	cmp	r2, #0
    51cc:	d101      	bne.n	51d2 <z_add_timeout+0x9a>
    51ce:	2201      	movs	r2, #1
    51d0:	2300      	movs	r3, #0
	return list->head == list;
    51d2:	4f35      	ldr	r7, [pc, #212]	; (52a8 <z_add_timeout+0x170>)
    51d4:	6122      	str	r2, [r4, #16]
    51d6:	6163      	str	r3, [r4, #20]
    51d8:	683b      	ldr	r3, [r7, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    51da:	42bb      	cmp	r3, r7
    51dc:	d000      	beq.n	51e0 <z_add_timeout+0xa8>
    51de:	001d      	movs	r5, r3
	return (node == list->tail) ? NULL : node->next;
    51e0:	687e      	ldr	r6, [r7, #4]
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
		}

		for (t = first(); t != NULL; t = next(t)) {
    51e2:	2d00      	cmp	r5, #0
    51e4:	d10f      	bne.n	5206 <z_add_timeout+0xce>
	node->next = list;
    51e6:	6027      	str	r7, [r4, #0]
	node->prev = tail;
    51e8:	6066      	str	r6, [r4, #4]
	tail->next = node;
    51ea:	6034      	str	r4, [r6, #0]
	list->tail = node;
    51ec:	607c      	str	r4, [r7, #4]
}
    51ee:	e01c      	b.n	522a <z_add_timeout+0xf2>
			to->dticks = timeout.ticks + 1 + elapsed();
    51f0:	f7ff ff58 	bl	50a4 <elapsed>
    51f4:	2201      	movs	r2, #1
    51f6:	2300      	movs	r3, #0
    51f8:	1992      	adds	r2, r2, r6
    51fa:	417b      	adcs	r3, r7
    51fc:	0006      	movs	r6, r0
    51fe:	17c7      	asrs	r7, r0, #31
    5200:	1992      	adds	r2, r2, r6
    5202:	417b      	adcs	r3, r7
    5204:	e7e5      	b.n	51d2 <z_add_timeout+0x9a>
			if (t->dticks > to->dticks) {
    5206:	6928      	ldr	r0, [r5, #16]
    5208:	6969      	ldr	r1, [r5, #20]
    520a:	6922      	ldr	r2, [r4, #16]
    520c:	6963      	ldr	r3, [r4, #20]
    520e:	4299      	cmp	r1, r3
    5210:	dc02      	bgt.n	5218 <z_add_timeout+0xe0>
    5212:	d127      	bne.n	5264 <z_add_timeout+0x12c>
    5214:	4290      	cmp	r0, r2
    5216:	d925      	bls.n	5264 <z_add_timeout+0x12c>
				t->dticks -= to->dticks;
    5218:	1a80      	subs	r0, r0, r2
    521a:	4199      	sbcs	r1, r3
	sys_dnode_t *const prev = successor->prev;
    521c:	686b      	ldr	r3, [r5, #4]
    521e:	6128      	str	r0, [r5, #16]
    5220:	6169      	str	r1, [r5, #20]
	node->prev = prev;
    5222:	6063      	str	r3, [r4, #4]
	node->next = successor;
    5224:	6025      	str	r5, [r4, #0]
	prev->next = node;
    5226:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    5228:	606c      	str	r4, [r5, #4]
	return list->head == list;
    522a:	4a1f      	ldr	r2, [pc, #124]	; (52a8 <z_add_timeout+0x170>)
    522c:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    522e:	4293      	cmp	r3, r2
    5230:	d006      	beq.n	5240 <z_add_timeout+0x108>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    5232:	429c      	cmp	r4, r3
    5234:	d104      	bne.n	5240 <z_add_timeout+0x108>
			sys_clock_set_timeout(next_timeout(), false);
    5236:	f7ff ff41 	bl	50bc <next_timeout>
    523a:	2100      	movs	r1, #0
    523c:	f7fb fdbc 	bl	db8 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    5240:	9800      	ldr	r0, [sp, #0]
    5242:	f7fe fd35 	bl	3cb0 <z_spin_unlock_valid>
    5246:	2800      	cmp	r0, #0
    5248:	d114      	bne.n	5274 <z_add_timeout+0x13c>
    524a:	4c13      	ldr	r4, [pc, #76]	; (5298 <z_add_timeout+0x160>)
    524c:	23c3      	movs	r3, #195	; 0xc3
    524e:	0022      	movs	r2, r4
    5250:	4916      	ldr	r1, [pc, #88]	; (52ac <z_add_timeout+0x174>)
    5252:	480e      	ldr	r0, [pc, #56]	; (528c <z_add_timeout+0x154>)
    5254:	f000 fb48 	bl	58e8 <assert_print>
    5258:	9900      	ldr	r1, [sp, #0]
    525a:	4815      	ldr	r0, [pc, #84]	; (52b0 <z_add_timeout+0x178>)
    525c:	f000 fb44 	bl	58e8 <assert_print>
    5260:	21c3      	movs	r1, #195	; 0xc3
    5262:	e780      	b.n	5166 <z_add_timeout+0x2e>
			to->dticks -= t->dticks;
    5264:	1a12      	subs	r2, r2, r0
    5266:	418b      	sbcs	r3, r1
    5268:	6122      	str	r2, [r4, #16]
    526a:	6163      	str	r3, [r4, #20]
	return (node == list->tail) ? NULL : node->next;
    526c:	42b5      	cmp	r5, r6
    526e:	d0ba      	beq.n	51e6 <z_add_timeout+0xae>
    5270:	682d      	ldr	r5, [r5, #0]
    5272:	e7b6      	b.n	51e2 <z_add_timeout+0xaa>
	if (key != 0U) {
    5274:	9b01      	ldr	r3, [sp, #4]
    5276:	2b00      	cmp	r3, #0
    5278:	d102      	bne.n	5280 <z_add_timeout+0x148>
	__asm__ volatile(
    527a:	b662      	cpsie	i
    527c:	f3bf 8f6f 	isb	sy
		}
	}
}
    5280:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    5282:	46c0      	nop			; (mov r8, r8)
    5284:	000072fd 	.word	0x000072fd
    5288:	00007321 	.word	0x00007321
    528c:	00006347 	.word	0x00006347
    5290:	00006f86 	.word	0x00006f86
    5294:	2000036c 	.word	0x2000036c
    5298:	00006305 	.word	0x00006305
    529c:	00006332 	.word	0x00006332
    52a0:	00006364 	.word	0x00006364
    52a4:	20000258 	.word	0x20000258
    52a8:	2000007c 	.word	0x2000007c
    52ac:	0000637c 	.word	0x0000637c
    52b0:	00006393 	.word	0x00006393

000052b4 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
    52b4:	b570      	push	{r4, r5, r6, lr}
    52b6:	0005      	movs	r5, r0
	__asm__ volatile("mrs %0, PRIMASK;"
    52b8:	f3ef 8610 	mrs	r6, PRIMASK
    52bc:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    52be:	4c1d      	ldr	r4, [pc, #116]	; (5334 <z_abort_timeout+0x80>)
    52c0:	0020      	movs	r0, r4
    52c2:	f7fe fce5 	bl	3c90 <z_spin_lock_valid>
    52c6:	2800      	cmp	r0, #0
    52c8:	d10e      	bne.n	52e8 <z_abort_timeout+0x34>
    52ca:	4d1b      	ldr	r5, [pc, #108]	; (5338 <z_abort_timeout+0x84>)
    52cc:	2394      	movs	r3, #148	; 0x94
    52ce:	002a      	movs	r2, r5
    52d0:	491a      	ldr	r1, [pc, #104]	; (533c <z_abort_timeout+0x88>)
    52d2:	481b      	ldr	r0, [pc, #108]	; (5340 <z_abort_timeout+0x8c>)
    52d4:	f000 fb08 	bl	58e8 <assert_print>
    52d8:	0021      	movs	r1, r4
    52da:	481a      	ldr	r0, [pc, #104]	; (5344 <z_abort_timeout+0x90>)
    52dc:	f000 fb04 	bl	58e8 <assert_print>
    52e0:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    52e2:	0028      	movs	r0, r5
    52e4:	f000 fafc 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    52e8:	0020      	movs	r0, r4
    52ea:	f7fe fcef 	bl	3ccc <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    52ee:	682b      	ldr	r3, [r5, #0]
    52f0:	2b00      	cmp	r3, #0
    52f2:	d015      	beq.n	5320 <z_abort_timeout+0x6c>
			remove_timeout(to);
    52f4:	0028      	movs	r0, r5
    52f6:	f7ff ff03 	bl	5100 <remove_timeout>
			ret = 0;
    52fa:	2500      	movs	r5, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    52fc:	0020      	movs	r0, r4
    52fe:	f7fe fcd7 	bl	3cb0 <z_spin_unlock_valid>
    5302:	2800      	cmp	r0, #0
    5304:	d10f      	bne.n	5326 <z_abort_timeout+0x72>
    5306:	4d0c      	ldr	r5, [pc, #48]	; (5338 <z_abort_timeout+0x84>)
    5308:	23c3      	movs	r3, #195	; 0xc3
    530a:	002a      	movs	r2, r5
    530c:	490e      	ldr	r1, [pc, #56]	; (5348 <z_abort_timeout+0x94>)
    530e:	480c      	ldr	r0, [pc, #48]	; (5340 <z_abort_timeout+0x8c>)
    5310:	f000 faea 	bl	58e8 <assert_print>
    5314:	0021      	movs	r1, r4
    5316:	480d      	ldr	r0, [pc, #52]	; (534c <z_abort_timeout+0x98>)
    5318:	f000 fae6 	bl	58e8 <assert_print>
    531c:	21c3      	movs	r1, #195	; 0xc3
    531e:	e7e0      	b.n	52e2 <z_abort_timeout+0x2e>
	int ret = -EINVAL;
    5320:	2516      	movs	r5, #22
    5322:	426d      	negs	r5, r5
    5324:	e7ea      	b.n	52fc <z_abort_timeout+0x48>
	if (key != 0U) {
    5326:	2e00      	cmp	r6, #0
    5328:	d102      	bne.n	5330 <z_abort_timeout+0x7c>
	__asm__ volatile(
    532a:	b662      	cpsie	i
    532c:	f3bf 8f6f 	isb	sy
		}
	}

	return ret;
}
    5330:	0028      	movs	r0, r5
    5332:	bd70      	pop	{r4, r5, r6, pc}
    5334:	2000036c 	.word	0x2000036c
    5338:	00006305 	.word	0x00006305
    533c:	00006332 	.word	0x00006332
    5340:	00006347 	.word	0x00006347
    5344:	00006364 	.word	0x00006364
    5348:	0000637c 	.word	0x0000637c
    534c:	00006393 	.word	0x00006393

00005350 <z_get_next_timeout_expiry>:

	return ticks;
}

int32_t z_get_next_timeout_expiry(void)
{
    5350:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    5352:	f3ef 8610 	mrs	r6, PRIMASK
    5356:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    5358:	4c19      	ldr	r4, [pc, #100]	; (53c0 <z_get_next_timeout_expiry+0x70>)
    535a:	0020      	movs	r0, r4
    535c:	f7fe fc98 	bl	3c90 <z_spin_lock_valid>
    5360:	2800      	cmp	r0, #0
    5362:	d10e      	bne.n	5382 <z_get_next_timeout_expiry+0x32>
    5364:	4d17      	ldr	r5, [pc, #92]	; (53c4 <z_get_next_timeout_expiry+0x74>)
    5366:	2394      	movs	r3, #148	; 0x94
    5368:	002a      	movs	r2, r5
    536a:	4917      	ldr	r1, [pc, #92]	; (53c8 <z_get_next_timeout_expiry+0x78>)
    536c:	4817      	ldr	r0, [pc, #92]	; (53cc <z_get_next_timeout_expiry+0x7c>)
    536e:	f000 fabb 	bl	58e8 <assert_print>
    5372:	0021      	movs	r1, r4
    5374:	4816      	ldr	r0, [pc, #88]	; (53d0 <z_get_next_timeout_expiry+0x80>)
    5376:	f000 fab7 	bl	58e8 <assert_print>
    537a:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    537c:	0028      	movs	r0, r5
    537e:	f000 faaf 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    5382:	0020      	movs	r0, r4
    5384:	f7fe fca2 	bl	3ccc <z_spin_lock_set_owner>
	int32_t ret = (int32_t) K_TICKS_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
    5388:	f7ff fe98 	bl	50bc <next_timeout>
    538c:	0005      	movs	r5, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    538e:	0020      	movs	r0, r4
    5390:	f7fe fc8e 	bl	3cb0 <z_spin_unlock_valid>
    5394:	2800      	cmp	r0, #0
    5396:	d10c      	bne.n	53b2 <z_get_next_timeout_expiry+0x62>
    5398:	4d0a      	ldr	r5, [pc, #40]	; (53c4 <z_get_next_timeout_expiry+0x74>)
    539a:	23c3      	movs	r3, #195	; 0xc3
    539c:	002a      	movs	r2, r5
    539e:	490d      	ldr	r1, [pc, #52]	; (53d4 <z_get_next_timeout_expiry+0x84>)
    53a0:	480a      	ldr	r0, [pc, #40]	; (53cc <z_get_next_timeout_expiry+0x7c>)
    53a2:	f000 faa1 	bl	58e8 <assert_print>
    53a6:	0021      	movs	r1, r4
    53a8:	480b      	ldr	r0, [pc, #44]	; (53d8 <z_get_next_timeout_expiry+0x88>)
    53aa:	f000 fa9d 	bl	58e8 <assert_print>
    53ae:	21c3      	movs	r1, #195	; 0xc3
    53b0:	e7e4      	b.n	537c <z_get_next_timeout_expiry+0x2c>
	if (key != 0U) {
    53b2:	2e00      	cmp	r6, #0
    53b4:	d102      	bne.n	53bc <z_get_next_timeout_expiry+0x6c>
	__asm__ volatile(
    53b6:	b662      	cpsie	i
    53b8:	f3bf 8f6f 	isb	sy
	}
	return ret;
}
    53bc:	0028      	movs	r0, r5
    53be:	bd70      	pop	{r4, r5, r6, pc}
    53c0:	2000036c 	.word	0x2000036c
    53c4:	00006305 	.word	0x00006305
    53c8:	00006332 	.word	0x00006332
    53cc:	00006347 	.word	0x00006347
    53d0:	00006364 	.word	0x00006364
    53d4:	0000637c 	.word	0x0000637c
    53d8:	00006393 	.word	0x00006393

000053dc <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
    53dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    53de:	0004      	movs	r4, r0
    53e0:	b087      	sub	sp, #28
	__asm__ volatile("mrs %0, PRIMASK;"
    53e2:	f3ef 8310 	mrs	r3, PRIMASK
    53e6:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    53e8:	4d4d      	ldr	r5, [pc, #308]	; (5520 <sys_clock_announce+0x144>)
	k.key = arch_irq_lock();
    53ea:	9301      	str	r3, [sp, #4]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    53ec:	0028      	movs	r0, r5
    53ee:	f7fe fc4f 	bl	3c90 <z_spin_lock_valid>
    53f2:	2800      	cmp	r0, #0
    53f4:	d10e      	bne.n	5414 <sys_clock_announce+0x38>
    53f6:	4c4b      	ldr	r4, [pc, #300]	; (5524 <sys_clock_announce+0x148>)
    53f8:	2394      	movs	r3, #148	; 0x94
    53fa:	0022      	movs	r2, r4
    53fc:	494a      	ldr	r1, [pc, #296]	; (5528 <sys_clock_announce+0x14c>)
    53fe:	484b      	ldr	r0, [pc, #300]	; (552c <sys_clock_announce+0x150>)
    5400:	f000 fa72 	bl	58e8 <assert_print>
    5404:	4946      	ldr	r1, [pc, #280]	; (5520 <sys_clock_announce+0x144>)
    5406:	484a      	ldr	r0, [pc, #296]	; (5530 <sys_clock_announce+0x154>)
    5408:	f000 fa6e 	bl	58e8 <assert_print>
    540c:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    540e:	0020      	movs	r0, r4
    5410:	f000 fa66 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    5414:	0028      	movs	r0, r5
    5416:	f7fe fc59 	bl	3ccc <z_spin_lock_set_owner>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
    541a:	4b46      	ldr	r3, [pc, #280]	; (5534 <sys_clock_announce+0x158>)
    541c:	601c      	str	r4, [r3, #0]
	return list->head == list;
    541e:	4b46      	ldr	r3, [pc, #280]	; (5538 <sys_clock_announce+0x15c>)
    5420:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    5422:	429c      	cmp	r4, r3
    5424:	d100      	bne.n	5428 <sys_clock_announce+0x4c>
    5426:	2400      	movs	r4, #0
	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
    5428:	4b44      	ldr	r3, [pc, #272]	; (553c <sys_clock_announce+0x160>)
    542a:	9304      	str	r3, [sp, #16]
    542c:	6818      	ldr	r0, [r3, #0]
    542e:	6859      	ldr	r1, [r3, #4]
	     (t != NULL) && (t->dticks <= announce_remaining);
    5430:	4b40      	ldr	r3, [pc, #256]	; (5534 <sys_clock_announce+0x158>)
    5432:	681f      	ldr	r7, [r3, #0]
    5434:	9305      	str	r3, [sp, #20]
    5436:	2c00      	cmp	r4, #0
    5438:	d054      	beq.n	54e4 <sys_clock_announce+0x108>
    543a:	6962      	ldr	r2, [r4, #20]
    543c:	6926      	ldr	r6, [r4, #16]
    543e:	17fb      	asrs	r3, r7, #31
    5440:	429a      	cmp	r2, r3
    5442:	dc02      	bgt.n	544a <sys_clock_announce+0x6e>
    5444:	d10a      	bne.n	545c <sys_clock_announce+0x80>
    5446:	42be      	cmp	r6, r7
    5448:	d908      	bls.n	545c <sys_clock_announce+0x80>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
    544a:	001e      	movs	r6, r3
    544c:	6922      	ldr	r2, [r4, #16]
    544e:	6963      	ldr	r3, [r4, #20]
    5450:	003d      	movs	r5, r7
    5452:	1b52      	subs	r2, r2, r5
    5454:	41b3      	sbcs	r3, r6
    5456:	6122      	str	r2, [r4, #16]
    5458:	6163      	str	r3, [r4, #20]
    545a:	e043      	b.n	54e4 <sys_clock_announce+0x108>
		curr_tick += dt;
    545c:	17f3      	asrs	r3, r6, #31
    545e:	9602      	str	r6, [sp, #8]
    5460:	9303      	str	r3, [sp, #12]
    5462:	9a02      	ldr	r2, [sp, #8]
    5464:	9b03      	ldr	r3, [sp, #12]
    5466:	1880      	adds	r0, r0, r2
    5468:	4159      	adcs	r1, r3
		t->dticks = 0;
    546a:	2200      	movs	r2, #0
    546c:	2300      	movs	r3, #0
		curr_tick += dt;
    546e:	4d33      	ldr	r5, [pc, #204]	; (553c <sys_clock_announce+0x160>)
		t->dticks = 0;
    5470:	6122      	str	r2, [r4, #16]
    5472:	6163      	str	r3, [r4, #20]
		curr_tick += dt;
    5474:	6028      	str	r0, [r5, #0]
    5476:	6069      	str	r1, [r5, #4]
		remove_timeout(t);
    5478:	0020      	movs	r0, r4
    547a:	f7ff fe41 	bl	5100 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    547e:	4f28      	ldr	r7, [pc, #160]	; (5520 <sys_clock_announce+0x144>)
    5480:	0038      	movs	r0, r7
    5482:	f7fe fc15 	bl	3cb0 <z_spin_unlock_valid>
    5486:	2800      	cmp	r0, #0
    5488:	d10c      	bne.n	54a4 <sys_clock_announce+0xc8>
    548a:	4c26      	ldr	r4, [pc, #152]	; (5524 <sys_clock_announce+0x148>)
    548c:	23c3      	movs	r3, #195	; 0xc3
    548e:	0022      	movs	r2, r4
    5490:	492b      	ldr	r1, [pc, #172]	; (5540 <sys_clock_announce+0x164>)
    5492:	4826      	ldr	r0, [pc, #152]	; (552c <sys_clock_announce+0x150>)
    5494:	f000 fa28 	bl	58e8 <assert_print>
    5498:	4921      	ldr	r1, [pc, #132]	; (5520 <sys_clock_announce+0x144>)
    549a:	482a      	ldr	r0, [pc, #168]	; (5544 <sys_clock_announce+0x168>)
    549c:	f000 fa24 	bl	58e8 <assert_print>
    54a0:	21c3      	movs	r1, #195	; 0xc3
    54a2:	e7b4      	b.n	540e <sys_clock_announce+0x32>
	if (key != 0U) {
    54a4:	9b01      	ldr	r3, [sp, #4]
    54a6:	2b00      	cmp	r3, #0
    54a8:	d102      	bne.n	54b0 <sys_clock_announce+0xd4>
	__asm__ volatile(
    54aa:	b662      	cpsie	i
    54ac:	f3bf 8f6f 	isb	sy
		t->fn(t);
    54b0:	0020      	movs	r0, r4
    54b2:	68a3      	ldr	r3, [r4, #8]
    54b4:	4798      	blx	r3
	__asm__ volatile("mrs %0, PRIMASK;"
    54b6:	f3ef 8310 	mrs	r3, PRIMASK
    54ba:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    54bc:	0038      	movs	r0, r7
	k.key = arch_irq_lock();
    54be:	9301      	str	r3, [sp, #4]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    54c0:	f7fe fbe6 	bl	3c90 <z_spin_lock_valid>
    54c4:	2800      	cmp	r0, #0
    54c6:	d096      	beq.n	53f6 <sys_clock_announce+0x1a>
	z_spin_lock_set_owner(l);
    54c8:	0038      	movs	r0, r7
    54ca:	f7fe fbff 	bl	3ccc <z_spin_lock_set_owner>
		announce_remaining -= dt;
    54ce:	4b19      	ldr	r3, [pc, #100]	; (5534 <sys_clock_announce+0x158>)
    54d0:	681f      	ldr	r7, [r3, #0]
    54d2:	1bbf      	subs	r7, r7, r6
    54d4:	601f      	str	r7, [r3, #0]
	return list->head == list;
    54d6:	4b18      	ldr	r3, [pc, #96]	; (5538 <sys_clock_announce+0x15c>)
    54d8:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    54da:	429c      	cmp	r4, r3
    54dc:	d1a4      	bne.n	5428 <sys_clock_announce+0x4c>
		curr_tick += dt;
    54de:	4b17      	ldr	r3, [pc, #92]	; (553c <sys_clock_announce+0x160>)
    54e0:	6818      	ldr	r0, [r3, #0]
    54e2:	6859      	ldr	r1, [r3, #4]
	}

	curr_tick += announce_remaining;
    54e4:	003a      	movs	r2, r7
    54e6:	17fb      	asrs	r3, r7, #31
    54e8:	1812      	adds	r2, r2, r0
    54ea:	414b      	adcs	r3, r1
	announce_remaining = 0;
    54ec:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
    54ee:	9904      	ldr	r1, [sp, #16]
    54f0:	600a      	str	r2, [r1, #0]
    54f2:	604b      	str	r3, [r1, #4]
	announce_remaining = 0;
    54f4:	9b05      	ldr	r3, [sp, #20]
    54f6:	601c      	str	r4, [r3, #0]

	sys_clock_set_timeout(next_timeout(), false);
    54f8:	f7ff fde0 	bl	50bc <next_timeout>
    54fc:	0021      	movs	r1, r4
    54fe:	f7fb fc5b 	bl	db8 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    5502:	4807      	ldr	r0, [pc, #28]	; (5520 <sys_clock_announce+0x144>)
    5504:	f7fe fbd4 	bl	3cb0 <z_spin_unlock_valid>
    5508:	42a0      	cmp	r0, r4
    550a:	d0be      	beq.n	548a <sys_clock_announce+0xae>
	if (key != 0U) {
    550c:	9b01      	ldr	r3, [sp, #4]
    550e:	42a3      	cmp	r3, r4
    5510:	d102      	bne.n	5518 <sys_clock_announce+0x13c>
	__asm__ volatile(
    5512:	b662      	cpsie	i
    5514:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
    5518:	f7ff f826 	bl	4568 <z_time_slice>
#endif
}
    551c:	b007      	add	sp, #28
    551e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5520:	2000036c 	.word	0x2000036c
    5524:	00006305 	.word	0x00006305
    5528:	00006332 	.word	0x00006332
    552c:	00006347 	.word	0x00006347
    5530:	00006364 	.word	0x00006364
    5534:	20000368 	.word	0x20000368
    5538:	2000007c 	.word	0x2000007c
    553c:	20000258 	.word	0x20000258
    5540:	0000637c 	.word	0x0000637c
    5544:	00006393 	.word	0x00006393

00005548 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    5548:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    554a:	f3ef 8510 	mrs	r5, PRIMASK
    554e:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    5550:	4c1d      	ldr	r4, [pc, #116]	; (55c8 <sys_clock_tick_get+0x80>)
    5552:	0020      	movs	r0, r4
    5554:	f7fe fb9c 	bl	3c90 <z_spin_lock_valid>
    5558:	2800      	cmp	r0, #0
    555a:	d10e      	bne.n	557a <sys_clock_tick_get+0x32>
    555c:	4d1b      	ldr	r5, [pc, #108]	; (55cc <sys_clock_tick_get+0x84>)
    555e:	2394      	movs	r3, #148	; 0x94
    5560:	002a      	movs	r2, r5
    5562:	491b      	ldr	r1, [pc, #108]	; (55d0 <sys_clock_tick_get+0x88>)
    5564:	481b      	ldr	r0, [pc, #108]	; (55d4 <sys_clock_tick_get+0x8c>)
    5566:	f000 f9bf 	bl	58e8 <assert_print>
    556a:	0021      	movs	r1, r4
    556c:	481a      	ldr	r0, [pc, #104]	; (55d8 <sys_clock_tick_get+0x90>)
    556e:	f000 f9bb 	bl	58e8 <assert_print>
    5572:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    5574:	0028      	movs	r0, r5
    5576:	f000 f9b3 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    557a:	0020      	movs	r0, r4
    557c:	f7fe fba6 	bl	3ccc <z_spin_lock_set_owner>
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
    5580:	f7ff fd90 	bl	50a4 <elapsed>
    5584:	0002      	movs	r2, r0
    5586:	4915      	ldr	r1, [pc, #84]	; (55dc <sys_clock_tick_get+0x94>)
    5588:	17c3      	asrs	r3, r0, #31
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    558a:	0020      	movs	r0, r4
    558c:	680e      	ldr	r6, [r1, #0]
    558e:	684f      	ldr	r7, [r1, #4]
    5590:	18b6      	adds	r6, r6, r2
    5592:	415f      	adcs	r7, r3
    5594:	f7fe fb8c 	bl	3cb0 <z_spin_unlock_valid>
    5598:	2800      	cmp	r0, #0
    559a:	d10c      	bne.n	55b6 <sys_clock_tick_get+0x6e>
    559c:	4d0b      	ldr	r5, [pc, #44]	; (55cc <sys_clock_tick_get+0x84>)
    559e:	23c3      	movs	r3, #195	; 0xc3
    55a0:	002a      	movs	r2, r5
    55a2:	490f      	ldr	r1, [pc, #60]	; (55e0 <sys_clock_tick_get+0x98>)
    55a4:	480b      	ldr	r0, [pc, #44]	; (55d4 <sys_clock_tick_get+0x8c>)
    55a6:	f000 f99f 	bl	58e8 <assert_print>
    55aa:	0021      	movs	r1, r4
    55ac:	480d      	ldr	r0, [pc, #52]	; (55e4 <sys_clock_tick_get+0x9c>)
    55ae:	f000 f99b 	bl	58e8 <assert_print>
    55b2:	21c3      	movs	r1, #195	; 0xc3
    55b4:	e7de      	b.n	5574 <sys_clock_tick_get+0x2c>
	if (key != 0U) {
    55b6:	2d00      	cmp	r5, #0
    55b8:	d102      	bne.n	55c0 <sys_clock_tick_get+0x78>
	__asm__ volatile(
    55ba:	b662      	cpsie	i
    55bc:	f3bf 8f6f 	isb	sy
	}
	return t;
}
    55c0:	0030      	movs	r0, r6
    55c2:	0039      	movs	r1, r7
    55c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    55c6:	46c0      	nop			; (mov r8, r8)
    55c8:	2000036c 	.word	0x2000036c
    55cc:	00006305 	.word	0x00006305
    55d0:	00006332 	.word	0x00006332
    55d4:	00006347 	.word	0x00006347
    55d8:	00006364 	.word	0x00006364
    55dc:	20000258 	.word	0x20000258
    55e0:	0000637c 	.word	0x0000637c
    55e4:	00006393 	.word	0x00006393

000055e8 <z_impl_atomic_cas>:
 * @param new_value value to compare against
 * @return Returns true if <new_value> is written, false otherwise.
 */
bool z_impl_atomic_cas(atomic_t *target, atomic_val_t old_value,
		       atomic_val_t new_value)
{
    55e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    55ea:	0006      	movs	r6, r0
    55ec:	9100      	str	r1, [sp, #0]
    55ee:	9201      	str	r2, [sp, #4]
	__asm__ volatile("mrs %0, PRIMASK;"
    55f0:	f3ef 8710 	mrs	r7, PRIMASK
    55f4:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    55f6:	4c1c      	ldr	r4, [pc, #112]	; (5668 <z_impl_atomic_cas+0x80>)
    55f8:	0020      	movs	r0, r4
    55fa:	f7fe fb49 	bl	3c90 <z_spin_lock_valid>
    55fe:	2800      	cmp	r0, #0
    5600:	d10e      	bne.n	5620 <z_impl_atomic_cas+0x38>
    5602:	4d1a      	ldr	r5, [pc, #104]	; (566c <z_impl_atomic_cas+0x84>)
    5604:	2394      	movs	r3, #148	; 0x94
    5606:	002a      	movs	r2, r5
    5608:	4919      	ldr	r1, [pc, #100]	; (5670 <z_impl_atomic_cas+0x88>)
    560a:	481a      	ldr	r0, [pc, #104]	; (5674 <z_impl_atomic_cas+0x8c>)
    560c:	f000 f96c 	bl	58e8 <assert_print>
    5610:	0021      	movs	r1, r4
    5612:	4819      	ldr	r0, [pc, #100]	; (5678 <z_impl_atomic_cas+0x90>)
    5614:	f000 f968 	bl	58e8 <assert_print>
    5618:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    561a:	0028      	movs	r0, r5
    561c:	f000 f960 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    5620:	0020      	movs	r0, r4
    5622:	f7fe fb53 	bl	3ccc <z_spin_lock_set_owner>
	 */
	BUILD_ASSERT(!IS_ENABLED(CONFIG_SMP));

	key = k_spin_lock(&lock);

	if (*target == old_value) {
    5626:	6833      	ldr	r3, [r6, #0]
    5628:	9a00      	ldr	r2, [sp, #0]
	int ret = false;
    562a:	2500      	movs	r5, #0
	if (*target == old_value) {
    562c:	4293      	cmp	r3, r2
    562e:	d102      	bne.n	5636 <z_impl_atomic_cas+0x4e>
		*target = new_value;
    5630:	9b01      	ldr	r3, [sp, #4]
		ret = true;
    5632:	3501      	adds	r5, #1
		*target = new_value;
    5634:	6033      	str	r3, [r6, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    5636:	0020      	movs	r0, r4
    5638:	f7fe fb3a 	bl	3cb0 <z_spin_unlock_valid>
    563c:	2800      	cmp	r0, #0
    563e:	d10c      	bne.n	565a <z_impl_atomic_cas+0x72>
    5640:	4d0a      	ldr	r5, [pc, #40]	; (566c <z_impl_atomic_cas+0x84>)
    5642:	23c3      	movs	r3, #195	; 0xc3
    5644:	002a      	movs	r2, r5
    5646:	490d      	ldr	r1, [pc, #52]	; (567c <z_impl_atomic_cas+0x94>)
    5648:	480a      	ldr	r0, [pc, #40]	; (5674 <z_impl_atomic_cas+0x8c>)
    564a:	f000 f94d 	bl	58e8 <assert_print>
    564e:	0021      	movs	r1, r4
    5650:	480b      	ldr	r0, [pc, #44]	; (5680 <z_impl_atomic_cas+0x98>)
    5652:	f000 f949 	bl	58e8 <assert_print>
    5656:	21c3      	movs	r1, #195	; 0xc3
    5658:	e7df      	b.n	561a <z_impl_atomic_cas+0x32>
	if (key != 0U) {
    565a:	2f00      	cmp	r7, #0
    565c:	d102      	bne.n	5664 <z_impl_atomic_cas+0x7c>
	__asm__ volatile(
    565e:	b662      	cpsie	i
    5660:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&lock, key);

	return ret;
    5664:	0028      	movs	r0, r5
}
    5666:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    5668:	20000370 	.word	0x20000370
    566c:	00006305 	.word	0x00006305
    5670:	00006332 	.word	0x00006332
    5674:	00006347 	.word	0x00006347
    5678:	00006364 	.word	0x00006364
    567c:	0000637c 	.word	0x0000637c
    5680:	00006393 	.word	0x00006393

00005684 <z_impl_atomic_or>:
 * @param value the value to OR
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_or(atomic_t *target, atomic_val_t value)
{
    5684:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    5686:	0006      	movs	r6, r0
    5688:	000d      	movs	r5, r1
	__asm__ volatile("mrs %0, PRIMASK;"
    568a:	f3ef 8710 	mrs	r7, PRIMASK
    568e:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    5690:	4c1a      	ldr	r4, [pc, #104]	; (56fc <z_impl_atomic_or+0x78>)
    5692:	0020      	movs	r0, r4
    5694:	f7fe fafc 	bl	3c90 <z_spin_lock_valid>
    5698:	2800      	cmp	r0, #0
    569a:	d10e      	bne.n	56ba <z_impl_atomic_or+0x36>
    569c:	4d18      	ldr	r5, [pc, #96]	; (5700 <z_impl_atomic_or+0x7c>)
    569e:	2394      	movs	r3, #148	; 0x94
    56a0:	002a      	movs	r2, r5
    56a2:	4918      	ldr	r1, [pc, #96]	; (5704 <z_impl_atomic_or+0x80>)
    56a4:	4818      	ldr	r0, [pc, #96]	; (5708 <z_impl_atomic_or+0x84>)
    56a6:	f000 f91f 	bl	58e8 <assert_print>
    56aa:	0021      	movs	r1, r4
    56ac:	4817      	ldr	r0, [pc, #92]	; (570c <z_impl_atomic_or+0x88>)
    56ae:	f000 f91b 	bl	58e8 <assert_print>
    56b2:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    56b4:	0028      	movs	r0, r5
    56b6:	f000 f913 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    56ba:	0020      	movs	r0, r4
    56bc:	f7fe fb06 	bl	3ccc <z_spin_lock_set_owner>
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
    56c0:	6833      	ldr	r3, [r6, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    56c2:	0020      	movs	r0, r4
	*target |= value;
    56c4:	431d      	orrs	r5, r3
    56c6:	6035      	str	r5, [r6, #0]
	ret = *target;
    56c8:	9301      	str	r3, [sp, #4]
    56ca:	f7fe faf1 	bl	3cb0 <z_spin_unlock_valid>
    56ce:	2800      	cmp	r0, #0
    56d0:	d10c      	bne.n	56ec <z_impl_atomic_or+0x68>
    56d2:	4d0b      	ldr	r5, [pc, #44]	; (5700 <z_impl_atomic_or+0x7c>)
    56d4:	23c3      	movs	r3, #195	; 0xc3
    56d6:	002a      	movs	r2, r5
    56d8:	490d      	ldr	r1, [pc, #52]	; (5710 <z_impl_atomic_or+0x8c>)
    56da:	480b      	ldr	r0, [pc, #44]	; (5708 <z_impl_atomic_or+0x84>)
    56dc:	f000 f904 	bl	58e8 <assert_print>
    56e0:	0021      	movs	r1, r4
    56e2:	480c      	ldr	r0, [pc, #48]	; (5714 <z_impl_atomic_or+0x90>)
    56e4:	f000 f900 	bl	58e8 <assert_print>
    56e8:	21c3      	movs	r1, #195	; 0xc3
    56ea:	e7e3      	b.n	56b4 <z_impl_atomic_or+0x30>
	if (key != 0U) {
    56ec:	2f00      	cmp	r7, #0
    56ee:	d102      	bne.n	56f6 <z_impl_atomic_or+0x72>
	__asm__ volatile(
    56f0:	b662      	cpsie	i
    56f2:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);

	return ret;
}
    56f6:	9801      	ldr	r0, [sp, #4]
    56f8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    56fa:	46c0      	nop			; (mov r8, r8)
    56fc:	20000370 	.word	0x20000370
    5700:	00006305 	.word	0x00006305
    5704:	00006332 	.word	0x00006332
    5708:	00006347 	.word	0x00006347
    570c:	00006364 	.word	0x00006364
    5710:	0000637c 	.word	0x0000637c
    5714:	00006393 	.word	0x00006393

00005718 <z_impl_atomic_and>:
 * @param value the value to AND
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_and(atomic_t *target, atomic_val_t value)
{
    5718:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    571a:	0006      	movs	r6, r0
    571c:	000d      	movs	r5, r1
	__asm__ volatile("mrs %0, PRIMASK;"
    571e:	f3ef 8710 	mrs	r7, PRIMASK
    5722:	b672      	cpsid	i
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    5724:	4c1a      	ldr	r4, [pc, #104]	; (5790 <z_impl_atomic_and+0x78>)
    5726:	0020      	movs	r0, r4
    5728:	f7fe fab2 	bl	3c90 <z_spin_lock_valid>
    572c:	2800      	cmp	r0, #0
    572e:	d10e      	bne.n	574e <z_impl_atomic_and+0x36>
    5730:	4d18      	ldr	r5, [pc, #96]	; (5794 <z_impl_atomic_and+0x7c>)
    5732:	2394      	movs	r3, #148	; 0x94
    5734:	002a      	movs	r2, r5
    5736:	4918      	ldr	r1, [pc, #96]	; (5798 <z_impl_atomic_and+0x80>)
    5738:	4818      	ldr	r0, [pc, #96]	; (579c <z_impl_atomic_and+0x84>)
    573a:	f000 f8d5 	bl	58e8 <assert_print>
    573e:	0021      	movs	r1, r4
    5740:	4817      	ldr	r0, [pc, #92]	; (57a0 <z_impl_atomic_and+0x88>)
    5742:	f000 f8d1 	bl	58e8 <assert_print>
    5746:	2194      	movs	r1, #148	; 0x94
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    5748:	0028      	movs	r0, r5
    574a:	f000 f8c9 	bl	58e0 <assert_post_action>
	z_spin_lock_set_owner(l);
    574e:	0020      	movs	r0, r4
    5750:	f7fe fabc 	bl	3ccc <z_spin_lock_set_owner>
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
    5754:	6833      	ldr	r3, [r6, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    5756:	0020      	movs	r0, r4
	*target &= value;
    5758:	401d      	ands	r5, r3
    575a:	6035      	str	r5, [r6, #0]
	ret = *target;
    575c:	9301      	str	r3, [sp, #4]
    575e:	f7fe faa7 	bl	3cb0 <z_spin_unlock_valid>
    5762:	2800      	cmp	r0, #0
    5764:	d10c      	bne.n	5780 <z_impl_atomic_and+0x68>
    5766:	4d0b      	ldr	r5, [pc, #44]	; (5794 <z_impl_atomic_and+0x7c>)
    5768:	23c3      	movs	r3, #195	; 0xc3
    576a:	002a      	movs	r2, r5
    576c:	490d      	ldr	r1, [pc, #52]	; (57a4 <z_impl_atomic_and+0x8c>)
    576e:	480b      	ldr	r0, [pc, #44]	; (579c <z_impl_atomic_and+0x84>)
    5770:	f000 f8ba 	bl	58e8 <assert_print>
    5774:	0021      	movs	r1, r4
    5776:	480c      	ldr	r0, [pc, #48]	; (57a8 <z_impl_atomic_and+0x90>)
    5778:	f000 f8b6 	bl	58e8 <assert_print>
    577c:	21c3      	movs	r1, #195	; 0xc3
    577e:	e7e3      	b.n	5748 <z_impl_atomic_and+0x30>
	if (key != 0U) {
    5780:	2f00      	cmp	r7, #0
    5782:	d102      	bne.n	578a <z_impl_atomic_and+0x72>
	__asm__ volatile(
    5784:	b662      	cpsie	i
    5786:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);

	return ret;
}
    578a:	9801      	ldr	r0, [sp, #4]
    578c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    578e:	46c0      	nop			; (mov r8, r8)
    5790:	20000370 	.word	0x20000370
    5794:	00006305 	.word	0x00006305
    5798:	00006332 	.word	0x00006332
    579c:	00006347 	.word	0x00006347
    57a0:	00006364 	.word	0x00006364
    57a4:	0000637c 	.word	0x0000637c
    57a8:	00006393 	.word	0x00006393

000057ac <boot_banner>:
#else
#define BANNER_VERSION KERNEL_VERSION_STRING
#endif

void boot_banner(void)
{
    57ac:	b510      	push	{r4, lr}
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
    57ae:	4802      	ldr	r0, [pc, #8]	; (57b8 <boot_banner+0xc>)
    57b0:	f000 f807 	bl	57c2 <printk>
#endif /* CONFIG_BOOT_BANNER */
}
    57b4:	bd10      	pop	{r4, pc}
    57b6:	46c0      	nop			; (mov r8, r8)
    57b8:	00007341 	.word	0x00007341

000057bc <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
    57bc:	4770      	bx	lr

000057be <arch_printk_char_out>:
}
    57be:	2000      	movs	r0, #0
    57c0:	4770      	bx	lr

000057c2 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
    57c2:	b40f      	push	{r0, r1, r2, r3}
    57c4:	b507      	push	{r0, r1, r2, lr}
    57c6:	a904      	add	r1, sp, #16
    57c8:	c901      	ldmia	r1!, {r0}
	va_list ap;

	va_start(ap, fmt);
    57ca:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
    57cc:	f7fa ff02 	bl	5d4 <vprintk>

	va_end(ap);
}
    57d0:	b003      	add	sp, #12
    57d2:	bc08      	pop	{r3}
    57d4:	b004      	add	sp, #16
    57d6:	4718      	bx	r3

000057d8 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    57d8:	b510      	push	{r4, lr}
    57da:	0004      	movs	r4, r0
    57dc:	0008      	movs	r0, r1
    57de:	0011      	movs	r1, r2
    57e0:	001a      	movs	r2, r3
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    57e2:	47a0      	blx	r4
	return z_impl_z_current_get();
    57e4:	f7ff fac6 	bl	4d74 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
    57e8:	f7fb ffcc 	bl	1784 <z_impl_k_thread_abort>

000057ec <onoff_manager_init>:
	return rv;
}

int onoff_manager_init(struct onoff_manager *mgr,
		       const struct onoff_transitions *transitions)
{
    57ec:	b570      	push	{r4, r5, r6, lr}
    57ee:	0005      	movs	r5, r0
    57f0:	000c      	movs	r4, r1
	if ((mgr == NULL)
    57f2:	2800      	cmp	r0, #0
    57f4:	d00e      	beq.n	5814 <onoff_manager_init+0x28>
	    || (transitions == NULL)
    57f6:	2900      	cmp	r1, #0
    57f8:	d00c      	beq.n	5814 <onoff_manager_init+0x28>
	    || (transitions->start == NULL)
    57fa:	680b      	ldr	r3, [r1, #0]
    57fc:	2b00      	cmp	r3, #0
    57fe:	d009      	beq.n	5814 <onoff_manager_init+0x28>
	    || (transitions->stop == NULL)) {
    5800:	684b      	ldr	r3, [r1, #4]
    5802:	2b00      	cmp	r3, #0
    5804:	d006      	beq.n	5814 <onoff_manager_init+0x28>
		return -EINVAL;
	}

	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
    5806:	2220      	movs	r2, #32
    5808:	2100      	movs	r1, #0
    580a:	f000 f8d5 	bl	59b8 <memset>

	return 0;
    580e:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
    5810:	612c      	str	r4, [r5, #16]
}
    5812:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
    5814:	2016      	movs	r0, #22
    5816:	4240      	negs	r0, r0
    5818:	e7fb      	b.n	5812 <onoff_manager_init+0x26>

0000581a <encode_uint>:
{
    581a:	b5f0      	push	{r4, r5, r6, r7, lr}
    581c:	b085      	sub	sp, #20
    581e:	9001      	str	r0, [sp, #4]
    5820:	9303      	str	r3, [sp, #12]
	bool upcase = isupper((int)conv->specifier) != 0;
    5822:	78d3      	ldrb	r3, [r2, #3]
{
    5824:	0015      	movs	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    5826:	001a      	movs	r2, r3
    5828:	3a41      	subs	r2, #65	; 0x41
    582a:	000f      	movs	r7, r1
	switch (specifier) {
    582c:	2408      	movs	r4, #8
    582e:	9202      	str	r2, [sp, #8]
    5830:	2b6f      	cmp	r3, #111	; 0x6f
    5832:	d00a      	beq.n	584a <encode_uint+0x30>
    5834:	d804      	bhi.n	5840 <encode_uint+0x26>
		return 16;
    5836:	1924      	adds	r4, r4, r4
	switch (specifier) {
    5838:	2b58      	cmp	r3, #88	; 0x58
    583a:	d006      	beq.n	584a <encode_uint+0x30>
		return 10;
    583c:	3c06      	subs	r4, #6
    583e:	e004      	b.n	584a <encode_uint+0x30>
	switch (specifier) {
    5840:	2208      	movs	r2, #8
		return 16;
    5842:	2410      	movs	r4, #16
	switch (specifier) {
    5844:	4393      	bics	r3, r2
    5846:	2b70      	cmp	r3, #112	; 0x70
    5848:	d1f8      	bne.n	583c <encode_uint+0x22>
	char *bp = bps + (bpe - bps);
    584a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
    584c:	0022      	movs	r2, r4
    584e:	2300      	movs	r3, #0
    5850:	0039      	movs	r1, r7
    5852:	9801      	ldr	r0, [sp, #4]
    5854:	f7fa fd16 	bl	284 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    5858:	0013      	movs	r3, r2
    585a:	468c      	mov	ip, r1
    585c:	b2d2      	uxtb	r2, r2
    585e:	2b09      	cmp	r3, #9
    5860:	d81a      	bhi.n	5898 <encode_uint+0x7e>
    5862:	3230      	adds	r2, #48	; 0x30
    5864:	b2d3      	uxtb	r3, r2
    5866:	3e01      	subs	r6, #1
    5868:	7033      	strb	r3, [r6, #0]
	} while ((value != 0) && (bps < bp));
    586a:	2300      	movs	r3, #0
    586c:	42bb      	cmp	r3, r7
    586e:	d102      	bne.n	5876 <encode_uint+0x5c>
    5870:	9b01      	ldr	r3, [sp, #4]
    5872:	429c      	cmp	r4, r3
    5874:	d802      	bhi.n	587c <encode_uint+0x62>
    5876:	9b03      	ldr	r3, [sp, #12]
    5878:	429e      	cmp	r6, r3
    587a:	d80a      	bhi.n	5892 <encode_uint+0x78>
	if (conv->flag_hash) {
    587c:	782b      	ldrb	r3, [r5, #0]
    587e:	069b      	lsls	r3, r3, #26
    5880:	d504      	bpl.n	588c <encode_uint+0x72>
		if (radix == 8) {
    5882:	2c08      	cmp	r4, #8
    5884:	d110      	bne.n	58a8 <encode_uint+0x8e>
			conv->altform_0 = true;
    5886:	78ab      	ldrb	r3, [r5, #2]
    5888:	4323      	orrs	r3, r4
    588a:	70ab      	strb	r3, [r5, #2]
}
    588c:	0030      	movs	r0, r6
    588e:	b005      	add	sp, #20
    5890:	bdf0      	pop	{r4, r5, r6, r7, pc}
		value /= radix;
    5892:	4667      	mov	r7, ip
    5894:	9001      	str	r0, [sp, #4]
    5896:	e7d9      	b.n	584c <encode_uint+0x32>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    5898:	0013      	movs	r3, r2
    589a:	9902      	ldr	r1, [sp, #8]
    589c:	3357      	adds	r3, #87	; 0x57
    589e:	b2db      	uxtb	r3, r3
    58a0:	2919      	cmp	r1, #25
    58a2:	d8e0      	bhi.n	5866 <encode_uint+0x4c>
    58a4:	3237      	adds	r2, #55	; 0x37
    58a6:	e7dd      	b.n	5864 <encode_uint+0x4a>
		} else if (radix == 16) {
    58a8:	2c10      	cmp	r4, #16
    58aa:	d1ef      	bne.n	588c <encode_uint+0x72>
			conv->altform_0c = true;
    58ac:	78ab      	ldrb	r3, [r5, #2]
    58ae:	431c      	orrs	r4, r3
    58b0:	70ac      	strb	r4, [r5, #2]
	return bp;
    58b2:	e7eb      	b.n	588c <encode_uint+0x72>

000058b4 <outs>:
{
    58b4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    58b6:	0007      	movs	r7, r0
    58b8:	0015      	movs	r5, r2
    58ba:	001e      	movs	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    58bc:	0014      	movs	r4, r2
{
    58be:	9101      	str	r1, [sp, #4]
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    58c0:	42a6      	cmp	r6, r4
    58c2:	d806      	bhi.n	58d2 <outs+0x1e>
    58c4:	2e00      	cmp	r6, #0
    58c6:	d001      	beq.n	58cc <outs+0x18>
	return (int)count;
    58c8:	1b60      	subs	r0, r4, r5
    58ca:	e008      	b.n	58de <outs+0x2a>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    58cc:	7823      	ldrb	r3, [r4, #0]
    58ce:	2b00      	cmp	r3, #0
    58d0:	d0fa      	beq.n	58c8 <outs+0x14>
		int rc = out((int)*sp++, ctx);
    58d2:	7820      	ldrb	r0, [r4, #0]
    58d4:	9901      	ldr	r1, [sp, #4]
    58d6:	47b8      	blx	r7
		if (rc < 0) {
    58d8:	3401      	adds	r4, #1
    58da:	2800      	cmp	r0, #0
    58dc:	daf0      	bge.n	58c0 <outs+0xc>
}
    58de:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

000058e0 <assert_post_action>:
	if (k_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
    58e0:	2004      	movs	r0, #4
    58e2:	b662      	cpsie	i
    58e4:	df02      	svc	2
}
    58e6:	4770      	bx	lr

000058e8 <assert_print>:

void assert_print(const char *fmt, ...)
{
    58e8:	b40f      	push	{r0, r1, r2, r3}
    58ea:	b507      	push	{r0, r1, r2, lr}
    58ec:	a904      	add	r1, sp, #16
    58ee:	c901      	ldmia	r1!, {r0}
	va_list ap;

	va_start(ap, fmt);
    58f0:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
    58f2:	f7fa fe6f 	bl	5d4 <vprintk>

	va_end(ap);
}
    58f6:	b003      	add	sp, #12
    58f8:	bc08      	pop	{r3}
    58fa:	b004      	add	sp, #16
    58fc:	4718      	bx	r3

000058fe <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_STRIP_PATHS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    58fe:	4770      	bx	lr

00005900 <z_log_minimal_printk>:
#include <zephyr/sys/printk.h>

#define HEXDUMP_BYTES_IN_LINE 8U

void z_log_minimal_printk(const char *fmt, ...)
{
    5900:	b40f      	push	{r0, r1, r2, r3}
    5902:	b507      	push	{r0, r1, r2, lr}
    5904:	a904      	add	r1, sp, #16
    5906:	c901      	ldmia	r1!, {r0}
	va_list ap;

	va_start(ap, fmt);
    5908:	9101      	str	r1, [sp, #4]
	vprintk(fmt, ap);
    590a:	f7fa fe63 	bl	5d4 <vprintk>
	va_end(ap);
}
    590e:	b003      	add	sp, #12
    5910:	bc08      	pop	{r3}
    5912:	b004      	add	sp, #16
    5914:	4718      	bx	r3

00005916 <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
    5916:	b510      	push	{r4, lr}
    5918:	0001      	movs	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
    591a:	6800      	ldr	r0, [r0, #0]
    591c:	f7fb fd36 	bl	138c <z_arm_fatal_error>
	esf_copy.extra_info = (struct __extra_esf_info) { 0 };
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	z_arm_fatal_error(reason, &esf_copy);
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
}
    5920:	bd10      	pop	{r4, pc}

00005922 <z_irq_spurious>:
 * Installed in all _sw_isr_table slots at boot time. Throws an error if
 * called.
 *
 */
void z_irq_spurious(const void *unused)
{
    5922:	b510      	push	{r4, lr}
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    5924:	2100      	movs	r1, #0
    5926:	2001      	movs	r0, #1
    5928:	f7fb fd30 	bl	138c <z_arm_fatal_error>
}
    592c:	bd10      	pop	{r4, pc}

0000592e <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
    592e:	b510      	push	{r4, lr}
	handler();
    5930:	f7fb fdb6 	bl	14a0 <z_SysNmiOnReset>
	z_arm_int_exit();
    5934:	f7fb fe60 	bl	15f8 <z_arm_exc_exit>
}
    5938:	bd10      	pop	{r4, pc}

0000593a <relocate_vector_table>:
	size_t vector_size = (size_t)_vector_end - (size_t)_vector_start;
	(void)memcpy(VECTOR_ADDRESS, _vector_start, vector_size);
#elif defined(CONFIG_SW_VECTOR_RELAY) || defined(CONFIG_SW_VECTOR_RELAY_CLIENT)
	_vector_table_pointer = _vector_start;
#endif
}
    593a:	4770      	bx	lr

0000593c <z_arm_prep_c>:
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
    593c:	b510      	push	{r4, lr}
	relocate_vector_table();
    593e:	f7ff fffc 	bl	593a <relocate_vector_table>
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    5942:	f7fd ffd1 	bl	38e8 <z_bss_zero>
	z_data_copy();
    5946:	f7ff fb93 	bl	5070 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    594a:	f7fb feed 	bl	1728 <z_arm_interrupt_init>
	z_cstart();
    594e:	f7fe f80f 	bl	3970 <z_cstart>

00005952 <z_arm_fault_init>:
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
    5952:	4770      	bx	lr

00005954 <strncpy>:

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
	char *dest = d;

	while ((n > 0) && *s != '\0') {
    5954:	2300      	movs	r3, #0
{
    5956:	b510      	push	{r4, lr}
	while ((n > 0) && *s != '\0') {
    5958:	429a      	cmp	r2, r3
    595a:	d109      	bne.n	5970 <strncpy+0x1c>
    595c:	2200      	movs	r2, #0
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
    595e:	2100      	movs	r1, #0
    5960:	18c3      	adds	r3, r0, r3
    5962:	189a      	adds	r2, r3, r2
	while (n > 0) {
    5964:	4293      	cmp	r3, r2
    5966:	d108      	bne.n	597a <strncpy+0x26>
		d++;
		n--;
	}

	return dest;
}
    5968:	bd10      	pop	{r4, pc}
		*d = *s;
    596a:	54c4      	strb	r4, [r0, r3]
		n--;
    596c:	3301      	adds	r3, #1
    596e:	e7f3      	b.n	5958 <strncpy+0x4>
	while ((n > 0) && *s != '\0') {
    5970:	5ccc      	ldrb	r4, [r1, r3]
    5972:	2c00      	cmp	r4, #0
    5974:	d1f9      	bne.n	596a <strncpy+0x16>
    5976:	1ad2      	subs	r2, r2, r3
    5978:	e7f1      	b.n	595e <strncpy+0xa>
		*d = '\0';
    597a:	7019      	strb	r1, [r3, #0]
		d++;
    597c:	3301      	adds	r3, #1
		n--;
    597e:	e7f1      	b.n	5964 <strncpy+0x10>

00005980 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    5980:	0003      	movs	r3, r0
	size_t n = 0;
    5982:	2000      	movs	r0, #0

	while (*s != '\0') {
    5984:	5c1a      	ldrb	r2, [r3, r0]
    5986:	2a00      	cmp	r2, #0
    5988:	d100      	bne.n	598c <strlen+0xc>
		s++;
		n++;
	}

	return n;
}
    598a:	4770      	bx	lr
		n++;
    598c:	3001      	adds	r0, #1
    598e:	e7f9      	b.n	5984 <strlen+0x4>

00005990 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    5990:	2200      	movs	r2, #0
{
    5992:	b510      	push	{r4, lr}
	while ((*s1 == *s2) && (*s1 != '\0')) {
    5994:	5c83      	ldrb	r3, [r0, r2]
    5996:	5c8c      	ldrb	r4, [r1, r2]
    5998:	42a3      	cmp	r3, r4
    599a:	d102      	bne.n	59a2 <strcmp+0x12>
    599c:	3201      	adds	r2, #1
    599e:	2b00      	cmp	r3, #0
    59a0:	d1f8      	bne.n	5994 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
    59a2:	1b18      	subs	r0, r3, r4
}
    59a4:	bd10      	pop	{r4, pc}

000059a6 <memcpy>:
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
    59a6:	2300      	movs	r3, #0
{
    59a8:	b510      	push	{r4, lr}
	while (n > 0) {
    59aa:	429a      	cmp	r2, r3
    59ac:	d100      	bne.n	59b0 <memcpy+0xa>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    59ae:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
    59b0:	5ccc      	ldrb	r4, [r1, r3]
    59b2:	54c4      	strb	r4, [r0, r3]
		n--;
    59b4:	3301      	adds	r3, #1
    59b6:	e7f8      	b.n	59aa <memcpy+0x4>

000059b8 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    59b8:	0003      	movs	r3, r0
    59ba:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
    59bc:	1882      	adds	r2, r0, r2
    59be:	4293      	cmp	r3, r2
    59c0:	d100      	bne.n	59c4 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    59c2:	4770      	bx	lr
		*(d_byte++) = c_byte;
    59c4:	7019      	strb	r1, [r3, #0]
		n--;
    59c6:	3301      	adds	r3, #1
    59c8:	e7f9      	b.n	59be <memset+0x6>

000059ca <_stdout_hook_default>:
	return EOF;
    59ca:	2001      	movs	r0, #1
}
    59cc:	4240      	negs	r0, r0
    59ce:	4770      	bx	lr

000059d0 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    59d0:	0003      	movs	r3, r0
	size_t n = 0;
    59d2:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
    59d4:	5c1a      	ldrb	r2, [r3, r0]
    59d6:	2a00      	cmp	r2, #0
    59d8:	d001      	beq.n	59de <strnlen+0xe>
    59da:	4288      	cmp	r0, r1
    59dc:	d100      	bne.n	59e0 <strnlen+0x10>
		s++;
		n++;
	}

	return n;
}
    59de:	4770      	bx	lr
		n++;
    59e0:	3001      	adds	r0, #1
    59e2:	e7f7      	b.n	59d4 <strnlen+0x4>

000059e4 <nordicsemi_nrf51_init>:
	__asm__ volatile("mrs %0, PRIMASK;"
    59e4:	f3ef 8310 	mrs	r3, PRIMASK
    59e8:	b672      	cpsid	i
	if (key != 0U) {
    59ea:	2b00      	cmp	r3, #0
    59ec:	d102      	bne.n	59f4 <nordicsemi_nrf51_init+0x10>
	__asm__ volatile(
    59ee:	b662      	cpsie	i
    59f0:	f3bf 8f6f 	isb	sy
}
    59f4:	2000      	movs	r0, #0
    59f6:	4770      	bx	lr

000059f8 <pm_state_set>:
/* Invoke Low Power/System Off specific Tasks */
__weak void pm_state_set(enum pm_state state, uint8_t substate_id)
{
	ARG_UNUSED(substate_id);

	switch (state) {
    59f8:	2806      	cmp	r0, #6
    59fa:	d109      	bne.n	5a10 <pm_state_set+0x18>
#endif // defined(POWER_RAMSTATUS_RAMBLOCK0_Msk)

#if defined(POWER_SYSTEMOFF_SYSTEMOFF_Enter)
NRF_STATIC_INLINE void nrf_power_system_off(NRF_POWER_Type * p_reg)
{
    p_reg->SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
    59fc:	2280      	movs	r2, #128	; 0x80
    59fe:	23a0      	movs	r3, #160	; 0xa0
    5a00:	2101      	movs	r1, #1
    5a02:	05d2      	lsls	r2, r2, #23
    5a04:	00db      	lsls	r3, r3, #3
    5a06:	50d1      	str	r1, [r2, r3]
  __ASM volatile ("dsb 0xF":::"memory");
    5a08:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Solution for simulated System OFF in debug mode */
    while (true)
    {
        __WFE();
    5a0c:	bf20      	wfe
    while (true)
    5a0e:	e7fd      	b.n	5a0c <pm_state_set+0x14>
		break;
	default:
		LOG_DBG("Unsupported power state %u", state);
		break;
	}
}
    5a10:	4770      	bx	lr

00005a12 <pm_state_exit_post_ops>:
    5a12:	b662      	cpsie	i
    5a14:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
    5a18:	4770      	bx	lr

00005a1a <test_main>:
{
    5a1a:	b510      	push	{r4, lr}
	ztest_run_all(NULL);
    5a1c:	2000      	movs	r0, #0
    5a1e:	f7fc f96d 	bl	1cfc <ztest_run_all>
	ztest_verify_all_test_suites_ran();
    5a22:	f7fc f91d 	bl	1c60 <ztest_verify_all_test_suites_ran>
}
    5a26:	bd10      	pop	{r4, pc}

00005a28 <z_ztest_should_suite_run>:
 * @param suite Pointer to ztest_suite_node
 * @return true
 * @return false
 */
bool z_ztest_should_suite_run(const void *state, struct ztest_suite_node *suite)
{
    5a28:	b510      	push	{r4, lr}
	bool run_suite = true;

	if (suite->predicate != NULL) {
    5a2a:	694a      	ldr	r2, [r1, #20]
	bool run_suite = true;
    5a2c:	2301      	movs	r3, #1
	if (suite->predicate != NULL) {
    5a2e:	2a00      	cmp	r2, #0
    5a30:	d001      	beq.n	5a36 <z_ztest_should_suite_run+0xe>
		run_suite = suite->predicate(state);
    5a32:	4790      	blx	r2
    5a34:	0003      	movs	r3, r0
	}

	return run_suite;
}
    5a36:	0018      	movs	r0, r3
    5a38:	bd10      	pop	{r4, pc}

00005a3a <z_ztest_should_test_run>:
 * @return false
 */
bool z_ztest_should_test_run(const char *suite, const char *test)
{
	return true;
}
    5a3a:	2001      	movs	r0, #1
    5a3c:	4770      	bx	lr

00005a3e <z_ztest_run_all>:
{
    5a3e:	b510      	push	{r4, lr}
		union { uintptr_t x; const void * val; } parm0 = { .val = state };
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_ZTEST_RUN_TEST_SUITES);
	}
#endif
	compiler_barrier();
	return z_impl_ztest_run_test_suites(state);
    5a40:	f7fc f8ca 	bl	1bd8 <z_impl_ztest_run_test_suites>
}
    5a44:	bd10      	pop	{r4, pc}

00005a46 <ztest_relative_filename>:
}
    5a46:	4770      	bx	lr

00005a48 <async_start>:
{
    5a48:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    5a4a:	001f      	movs	r7, r3
    5a4c:	9201      	str	r2, [sp, #4]
    5a4e:	b2c9      	uxtb	r1, r1
	struct nrf_clock_control_data *data = dev->data;
    5a50:	6902      	ldr	r2, [r0, #16]
	__asm__ volatile("mrs %0, PRIMASK;"
    5a52:	f3ef 8610 	mrs	r6, PRIMASK
    5a56:	b672      	cpsid	i
	uint32_t current_ctx = GET_CTX(*flags);
    5a58:	250c      	movs	r5, #12
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
    5a5a:	2307      	movs	r3, #7
	uint32_t current_ctx = GET_CTX(*flags);
    5a5c:	434d      	muls	r5, r1
    5a5e:	1955      	adds	r5, r2, r5
    5a60:	6cac      	ldr	r4, [r5, #72]	; 0x48
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
    5a62:	4023      	ands	r3, r4
    5a64:	2b01      	cmp	r3, #1
    5a66:	d111      	bne.n	5a8c <async_start+0x44>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
    5a68:	9b08      	ldr	r3, [sp, #32]
    5a6a:	64ab      	str	r3, [r5, #72]	; 0x48
	if (key != 0U) {
    5a6c:	2e00      	cmp	r6, #0
    5a6e:	d102      	bne.n	5a76 <async_start+0x2e>
	__asm__ volatile(
    5a70:	b662      	cpsie	i
    5a72:	f3bf 8f6f 	isb	sy
	subdata->cb = cb;
    5a76:	230c      	movs	r3, #12
    5a78:	434b      	muls	r3, r1
    5a7a:	9901      	ldr	r1, [sp, #4]
    5a7c:	18d2      	adds	r2, r2, r3
    5a7e:	6411      	str	r1, [r2, #64]	; 0x40
	subdata->user_data = user_data;
    5a80:	6457      	str	r7, [r2, #68]	; 0x44
	 get_sub_config(dev, type)->start();
    5a82:	6842      	ldr	r2, [r0, #4]
    5a84:	589b      	ldr	r3, [r3, r2]
    5a86:	4798      	blx	r3
	return 0;
    5a88:	2000      	movs	r0, #0
    5a8a:	e00b      	b.n	5aa4 <async_start+0x5c>
	uint32_t current_ctx = GET_CTX(*flags);
    5a8c:	23c0      	movs	r3, #192	; 0xc0
    5a8e:	401c      	ands	r4, r3
	} else if (current_ctx != ctx) {
    5a90:	9b08      	ldr	r3, [sp, #32]
    5a92:	42a3      	cmp	r3, r4
    5a94:	d107      	bne.n	5aa6 <async_start+0x5e>
	if (key != 0U) {
    5a96:	2e00      	cmp	r6, #0
    5a98:	d102      	bne.n	5aa0 <async_start+0x58>
	__asm__ volatile(
    5a9a:	b662      	cpsie	i
    5a9c:	f3bf 8f6f 	isb	sy
		err = -EALREADY;
    5aa0:	2078      	movs	r0, #120	; 0x78
		err = -EPERM;
    5aa2:	4240      	negs	r0, r0
}
    5aa4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	if (key != 0U) {
    5aa6:	2e00      	cmp	r6, #0
    5aa8:	d001      	beq.n	5aae <async_start+0x66>
		err = -EPERM;
    5aaa:	2001      	movs	r0, #1
    5aac:	e7f9      	b.n	5aa2 <async_start+0x5a>
	__asm__ volatile(
    5aae:	b662      	cpsie	i
    5ab0:	f3bf 8f6f 	isb	sy
	if (err < 0) {
    5ab4:	e7f9      	b.n	5aaa <async_start+0x62>

00005ab6 <api_start>:
{
    5ab6:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
    5ab8:	2480      	movs	r4, #128	; 0x80
    5aba:	9400      	str	r4, [sp, #0]
    5abc:	f7ff ffc4 	bl	5a48 <async_start>
}
    5ac0:	bd16      	pop	{r1, r2, r4, pc}

00005ac2 <onoff_started_callback>:
{
    5ac2:	b510      	push	{r4, lr}
	return &data->mgr[type];
    5ac4:	b2c9      	uxtb	r1, r1
    5ac6:	6900      	ldr	r0, [r0, #16]
    5ac8:	0149      	lsls	r1, r1, #5
    5aca:	1840      	adds	r0, r0, r1
	notify(mgr, 0);
    5acc:	2100      	movs	r1, #0
    5ace:	4790      	blx	r2
}
    5ad0:	bd10      	pop	{r4, pc}

00005ad2 <lfclk_start>:
{
    5ad2:	b510      	push	{r4, lr}
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
    5ad4:	2000      	movs	r0, #0
    5ad6:	f7fd f8f7 	bl	2cc8 <nrfx_clock_start>
}
    5ada:	bd10      	pop	{r4, pc}

00005adc <lfclk_stop>:
{
    5adc:	b510      	push	{r4, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
    5ade:	2000      	movs	r0, #0
    5ae0:	f7fd f95e 	bl	2da0 <nrfx_clock_stop>
}
    5ae4:	bd10      	pop	{r4, pc}

00005ae6 <blocking_start_callback>:
{
    5ae6:	b510      	push	{r4, lr}
    5ae8:	0010      	movs	r0, r2
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    5aea:	f7fe f923 	bl	3d34 <z_impl_k_sem_give>
}
    5aee:	bd10      	pop	{r4, pc}

00005af0 <api_stop>:
{
    5af0:	b510      	push	{r4, lr}
	return stop(dev, subsys, CTX_API);
    5af2:	2280      	movs	r2, #128	; 0x80
    5af4:	f7fc fa2c 	bl	1f50 <stop>
}
    5af8:	bd10      	pop	{r4, pc}

00005afa <set_on_state>:
	__asm__ volatile("mrs %0, PRIMASK;"
    5afa:	f3ef 8110 	mrs	r1, PRIMASK
    5afe:	b672      	cpsid	i
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
    5b00:	23c0      	movs	r3, #192	; 0xc0
    5b02:	6802      	ldr	r2, [r0, #0]
    5b04:	401a      	ands	r2, r3
    5b06:	3bbe      	subs	r3, #190	; 0xbe
    5b08:	4313      	orrs	r3, r2
    5b0a:	6003      	str	r3, [r0, #0]
	if (key != 0U) {
    5b0c:	2900      	cmp	r1, #0
    5b0e:	d102      	bne.n	5b16 <set_on_state+0x1c>
	__asm__ volatile(
    5b10:	b662      	cpsie	i
    5b12:	f3bf 8f6f 	isb	sy
}
    5b16:	4770      	bx	lr

00005b18 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    5b18:	6843      	ldr	r3, [r0, #4]
}
    5b1a:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    5b1c:	685a      	ldr	r2, [r3, #4]
    return p_reg->IN;
    5b1e:	23a2      	movs	r3, #162	; 0xa2
    5b20:	00db      	lsls	r3, r3, #3
    5b22:	58d3      	ldr	r3, [r2, r3]
	*value = nrf_gpio_port_in_read(reg);
    5b24:	600b      	str	r3, [r1, #0]
}
    5b26:	4770      	bx	lr

00005b28 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    5b28:	6843      	ldr	r3, [r0, #4]
}
    5b2a:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    5b2c:	685a      	ldr	r2, [r3, #4]
    p_reg->OUTSET = set_mask;
    5b2e:	23a1      	movs	r3, #161	; 0xa1
    5b30:	00db      	lsls	r3, r3, #3
    5b32:	50d1      	str	r1, [r2, r3]
}
    5b34:	4770      	bx	lr

00005b36 <pinctrl_lookup_state>:

#include <zephyr/drivers/pinctrl.h>

int pinctrl_lookup_state(const struct pinctrl_dev_config *config, uint8_t id,
			 const struct pinctrl_state **state)
{
    5b36:	b530      	push	{r4, r5, lr}
	*state = &config->states[0];
    5b38:	6843      	ldr	r3, [r0, #4]
    5b3a:	6013      	str	r3, [r2, #0]
	while (*state < &config->states[config->state_cnt]) {
    5b3c:	7a05      	ldrb	r5, [r0, #8]
    5b3e:	6844      	ldr	r4, [r0, #4]
    5b40:	00ed      	lsls	r5, r5, #3
    5b42:	1964      	adds	r4, r4, r5
    5b44:	42a3      	cmp	r3, r4
    5b46:	d302      	bcc.n	5b4e <pinctrl_lookup_state+0x18>
		}

		(*state)++;
	}

	return -ENOENT;
    5b48:	2002      	movs	r0, #2
    5b4a:	4240      	negs	r0, r0
}
    5b4c:	bd30      	pop	{r4, r5, pc}
		if (id == (*state)->id) {
    5b4e:	795c      	ldrb	r4, [r3, #5]
    5b50:	428c      	cmp	r4, r1
    5b52:	d001      	beq.n	5b58 <pinctrl_lookup_state+0x22>
		(*state)++;
    5b54:	3308      	adds	r3, #8
    5b56:	e7f0      	b.n	5b3a <pinctrl_lookup_state+0x4>
			return 0;
    5b58:	2000      	movs	r0, #0
    5b5a:	e7f7      	b.n	5b4c <pinctrl_lookup_state+0x16>

00005b5c <uart_nrfx_config_get>:
{
    5b5c:	b510      	push	{r4, lr}
	struct uart_nrfx_data *data = dev->data;
    5b5e:	6903      	ldr	r3, [r0, #16]
	*cfg = data->uart_config;
    5b60:	cb11      	ldmia	r3!, {r0, r4}
    5b62:	c111      	stmia	r1!, {r0, r4}
}
    5b64:	2000      	movs	r0, #0
    5b66:	bd10      	pop	{r4, pc}

00005b68 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
    5b68:	4770      	bx	lr

00005b6a <custom_lib_get_value>:

int custom_lib_get_value(int return_value_if_nonzero)
{
	return (return_value_if_nonzero != 0) ? return_value_if_nonzero
		: CONFIG_CUSTOM_LIB_GET_VALUE_DEFAULT;
}
    5b6a:	4770      	bx	lr

00005b6c <nrfx_isr>:
#include <nrfx.h>
#include <zephyr/kernel.h>
#include <soc/nrfx_coredep.h>

void nrfx_isr(const void *irq_handler)
{
    5b6c:	b510      	push	{r4, lr}
	((nrfx_irq_handler_t)irq_handler)();
    5b6e:	4780      	blx	r0
}
    5b70:	bd10      	pop	{r4, pc}

00005b72 <nrfx_busy_wait>:

void nrfx_busy_wait(uint32_t usec_to_wait)
{
    5b72:	b510      	push	{r4, lr}
	z_impl_k_busy_wait(usec_to_wait);
    5b74:	f000 f8c8 	bl	5d08 <z_impl_k_busy_wait>
	if (IS_ENABLED(CONFIG_SYS_CLOCK_EXISTS)) {
		k_busy_wait(usec_to_wait);
	} else {
		nrfx_coredep_delay_us(usec_to_wait);
	}
}
    5b78:	bd10      	pop	{r4, pc}

00005b7a <pin_is_task_output>:
{
    5b7a:	b510      	push	{r4, lr}
    5b7c:	0004      	movs	r4, r0
    return pin_is_output(pin) && pin_in_use_by_te(pin);
    5b7e:	f7fd f96d 	bl	2e5c <pin_is_output>
    5b82:	2300      	movs	r3, #0
    5b84:	4298      	cmp	r0, r3
    5b86:	d003      	beq.n	5b90 <pin_is_task_output+0x16>
    5b88:	0020      	movs	r0, r4
    5b8a:	f7fd f95d 	bl	2e48 <pin_in_use_by_te>
    5b8e:	0003      	movs	r3, r0
    5b90:	2001      	movs	r0, #1
    5b92:	4018      	ands	r0, r3
}
    5b94:	bd10      	pop	{r4, pc}

00005b96 <nrf_gpio_reconfigure>:
{
    5b96:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    5b98:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    5b9a:	a801      	add	r0, sp, #4
{
    5b9c:	000e      	movs	r6, r1
    5b9e:	0015      	movs	r5, r2
    5ba0:	001c      	movs	r4, r3
    5ba2:	9f08      	ldr	r7, [sp, #32]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    5ba4:	f7fd f9e0 	bl	2f68 <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number];
    5ba8:	9b01      	ldr	r3, [sp, #4]
    5baa:	009b      	lsls	r3, r3, #2
    5bac:	18c0      	adds	r0, r0, r3
    5bae:	23e0      	movs	r3, #224	; 0xe0
    5bb0:	00db      	lsls	r3, r3, #3
    5bb2:	58c2      	ldr	r2, [r0, r3]
    5bb4:	9200      	str	r2, [sp, #0]
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk                              : 0) |
    5bb6:	002a      	movs	r2, r5
    5bb8:	1e51      	subs	r1, r2, #1
    5bba:	418a      	sbcs	r2, r1
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk                                : 0) |
    5bbc:	0031      	movs	r1, r6
    5bbe:	1e4b      	subs	r3, r1, #1
    5bc0:	4199      	sbcs	r1, r3
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk                              : 0) |
    5bc2:	0052      	lsls	r2, r2, #1
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk                                : 0) |
    5bc4:	430a      	orrs	r2, r1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk                               : 0) |
    5bc6:	0021      	movs	r1, r4
    5bc8:	1e4b      	subs	r3, r1, #1
    5bca:	4199      	sbcs	r1, r3
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk                                : 0) |
    5bcc:	4694      	mov	ip, r2
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk                               : 0) |
    5bce:	220c      	movs	r2, #12
    5bd0:	4249      	negs	r1, r1
    5bd2:	400a      	ands	r2, r1
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk                              : 0) |
    5bd4:	23e0      	movs	r3, #224	; 0xe0
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk                              : 0) |
    5bd6:	4661      	mov	r1, ip
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk                              : 0) |
    5bd8:	00db      	lsls	r3, r3, #3
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk                              : 0) |
    5bda:	430a      	orrs	r2, r1
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk                              : 0) |
    5bdc:	2f00      	cmp	r7, #0
    5bde:	d100      	bne.n	5be2 <nrf_gpio_reconfigure+0x4c>
    5be0:	003b      	movs	r3, r7
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk                               : 0) |
    5be2:	4313      	orrs	r3, r2
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk                              : 0);
    5be4:	9a09      	ldr	r2, [sp, #36]	; 0x24
    5be6:	2a00      	cmp	r2, #0
    5be8:	d001      	beq.n	5bee <nrf_gpio_reconfigure+0x58>
    5bea:	22c0      	movs	r2, #192	; 0xc0
    5bec:	0292      	lsls	r2, r2, #10
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk                                : 0) |
    5bee:	4313      	orrs	r3, r2
    cnf &= ~to_update;
    5bf0:	9a00      	ldr	r2, [sp, #0]
    5bf2:	439a      	bics	r2, r3
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)    |
    5bf4:	1e33      	subs	r3, r6, #0
    5bf6:	d000      	beq.n	5bfa <nrf_gpio_reconfigure+0x64>
    5bf8:	7833      	ldrb	r3, [r6, #0]
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos)  |
    5bfa:	1e2e      	subs	r6, r5, #0
    5bfc:	d001      	beq.n	5c02 <nrf_gpio_reconfigure+0x6c>
    5bfe:	782e      	ldrb	r6, [r5, #0]
    5c00:	0076      	lsls	r6, r6, #1
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)   |
    5c02:	0021      	movs	r1, r4
    5c04:	431a      	orrs	r2, r3
    5c06:	2c00      	cmp	r4, #0
    5c08:	d001      	beq.n	5c0e <nrf_gpio_reconfigure+0x78>
    5c0a:	7821      	ldrb	r1, [r4, #0]
    5c0c:	0089      	lsls	r1, r1, #2
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos)  |
    5c0e:	003b      	movs	r3, r7
    5c10:	4332      	orrs	r2, r6
    5c12:	2f00      	cmp	r7, #0
    5c14:	d001      	beq.n	5c1a <nrf_gpio_reconfigure+0x84>
    5c16:	783b      	ldrb	r3, [r7, #0]
    5c18:	021b      	lsls	r3, r3, #8
    5c1a:	430a      	orrs	r2, r1
           ((uint32_t)(p_sense ? *p_sense : 0)<< GPIO_PIN_CNF_SENSE_Pos);
    5c1c:	9909      	ldr	r1, [sp, #36]	; 0x24
    5c1e:	2900      	cmp	r1, #0
    5c20:	d001      	beq.n	5c26 <nrf_gpio_reconfigure+0x90>
    5c22:	7809      	ldrb	r1, [r1, #0]
    5c24:	0409      	lsls	r1, r1, #16
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)    |
    5c26:	4313      	orrs	r3, r2
    reg->PIN_CNF[pin_number] = cnf;
    5c28:	22e0      	movs	r2, #224	; 0xe0
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)    |
    5c2a:	430b      	orrs	r3, r1
    reg->PIN_CNF[pin_number] = cnf;
    5c2c:	00d2      	lsls	r2, r2, #3
    5c2e:	5083      	str	r3, [r0, r2]
}
    5c30:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

00005c32 <nrf_gpio_cfg_sense_set>:
{
    5c32:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    5c34:	230f      	movs	r3, #15
    5c36:	446b      	add	r3, sp
    5c38:	7019      	strb	r1, [r3, #0]
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
    5c3a:	2100      	movs	r1, #0
    5c3c:	9301      	str	r3, [sp, #4]
    5c3e:	000a      	movs	r2, r1
    5c40:	000b      	movs	r3, r1
    5c42:	9100      	str	r1, [sp, #0]
    5c44:	f7ff ffa7 	bl	5b96 <nrf_gpio_reconfigure>
}
    5c48:	b005      	add	sp, #20
    5c4a:	bd00      	pop	{pc}

00005c4c <nrf_gpio_pin_sense_get>:
{
    5c4c:	b507      	push	{r0, r1, r2, lr}
    5c4e:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    5c50:	a801      	add	r0, sp, #4
    5c52:	f7fd f989 	bl	2f68 <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    5c56:	9b01      	ldr	r3, [sp, #4]
    5c58:	33c1      	adds	r3, #193	; 0xc1
    5c5a:	33ff      	adds	r3, #255	; 0xff
    5c5c:	009b      	lsls	r3, r3, #2
    5c5e:	5818      	ldr	r0, [r3, r0]
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
    5c60:	0380      	lsls	r0, r0, #14
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    5c62:	0f80      	lsrs	r0, r0, #30
}
    5c64:	bd0e      	pop	{r1, r2, r3, pc}

00005c66 <nrf_gpio_ports_read.constprop.0>:
    return p_reg->IN;
    5c66:	22a0      	movs	r2, #160	; 0xa0
    5c68:	23a2      	movs	r3, #162	; 0xa2
    5c6a:	05d2      	lsls	r2, r2, #23
    5c6c:	00db      	lsls	r3, r3, #3
    5c6e:	58d3      	ldr	r3, [r2, r3]
        *p_masks = nrf_gpio_port_in_read(gpio_regs[i]);
    5c70:	6003      	str	r3, [r0, #0]
}
    5c72:	4770      	bx	lr

00005c74 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    5c74:	2800      	cmp	r0, #0
    5c76:	d009      	beq.n	5c8c <z_device_is_ready+0x18>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    5c78:	2301      	movs	r3, #1
    5c7a:	68c2      	ldr	r2, [r0, #12]
    5c7c:	2000      	movs	r0, #0
    5c7e:	7851      	ldrb	r1, [r2, #1]
    5c80:	4219      	tst	r1, r3
    5c82:	d002      	beq.n	5c8a <z_device_is_ready+0x16>
    5c84:	7810      	ldrb	r0, [r2, #0]
    5c86:	4242      	negs	r2, r0
    5c88:	4150      	adcs	r0, r2
    5c8a:	4018      	ands	r0, r3
}
    5c8c:	4770      	bx	lr

00005c8e <arch_system_halt>:
	__asm__ volatile("mrs %0, PRIMASK;"
    5c8e:	f3ef 8310 	mrs	r3, PRIMASK
    5c92:	b672      	cpsid	i
	for (;;) {
    5c94:	e7fe      	b.n	5c94 <arch_system_halt+0x6>

00005c96 <z_early_memset>:
{
    5c96:	b510      	push	{r4, lr}
	(void) memset(dst, c, n);
    5c98:	f7ff fe8e 	bl	59b8 <memset>
}
    5c9c:	bd10      	pop	{r4, pc}

00005c9e <z_early_memcpy>:
{
    5c9e:	b510      	push	{r4, lr}
	(void) memcpy(dst, src, n);
    5ca0:	f7ff fe81 	bl	59a6 <memcpy>
}
    5ca4:	bd10      	pop	{r4, pc}

00005ca6 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    5ca6:	f3ef 8005 	mrs	r0, IPSR
	return (__get_IPSR()) ? (true) : (false);
    5caa:	1e43      	subs	r3, r0, #1
    5cac:	4198      	sbcs	r0, r3
	return arch_is_in_isr();
    5cae:	b2c0      	uxtb	r0, r0
}
    5cb0:	4770      	bx	lr

00005cb2 <k_thread_name_get>:
	return (const char *)thread->name;
    5cb2:	3060      	adds	r0, #96	; 0x60
}
    5cb4:	4770      	bx	lr

00005cb6 <z_impl_k_thread_start>:
{
    5cb6:	b510      	push	{r4, lr}
	z_sched_start(thread);
    5cb8:	f7fe faa6 	bl	4208 <z_sched_start>
}
    5cbc:	bd10      	pop	{r4, pc}

00005cbe <z_pm_save_idle_exit>:
{
    5cbe:	b510      	push	{r4, lr}
	pm_system_resume();
    5cc0:	f7fb f9fe 	bl	10c0 <pm_system_resume>
	sys_clock_idle_exit();
    5cc4:	f7ff ff50 	bl	5b68 <sys_clock_idle_exit>
}
    5cc8:	bd10      	pop	{r4, pc}

00005cca <z_reschedule_irqlock>:
{
    5cca:	b510      	push	{r4, lr}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    5ccc:	2800      	cmp	r0, #0
    5cce:	d105      	bne.n	5cdc <z_reschedule_irqlock+0x12>
    5cd0:	f3ef 8005 	mrs	r0, IPSR
    5cd4:	2800      	cmp	r0, #0
    5cd6:	d102      	bne.n	5cde <z_reschedule_irqlock+0x14>
    5cd8:	f7fb fbe4 	bl	14a4 <arch_swap>
}
    5cdc:	bd10      	pop	{r4, pc}
	__asm__ volatile(
    5cde:	b662      	cpsie	i
    5ce0:	f3bf 8f6f 	isb	sy
    5ce4:	e7fa      	b.n	5cdc <z_reschedule_irqlock+0x12>

00005ce6 <z_reschedule_unlocked>:
{
    5ce6:	b510      	push	{r4, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    5ce8:	f3ef 8010 	mrs	r0, PRIMASK
    5cec:	b672      	cpsid	i
	(void) z_reschedule_irqlock(arch_irq_lock());
    5cee:	f7ff ffec 	bl	5cca <z_reschedule_irqlock>
}
    5cf2:	bd10      	pop	{r4, pc}

00005cf4 <z_thread_timeout>:
{
    5cf4:	b510      	push	{r4, lr}
	z_sched_wake_thread(thread, true);
    5cf6:	2101      	movs	r1, #1
	struct k_thread *thread = CONTAINER_OF(timeout,
    5cf8:	3818      	subs	r0, #24
	z_sched_wake_thread(thread, true);
    5cfa:	f7fe fe07 	bl	490c <z_sched_wake_thread>
}
    5cfe:	bd10      	pop	{r4, pc}

00005d00 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    5d00:	b510      	push	{r4, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    5d02:	f7ff fc21 	bl	5548 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    5d06:	bd10      	pop	{r4, pc}

00005d08 <z_impl_k_busy_wait>:
}
#include <syscalls/k_uptime_ticks_mrsh.c>
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
    5d08:	b510      	push	{r4, lr}
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
    5d0a:	2800      	cmp	r0, #0
    5d0c:	d001      	beq.n	5d12 <z_impl_k_busy_wait+0xa>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
    5d0e:	f7fb fd5b 	bl	17c8 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
    5d12:	bd10      	pop	{r4, pc}
